<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qeuroal.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="教程 本人学习的总原则: 了解功能, 现用现学  以熟练实用为目标, 以查漏补缺为方法, 达到究竟涅槃不可思议的程度  以下的顺序即为学习顺序, 分为看过和感觉不错的   学习顺序推荐  learn vim  zh  不全（第25-29章是没有的）  en    Vim实用技巧必知必会(极客时间吴咏炜)  Vim参考手册 by Bram Molenaar, 译者: Willis 一句话: 布莱姆·">
<meta property="og:type" content="article">
<meta property="og:title" content="153. VIM 从入门到放弃">
<meta property="og:url" content="http://qeuroal.top/2023/06/04/153/index.html">
<meta property="og:site_name" content="Qeuroal&#39;s Blog">
<meta property="og:description" content="教程 本人学习的总原则: 了解功能, 现用现学  以熟练实用为目标, 以查漏补缺为方法, 达到究竟涅槃不可思议的程度  以下的顺序即为学习顺序, 分为看过和感觉不错的   学习顺序推荐  learn vim  zh  不全（第25-29章是没有的）  en    Vim实用技巧必知必会(极客时间吴咏炜)  Vim参考手册 by Bram Molenaar, 译者: Willis 一句话: 布莱姆·">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-04T06:00:00.000Z">
<meta property="article:modified_time" content="2025-10-01T23:18:39.478Z">
<meta property="article:author" content="Qeuroal">
<meta property="article:tag" content="software">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="vim">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://qeuroal.top/2023/06/04/153/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qeuroal.top/2023/06/04/153/","path":"2023/06/04/153/","title":"153. VIM 从入门到放弃"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>153. VIM 从入门到放弃 | Qeuroal's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qeuroal's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">静幽正治</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%99%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">教程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">计数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">插件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#g"><span class="nav-number">4.</span> <span class="nav-text">g</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#first"><span class="nav-number">5.</span> <span class="nav-text">first</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%B8%AE%E5%8A%A9"><span class="nav-number">5.1.</span> <span class="nav-text">更多帮助</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vimrc"><span class="nav-number">5.2.</span> <span class="nav-text">Vimrc</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#start"><span class="nav-number">6.</span> <span class="nav-text">start</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">6.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%87%BAVim"><span class="nav-number">6.2.</span> <span class="nav-text">退出Vim</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6"><span class="nav-number">6.3.</span> <span class="nav-text">保存文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%AE%E5%8A%A9"><span class="nav-number">6.4.</span> <span class="nav-text">帮助</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-number">6.5.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">6.6.</span> <span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC"><span class="nav-number">6.6.1.</span> <span class="nav-text">当前版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF"><span class="nav-number">6.6.1.1.</span> <span class="nav-text">终端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.6.1.2.</span> <span class="nav-text">内部实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2"><span class="nav-number">6.6.2.</span> <span class="nav-text">替换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E7%AA%97%E5%8F%A3"><span class="nav-number">6.7.</span> <span class="nav-text">打开多个窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7"><span class="nav-number">6.8.</span> <span class="nav-text">挂起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E7%9A%84%E5%90%AF%E5%8A%A8Vim"><span class="nav-number">6.9.</span> <span class="nav-text">聪明的启动Vim</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA-Buffers-%EF%BC%8C%E7%AA%97%E5%8F%A3-Windows-%E5%92%8C%E9%80%89%E9%A1%B9%E5%8D%A1-Tabs"><span class="nav-number">7.</span> <span class="nav-text">缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffers"><span class="nav-number">7.1.</span> <span class="nav-text">Buffers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89buffers"><span class="nav-number">7.1.1.</span> <span class="nav-text">遍历所有buffers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4buffer"><span class="nav-number">7.1.2.</span> <span class="nav-text">删除buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%85%E4%BF%9D%E7%95%99%E5%BD%93%E5%89%8D-buffer"><span class="nav-number">7.1.3.</span> <span class="nav-text">仅保留当前 buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%80%E5%87%BAVim-1"><span class="nav-number">7.1.4.</span> <span class="nav-text">退出Vim</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows"><span class="nav-number">7.2.</span> <span class="nav-text">Windows</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%82%A8%E6%83%B3%E5%9C%A8%E7%AA%97%E5%8F%A3%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%9A"><span class="nav-number">7.2.1.</span> <span class="nav-text">如果您想在窗口之间导航，使用这些快捷键：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%AA%97%E5%8F%A3"><span class="nav-number">7.2.2.</span> <span class="nav-text">多窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">普通命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%AA%97%E5%8F%A3"><span class="nav-number">7.2.3.</span> <span class="nav-text">关闭窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">7.2.4.</span> <span class="nav-text">上下窗口最大化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E7%AA%97%E5%8F%A3%E5%AF%B9%E7%AD%89%E5%A4%A7%E5%B0%8F"><span class="nav-number">7.2.5.</span> <span class="nav-text">上下窗口对等大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%8C%96"><span class="nav-number">7.2.6.</span> <span class="nav-text">左右窗口最大化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E7%AA%97%E5%8F%A3%E5%AF%B9%E7%AD%89"><span class="nav-number">7.2.7.</span> <span class="nav-text">左右窗口对等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%BE%AE%E8%B0%83"><span class="nav-number">7.2.8.</span> <span class="nav-text">上下窗口大小微调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%BE%AE%E8%B0%83"><span class="nav-number">7.2.9.</span> <span class="nav-text">左右窗口大小微调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B0%83"><span class="nav-number">7.2.10.</span> <span class="nav-text">窗口对调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E8%BD%AE%E8%BD%AC"><span class="nav-number">7.2.11.</span> <span class="nav-text">窗口轮转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%89%80%E5%9C%A8%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE"><span class="nav-number">7.2.12.</span> <span class="nav-text">移动所在窗口位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%AA%97%E5%8F%A3%E8%B7%B3%E8%BD%AC"><span class="nav-number">7.2.13.</span> <span class="nav-text">不同窗口跳转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tabs"><span class="nav-number">7.3.</span> <span class="nav-text">Tabs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">7.3.1.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tab%E5%90%AF%E5%8A%A8"><span class="nav-number">7.3.2.</span> <span class="nav-text">tab启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%BB%B4%E7%A7%BB%E5%8A%A8"><span class="nav-number">7.4.</span> <span class="nav-text">三维移动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3"><span class="nav-number">7.4.1.</span> <span class="nav-text">窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buffer"><span class="nav-number">7.4.2.</span> <span class="nav-text">buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">7.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">7.5.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%92%8C%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="nav-number">8.</span> <span class="nav-text">打开和搜索文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%92%8C%E7%BC%96%E8%BE%91%E6%96%87%E4%BB%B6"><span class="nav-number">8.1.</span> <span class="nav-text">打开和编辑文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8find%E5%91%BD%E4%BB%A4%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="nav-number">8.2.</span> <span class="nav-text">使用find命令搜索文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="nav-number">8.2.1.</span> <span class="nav-text">搜索文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Find-%E5%92%8C-Path"><span class="nav-number">8.3.</span> <span class="nav-text">Find 和 Path</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">8.3.1.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Grep%E5%91%BD%E4%BB%A4%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E6%90%9C%E7%B4%A2"><span class="nav-number">8.4.</span> <span class="nav-text">使用Grep命令在文件中搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AEgrep"><span class="nav-number">8.4.1.</span> <span class="nav-text">内置grep</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">8.4.1.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E7%BD%AEgrep"><span class="nav-number">8.4.2.</span> <span class="nav-text">外置grep</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8Netrw%E6%B5%8F%E8%A7%88%E6%96%87%E4%BB%B6"><span class="nav-number">8.5.</span> <span class="nav-text">用Netrw浏览文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fzf%E6%8F%92%E4%BB%B6"><span class="nav-number">8.6.</span> <span class="nav-text">Fzf插件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-Vim-%E8%AF%AD%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">第4章 Vim 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E8%AF%AD%E8%A8%80"><span class="nav-number">9.1.</span> <span class="nav-text">如何学习一门语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">9.2.</span> <span class="nav-text">语法规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D-%E5%8A%A8%E4%BD%9C-Motion"><span class="nav-number">9.3.</span> <span class="nav-text">名词(动作 Motion)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E8%AF%8D-%E6%93%8D%E4%BD%9C%E7%AC%A6-Operator"><span class="nav-number">9.4.</span> <span class="nav-text">动词(操作符 Operator)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E8%AF%8D%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AC%A6-Operator%EF%BC%89%E5%92%8C%E5%90%8D%E8%AF%8D%EF%BC%88%E5%8A%A8%E4%BD%9C-motions%EF%BC%89%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">9.5.</span> <span class="nav-text">动词（操作符 Operator）和名词（动作 motions）的结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%90%8D%E8%AF%8D-%E6%96%87%E6%9C%AC%E5%AF%B9%E8%B1%A1-Text-Objects"><span class="nav-number">9.6.</span> <span class="nav-text">更多名词(文本对象 Text Objects)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E6%80%A7%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="nav-number">9.7.</span> <span class="nav-text">结合性和语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E8%AF%AD%E6%B3%95"><span class="nav-number">9.8.</span> <span class="nav-text">聪明地学习语法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%A7%BB%E5%8A%A8"><span class="nav-number">10.</span> <span class="nav-text">第5章 在文件中移动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%AF%BC%E8%88%AA"><span class="nav-number">10.1.</span> <span class="nav-text">字符导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9%E8%A1%8C%E5%8F%B7"><span class="nav-number">10.2.</span> <span class="nav-text">相对行号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">10.3.</span> <span class="nav-text">对移动计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E5%AF%BC%E8%88%AA"><span class="nav-number">10.4.</span> <span class="nav-text">单词导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%A1%8C%E5%AF%BC%E8%88%AA"><span class="nav-number">10.5.</span> <span class="nav-text">当前行导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A5%E5%AD%90%E5%92%8C%E6%AE%B5%E8%90%BD%E5%AF%BC%E8%88%AA"><span class="nav-number">10.6.</span> <span class="nav-text">句子和段落导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AF%BC%E8%88%AA"><span class="nav-number">10.7.</span> <span class="nav-text">匹配导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E5%8F%B7%E5%AF%BC%E8%88%AA"><span class="nav-number">10.8.</span> <span class="nav-text">行号导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E6%A0%BC%E5%AF%BC%E8%88%AA"><span class="nav-number">10.9.</span> <span class="nav-text">窗格导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8"><span class="nav-number">10.10.</span> <span class="nav-text">滚动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%AF%BC%E8%88%AA"><span class="nav-number">10.11.</span> <span class="nav-text">搜索导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E6%A0%87%E8%AE%B0"><span class="nav-number">10.12.</span> <span class="nav-text">位置标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC"><span class="nav-number">10.13.</span> <span class="nav-text">跳转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA"><span class="nav-number">10.14.</span> <span class="nav-text">聪明地学习导航</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">第6章 输入模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">进入输入模式的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">11.2.</span> <span class="nav-text">退出输入模式的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.3.</span> <span class="nav-text">重复输入模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E5%88%A0%E9%99%A4%E5%A4%A7%E5%9D%97%E6%96%87%E6%9C%AC"><span class="nav-number">11.4.</span> <span class="nav-text">在输入模式中删除大块文本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="nav-number">11.5.</span> <span class="nav-text">用寄存器进行输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8"><span class="nav-number">11.6.</span> <span class="nav-text">页面滚动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="nav-number">11.7.</span> <span class="nav-text">自动补全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">11.8.</span> <span class="nav-text">执行普通模式下的命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.9.</span> <span class="nav-text">聪明地学习输入模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E7%82%B9%E5%91%BD%E4%BB%A4"><span class="nav-number">12.</span> <span class="nav-text">第7章 点命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">12.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%89%8D%E7%AE%97%E6%98%AF%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">12.2.</span> <span class="nav-text">什么才算是修改操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%A4%9A%E8%A1%8C%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">12.3.</span> <span class="nav-text">重复多行修改操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E4%BF%AE%E6%94%B9%E4%B8%AD%E5%8C%85%E5%90%AB%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">12.4.</span> <span class="nav-text">在修改中包含移动操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E7%82%B9%E5%91%BD%E4%BB%A4"><span class="nav-number">12.5.</span> <span class="nav-text">聪明地学习点命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.</span> <span class="nav-text">第8章 寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%8410%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.1.</span> <span class="nav-text">寄存器的10种类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">13.2.</span> <span class="nav-text">寄存器命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.3.</span> <span class="nav-text">在输入模式中使用寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.4.</span> <span class="nav-text">匿名寄存器(&quot;&quot;)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%8F%B7%E5%AF%84%E5%AD%98%E5%99%A8-0-9"><span class="nav-number">13.5.</span> <span class="nav-text">编号寄存器(&quot;0-9)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-0"><span class="nav-number">13.5.1.</span> <span class="nav-text">复制寄存器 (&quot;0)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%8F%B7%E5%AF%84%E5%AD%98%E5%99%A8-1-9"><span class="nav-number">13.5.2.</span> <span class="nav-text">编号寄存器 (&quot;1-9)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E5%88%A0%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.6.</span> <span class="nav-text">小删除寄存器(&quot;-)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%AF%84%E5%AD%98%E5%99%A8-a-z"><span class="nav-number">13.7.</span> <span class="nav-text">命名寄存器 (&quot;a-z)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.8.</span> <span class="nav-text">只读寄存器(&quot;:, &quot;., &quot;%)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer%E4%BA%A4%E6%9B%BF%E6%96%87%E4%BB%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.9.</span> <span class="nav-text">Buffer交替文件寄存器 (&quot;#)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.10.</span> <span class="nav-text">表达式寄存器 (&quot;&#x3D;)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E5%8F%96%E5%92%8C%E6%8B%96%E6%94%BE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.11.</span> <span class="nav-text">选取和拖放寄存器 (&quot;*, &quot;+)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%91%E6%B4%9E%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.12.</span> <span class="nav-text">黑洞寄存器 (&quot;_)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%BC%8F%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.13.</span> <span class="nav-text">搜索模式寄存器 (&quot;&#x2F;)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.14.</span> <span class="nav-text">查看所有的寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.15.</span> <span class="nav-text">执行寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.16.</span> <span class="nav-text">清除寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">13.17.</span> <span class="nav-text">获取寄存器中的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">13.18.</span> <span class="nav-text">聪明地学习寄存器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">14.</span> <span class="nav-text">第9章 宏命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">14.1.</span> <span class="nav-text">基本宏命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4"><span class="nav-number">14.2.</span> <span class="nav-text">安全保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%AE%8F"><span class="nav-number">14.3.</span> <span class="nav-text">命令行执行宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">14.4.</span> <span class="nav-text">在多个文件中执行宏命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%89%A7%E8%A1%8C%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">14.5.</span> <span class="nav-text">递归执行宏命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E6%B7%BB%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E5%AE%8F"><span class="nav-number">14.6.</span> <span class="nav-text">增添一个已知宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E5%AE%8F"><span class="nav-number">14.7.</span> <span class="nav-text">修改一个已知宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%AE%8F"><span class="nav-number">14.8.</span> <span class="nav-text">拷贝宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E5%AE%8F%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%AE%8F"><span class="nav-number">14.9.</span> <span class="nav-text">串行宏和并行宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">14.10.</span> <span class="nav-text">聪明地学习宏命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0-%E6%92%A4%E9%94%80"><span class="nav-number">15.</span> <span class="nav-text">第10章 撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%A4%E9%94%80-undo-%EF%BC%8C%E9%87%8D%E5%81%9A%E5%92%8C%E8%A1%8C%E6%92%A4%E9%94%80-UNDO"><span class="nav-number">15.1.</span> <span class="nav-text">撤销(undo)，重做和行撤销(UNDO)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">15.2.</span> <span class="nav-text">断点插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E6%A0%91"><span class="nav-number">15.3.</span> <span class="nav-text">撤销树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E6%92%A4%E9%94%80%E8%AE%B0%E5%BD%95"><span class="nav-number">15.4.</span> <span class="nav-text">保存撤销记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%97%85%E8%A1%8C"><span class="nav-number">15.5.</span> <span class="nav-text">时间旅行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C"><span class="nav-number">15.6.</span> <span class="nav-text">聪明地学习撤销操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">第11章 可视模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.1.</span> <span class="nav-text">三种可视模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="nav-number">16.2.</span> <span class="nav-text">可视模式导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">16.3.</span> <span class="nav-text">可视模式语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E5%92%8CEx%E5%91%BD%E4%BB%A4"><span class="nav-number">16.4.</span> <span class="nav-text">可视模式和Ex命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%A4%9A%E8%A1%8C%E7%BC%96%E8%BE%91"><span class="nav-number">16.5.</span> <span class="nav-text">跨多行编辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E6%95%B0%E5%AD%97"><span class="nav-number">16.6.</span> <span class="nav-text">递增数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%9F%9F"><span class="nav-number">16.7.</span> <span class="nav-text">选择最后一个可视模式区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%8F%92%E5%85%A5%E6%A8%A1%E5%BC%8F%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.8.</span> <span class="nav-text">从插入模式进入可视模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.9.</span> <span class="nav-text">选择模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E8%81%AA%E6%98%8E%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.10.</span> <span class="nav-text">以聪明的方式学习可视模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">17.</span> <span class="nav-text">第12章 搜索和替换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="nav-number">17.1.</span> <span class="nav-text">智能区分大小写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">17.2.</span> <span class="nav-text">一行中的第一个和最后一个字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">17.3.</span> <span class="nav-text">重复搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%80%99%E9%80%89%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">17.4.</span> <span class="nav-text">使用候选词搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%92%8C%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE"><span class="nav-number">17.5.</span> <span class="nav-text">设置模式匹配的开始位置和结束位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E7%BB%84"><span class="nav-number">17.6.</span> <span class="nav-text">搜索字符组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="nav-number">17.7.</span> <span class="nav-text">搜索重复字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BB%84"><span class="nav-number">17.8.</span> <span class="nav-text">预定义的字符组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9C%A8%E4%B8%80%E5%AF%B9%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E6%8D%95%E8%8E%B7%E6%96%87%E6%9C%AC"><span class="nav-number">17.9.</span> <span class="nav-text">搜索示例：在一对相似字符之间捕获文本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%8D%95%E8%8E%B7%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81"><span class="nav-number">17.10.</span> <span class="nav-text">搜索示例：捕获电话号码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9B%BF%E6%8D%A2"><span class="nav-number">17.11.</span> <span class="nav-text">基本替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%9B%BF%E6%8D%A2"><span class="nav-number">17.12.</span> <span class="nav-text">重复最后一次替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E8%8C%83%E5%9B%B4"><span class="nav-number">17.13.</span> <span class="nav-text">替换范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">17.14.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E6%A0%87%E5%BF%97"><span class="nav-number">17.15.</span> <span class="nav-text">替换标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%AE%9A%E7%95%8C%E7%AC%A6"><span class="nav-number">17.16.</span> <span class="nav-text">更改定界符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%9B%BF%E6%8D%A2"><span class="nav-number">17.17.</span> <span class="nav-text">特殊替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%99%E9%80%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">17.18.</span> <span class="nav-text">候选模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%92%8C%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE"><span class="nav-number">17.19.</span> <span class="nav-text">指定替换模式的开始位置和结束位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA"><span class="nav-number">17.20.</span> <span class="nav-text">贪婪与非贪婪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2"><span class="nav-number">17.21.</span> <span class="nav-text">跨多个文件替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%AE%8F%E8%B7%A8%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2"><span class="nav-number">17.22.</span> <span class="nav-text">用宏跨多个文件替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E8%81%AA%E6%98%8E%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">17.23.</span> <span class="nav-text">以聪明的方式学习搜索和替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">17.24.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89"><span class="nav-number">17.24.1.</span> <span class="nav-text">转义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C-g"><span class="nav-number">17.24.2.</span> <span class="nav-text">% 和 g</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEtab%E4%BD%8D4%E4%B8%AA%E7%A9%BA%E6%A0%BC"><span class="nav-number">18.</span> <span class="nav-text">设置tab位4个空格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="nav-number">18.1.</span> <span class="nav-text">修改配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%B7%B2%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6"><span class="nav-number">18.2.</span> <span class="nav-text">修改已保存文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tab%E6%9B%BF%E6%8D%A2%E4%B8%BA%E7%A9%BA%E6%A0%BC"><span class="nav-number">18.2.1.</span> <span class="nav-text">Tab替换为空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2%E4%B8%BATab"><span class="nav-number">18.2.2.</span> <span class="nav-text">空格替换为Tab</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%B7%B2%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6-1"><span class="nav-number">18.3.</span> <span class="nav-text">修改已保存文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tab%E6%9B%BF%E6%8D%A2%E4%B8%BA%E7%A9%BA%E6%A0%BC-1"><span class="nav-number">18.3.1.</span> <span class="nav-text">Tab替换为空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2%E4%B8%BATab-1"><span class="nav-number">18.3.2.</span> <span class="nav-text">空格替换为Tab</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qeuroal"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qeuroal</p>
  <div class="site-description" itemprop="description">大人者，不失其赤子之心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">182</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Qeuroal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qeuroal" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/04/153/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="153. VIM 从入门到放弃 | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          153. VIM 从入门到放弃
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-04 14:00:00" itemprop="dateCreated datePublished" datetime="2023-06-04T14:00:00+08:00">2023-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-02 07:18:39" itemprop="dateModified" datetime="2025-10-02T07:18:39+08:00">2025-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul>
<li><p>本人学习的总原则: 了解功能, 现用现学</p>
<p> 以熟练实用为目标, 以查漏补缺为方法, 达到究竟涅槃不可思议的程度</p>
<p> 以下的顺序即为学习顺序, 分为看过和感觉不错的</p>
</li>
</ul>
<p><strong>学习顺序推荐</strong></p>
<ol>
<li><p>learn vim</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/wsdjeg/Learn-Vim_zh_cn">zh</a></p>
<p> 不全（第25-29章是没有的）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/iggredible/Learn-Vim">en</a></p>
</li>
</ul>
</li>
<li><p>Vim实用技巧必知必会(极客时间吴咏炜)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/">Vim参考手册</a> by Bram Molenaar, 译者: Willis</p>
<p>一句话: 布莱姆·米勒（荷兰语：Bram Moolenaar，1961年—2023年8月3日）是一名荷兰程序员，在自由软件界素有盛名。他是Vim软件的最初开发者，软件版本管理者，被推崇为终身仁慈独裁者.</p>
</li>
</ol>
<p><strong>感觉不错的</strong></p>
<ul>
<li><p>控制台运行 <code>vimtutor</code> 这是 Vim 官方实操教程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/dofy/learn-vim">vim实操教程</a></p>
<p> 只能当作入门吧!</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/5426.html">简明 Vim 练级攻略</a></p>
<p> 左耳听风值得信赖, 很不错的入门教程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mhinz/vim-galore">Vim Galore</a></p>
<p> 更新频繁，Vim 进阶必读. 确实东西很多!!!</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://liuzhijun.iteye.com/category/270228">每日一Vim</a></p>
<p> 共 30 篇，说是比较全, 但是还达不到系统的程度, 可以用来拓展知识面, 而不应该当作系统知识学习</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://openvim.com/">Open Vim</a></p>
<p> 交互式 Vim 教程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://quickref.me/vim">QuickRef.ME&#x2F;vim</a></p>
<p> Vim cheatsheet</p>
</li>
</ul>
<h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><ul>
<li>移动技术</li>
<li>d</li>
<li>p P</li>
<li>宏命令</li>
<li><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。</li>
</ul>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/junegunn/vim-peekaboo">vim-peekaboo</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/universal-ctags/ctags">universal ctags</a> </li>
<li><a target="_blank" rel="noopener" href="https://github.com/ludovicchabant/vim-gutentags">vim-gutentags</a></li>
<li>git 钩子。<a target="_blank" rel="noopener" href="https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html">可以看一看</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sheerun/vim-polyglot">vim-polyglot</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tpope/vim-fugitive">vim-fugitive</a></li>
</ul>
<h1 id="g"><a href="#g" class="headerlink" title="g"></a>g</h1><ul>
<li><a target="_blank" rel="noopener" href="https://vimdoc.sourceforge.net/htmldoc/vimindex.html#g">官方版本</a></li>
<li><a target="_blank" rel="noopener" href="https://vim.fandom.com/wiki/Power_of_g">power_of_g</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45086981/what-are-the-vim-commands-that-start-with-g">what-are-the-vim-commands-that-start-with-g</a></li>
</ul>
<h1 id="first"><a href="#first" class="headerlink" title="first"></a>first</h1><h2 id="更多帮助"><a href="#更多帮助" class="headerlink" title="更多帮助"></a>更多帮助</h2><p>关于Vim帮助手册有一个额外的小技巧：假设您想了解关于<code>Ctrl-p</code>在插入模式时的功能。如果您仅仅查找<code>:h CTRL-P</code>，您将被导航到普通模式下关于<code>Ctrl-P</code>的介绍页面，这并不是您想要的信息。在这种情况下，改为查找<code>:h i_CTRL-P</code>。添加的<code>i_</code>表示插入模式。注意它属于哪个模式。</p>
<h2 id="Vimrc"><a href="#Vimrc" class="headerlink" title="Vimrc"></a>Vimrc</h2><p>配置文件</p>
<p>激活这一配置(<code>:source %</code>)</p>
<p>您的vimrc文件中添加<code>set nocompatible</code>。如果启用<code>compatible</code>选项，许多Vim特有的功能将会被禁止</p>
<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从Vim的官方网站或官方仓库可以获得下载链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.vim.org/download.php">Vim 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/vim/vim">Vim 官方仓库</a></li>
<li><a target="_blank" rel="noopener" href="https://hub.fastgit.org/vim/vim">Vim 官方仓库镜像</a></li>
</ul>
<h2 id="退出Vim"><a href="#退出Vim" class="headerlink" title="退出Vim"></a>退出Vim</h2><ul>
<li><code>:q</code></li>
</ul>
<p>在Vim的好几种模式下都可以通过按<code>&lt;Esc&gt;</code>键切回普通模式</p>
<h2 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h2><ul>
<li><code>:w</code></li>
<li><code>:w filename</code></li>
<li><code>:wq</code></li>
<li><code>:q!</code></li>
</ul>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>如果您需要查询一些信息，只需要输入<code>:h</code>后接关键词，然后按<code>&lt;Tab&gt;</code>。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><ul>
<li><p>单个文件</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个文件</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello1.txt hello2.txt hello3.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="当前版本"><a href="#当前版本" class="headerlink" title="当前版本"></a>当前版本</h3><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure>

<ul>
<li>‘+’表示支持的特性</li>
<li>‘-‘表示不支持的特性</li>
</ul>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">version</span></span><br></pre></td></tr></table></figure>



<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>在Vim中，您可以使用<code>:s</code>命令（<code>substitue</code>的缩写）替换文本。如果您想打开<code>hello.txt</code>后立即将所有的”pancake”替换成”bagel”，在终端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +%s/pancake/bagel/g hello.txt</span><br></pre></td></tr></table></figure>



<p>该命令可以被叠加，在终端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt</span><br></pre></td></tr></table></figure>

<p>Vim会将所有”pancake” 实例替换为”bagel”，然后将所有”bagel”替换为”egg”，然后将所有”egg”替换为”donut”（在后面的章节中您将学到如何替换）。</p>
<p>您同样可以使用<code>c</code>标志来代替<code>+</code>语法，在终端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -c %s/pancake/bagel/g hello.txt</span><br><span class="line">vim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt</span><br></pre></td></tr></table></figure>



<h2 id="打开多个窗口"><a href="#打开多个窗口" class="headerlink" title="打开多个窗口"></a>打开多个窗口</h2><p>使用<code>o</code>和<code>O</code>选项使Vim打开后分别显示为水平或垂直分割的窗口</p>
<p>若想将Vim打开为2个水平分割的窗口，在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o2</span><br></pre></td></tr></table></figure>



<p>若想将Vim打开为5个水平分割的窗口，在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o5</span><br></pre></td></tr></table></figure>



<p>若想将Vim打开为5个水平分割的窗口，并使前两个窗口显示<code>hello1.txt</code>和<code>hello2.txt</code>的内容，在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o5 hello1.txt hello2.txt</span><br></pre></td></tr></table></figure>



<p>若想将Vim打开为2个垂直分割的窗口、5个垂直分割的窗口、5个垂直分割窗口并显示2个文件，在终端中分别运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim -O2</span><br><span class="line">vim -O5</span><br><span class="line">vim -O5 hello1.txt hello2.txt</span><br></pre></td></tr></table></figure>



<h2 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h2><p>如果您编辑时想将Vim挂起，您可以按下<code>Ctrl-z</code>。同样，您也可以使用<code>:stop</code>或<code>:suspend</code>命令达到相同的效果。若想从挂起状态返回，在终端中运行<code>fg</code>命令。</p>
<h2 id="聪明的启动Vim"><a href="#聪明的启动Vim" class="headerlink" title="聪明的启动Vim"></a>聪明的启动Vim</h2><p>您可以向<code>vim</code>命令传递不同的选项(option)和标志(flag)，就像其他终端命令一样。其中一个选项是命令行命令（<code>+&#123;cmd&#125;</code>或<code>-c cmd</code>）。当您读完本教程学到更多命令后，看看您是否能将相应命令应用到Vim的启动中。同样，作为一个终端命令，您可以将<code>vim</code>命令和其他终端命令联合起来。比如，您可以将<code>ls</code>命令的输出重定向到Vim中编辑，命令是<code>ls -l | vim -</code>。</p>
<h1 id="缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs"><a href="#缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs" class="headerlink" title="缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)"></a>缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)</h1><p>确保您的vimrc文件中开启了<code>set hidden</code></p>
<h2 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h2><p>buffer就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers。</p>
<p>运行<code>:buffers</code>命令可以查看所有的buffers（另外，您也可以使用<code>:ls</code>和<code>:files</code>命令）</p>
<h3 id="遍历所有buffers"><a href="#遍历所有buffers" class="headerlink" title="遍历所有buffers"></a>遍历所有buffers</h3><ul>
<li><code>:bnext</code> 切换至下一个buffer（<code>:bprevious</code>切换至前一个buffer）。</li>
<li><code>:buffer</code> + 文件名。（按下<code>&lt;Tab&gt;</code>键Vim会自动补全文件名）。</li>
<li><code>:buffer</code> + <code>n</code>, n是buffer的编号。比如，输入<code>:buffer 2</code>将使您切换到buffer #2。</li>
<li>按下<code>Ctrl-O</code>将跳转至跳转列表中旧的位置，对应的，按下<code>Ctrl-I</code>将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转。我将在第5章详细讲述关于跳转的知识。</li>
<li>按下<code>Ctrl-^</code>跳转至先前编辑过的buffer。</li>
</ul>
<h3 id="删除buffer"><a href="#删除buffer" class="headerlink" title="删除buffer"></a>删除buffer</h3><ul>
<li><code>:bdelete</code></li>
<li>接收一个buffer编号（<code>:bdelete 3</code>将删除buffer #3）一个文件名（<code>:bdelete</code>然后按<code>&lt;Tab&gt;</code>自动补全文件名）。</li>
</ul>
<h3 id="仅保留当前-buffer"><a href="#仅保留当前-buffer" class="headerlink" title="仅保留当前 buffer"></a>仅保留当前 buffer</h3><p><code>%bd | e#</code></p>
<h3 id="退出Vim-1"><a href="#退出Vim-1" class="headerlink" title="退出Vim"></a>退出Vim</h3><p>顺带说一句，如果您已经打开了多个buffers，您可以使用quit -all来关闭所有的buffers：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall</span><br></pre></td></tr></table></figure>



<p>如果您想关闭所有buffers但不保存，仅需要在后面加<code>!</code>（叹号）就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall!</span><br></pre></td></tr></table></figure>



<p>若要保存所有buffers然后退出，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wqall</span><br></pre></td></tr></table></figure>



<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>一个window就是在buffer上的一个视口</p>
<p>在Vim中，您同样可以拥有多个窗口。</p>
<p>先前我说过，您看到的是<code>file1.js</code>的buffer。但这个说法并不完整，现在这句话得更正一下，您看到的是<code>file1.js </code>的buffer通过 <strong>一个窗口</strong> 显示出来。窗口就是您查看的buffer所使用的视口。</p>
<h3 id="如果您想在窗口之间导航，使用这些快捷键："><a href="#如果您想在窗口之间导航，使用这些快捷键：" class="headerlink" title="如果您想在窗口之间导航，使用这些快捷键："></a>如果您想在窗口之间导航，使用这些快捷键：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-W H    移动光标到左边的窗口</span><br><span class="line">Ctrl-W J    移动光标到下面的窗口</span><br><span class="line">Ctrl-W K    移动光标到上面的窗口</span><br><span class="line">Ctrl-W L    移动光标到右边的窗口</span><br></pre></td></tr></table></figure>



<h3 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h3><ul>
<li><p>split: 垂直排列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:split file2.js</span><br></pre></td></tr></table></figure>


</li>
<li><p>vsplit: 水平排列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:split file2.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个窗口显示同一个buffer</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:buffer file2.js</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:vsplit filename    垂直分割当前窗口，并在新窗口中打开名为filename的文件。</span><br><span class="line">:split filename     水平分割当前窗口，并在新窗口中打开名为filename的文件。</span><br><span class="line">:new filename       创建一个新窗口并打开名为filename的文件。</span><br></pre></td></tr></table></figure>



<h4 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-W V    打开一个新的垂直分割的窗口</span><br><span class="line">Ctrl-W S    打开一个新的水平分割的窗口</span><br><span class="line">Ctrl-W C    关闭一个窗口</span><br><span class="line">Ctrl-W O    除了当前窗口，关闭所有其他的窗口</span><br></pre></td></tr></table></figure>



<h3 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h3><p>您可以按<code>Ctrl-W C</code>或输入<code>:quit</code>。当您关闭一个窗口后，buffers仍然会在列表中。</p>
<h3 id="上下窗口最大化"><a href="#上下窗口最大化" class="headerlink" title="上下窗口最大化"></a>上下窗口最大化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+_</span><br></pre></td></tr></table></figure>



<h3 id="上下窗口对等大小"><a href="#上下窗口对等大小" class="headerlink" title="上下窗口对等大小"></a>上下窗口对等大小</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+=</span><br></pre></td></tr></table></figure>



<h3 id="左右窗口最大化"><a href="#左右窗口最大化" class="headerlink" title="左右窗口最大化"></a>左右窗口最大化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+|</span><br></pre></td></tr></table></figure>



<h3 id="左右窗口对等"><a href="#左右窗口对等" class="headerlink" title="左右窗口对等"></a>左右窗口对等</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+=</span><br></pre></td></tr></table></figure>



<h3 id="上下窗口大小微调"><a href="#上下窗口大小微调" class="headerlink" title="上下窗口大小微调"></a>上下窗口大小微调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+-</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+-</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+[+]</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+shift+[+]</span><br></pre></td></tr></table></figure>



<h3 id="左右窗口大小微调"><a href="#左右窗口大小微调" class="headerlink" title="左右窗口大小微调"></a>左右窗口大小微调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+shift+&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+&lt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+shift+&lt;</span><br></pre></td></tr></table></figure>



<h3 id="窗口对调"><a href="#窗口对调" class="headerlink" title="窗口对调"></a>窗口对调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+x</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 窗口必须是对等的才行 </p>
</blockquote>
<h3 id="窗口轮转"><a href="#窗口轮转" class="headerlink" title="窗口轮转"></a>窗口轮转</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+r/R</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 窗口必须是对等的才行 </p>
</blockquote>
<h3 id="移动所在窗口位置"><a href="#移动所在窗口位置" class="headerlink" title="移动所在窗口位置"></a>移动所在窗口位置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+<span class="variable constant_">HJKL</span></span><br></pre></td></tr></table></figure>



<h3 id="不同窗口跳转"><a href="#不同窗口跳转" class="headerlink" title="不同窗口跳转"></a>不同窗口跳转</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crtl+w+hjkl</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crtl+w、ctrl+w</span><br></pre></td></tr></table></figure>



<h2 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h2><p>Tabs就是windows的集合</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>拥有多个tabs的好处是，您可以在不同的tab中使用不同的窗口布局。也许，您想让您的第1个tab包含3个垂直分割的窗口，然后让第2个tab为水平分割和垂直分割混合的窗口布局。tab是完成这件工作的完美工具!</p>
<h3 id="tab启动"><a href="#tab启动" class="headerlink" title="tab启动"></a>tab启动</h3><ul>
<li><p>导航</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:tabnew file.txt    在tab中打开一个文件</span><br><span class="line">:tabclose           关闭当前tab</span><br><span class="line">:tabnext            切换至下一个tab</span><br><span class="line">:tabprevious        切换至前一个tab</span><br><span class="line">:tablast            切换至最后一个tab</span><br><span class="line">:tabfirst           切换至第一个tab</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gt</code>切换到下一个标签页（对应的，可以用<code>gT</code>切换到前一个标签页）。您也可以传递一个数字作为参数给<code>gt</code>，这个数字是tab的编号。若想切换到第3个tab，输入<code>3gt</code></p>
</li>
<li><p>启动</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -p file1.js file2.js file3.js</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三维移动"><a href="#三维移动" class="headerlink" title="三维移动"></a>三维移动</h2><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动</p>
<p>使用<code>Ctrl-W H/J/K/L</code>移动到上面、右侧、下面、以及左侧的窗口</p>
<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>在笛卡尔坐标系的Z轴上穿梭，想象您的buffer文件在Z轴上呈线性排列</p>
<p>使用<code>:bnext</code>和<code>bprevious</code>在Z轴上一次一个buffer地遍历。您也可以使用<code>:buffer 文件名/buffer编号</code>在Z轴上跳转到任意坐标</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合window和buffer的移动，您可以在 <em>三维空间</em> 中移动</p>
<p>可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）</p>
<p>因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>首先，对于&#x3D;&#x3D;某个特定任务&#x3D;&#x3D;，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。</li>
<li>当&#x3D;&#x3D;比对文件、读文档、或追踪代码流&#x3D;&#x3D;时，我使用&#x3D;&#x3D;多窗口来一次查看多个buffers&#x3D;&#x3D;。我尽量保持屏幕上的&#x3D;&#x3D;窗口数不超过3个&#x3D;&#x3D;，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。</li>
<li>我使用<a target="_blank" rel="noopener" href="https://github.com/tmux/tmux/wiki">tmux</a>windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。</li>
</ul>
<h1 id="打开和搜索文件"><a href="#打开和搜索文件" class="headerlink" title="打开和搜索文件"></a>打开和搜索文件</h1><h2 id="打开和编辑文件"><a href="#打开和编辑文件" class="headerlink" title="打开和编辑文件"></a>打开和编辑文件</h2><p>Vim中打开一个文件使用<code>:edit</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit file.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>file.txt</code>已经存在，就会打开<code>file.txt</code>buffer。</li>
<li>如果<code>file.txt</code>不存在，会创建一个新buffer名为<code>file.txt</code>、</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p><code>:edit</code>命令支持使用<code>&lt;Tab&gt;</code>进行自动补全</p>
</li>
<li><p><code>:edit</code>可以接收通配符参数。<code>*</code>匹配当前目录下的任意文件</p>
<ul>
<li><p><code>:edit *.yml&lt;Tab&gt;</code>: Vim将列出当前目录下所有<code>.yml</code>文件供您选择。</p>
</li>
<li><p>可以使用<code>**</code>进行递归的搜索</p>
<ul>
<li><p>查找当前项目文件夹下所有<code>*.md</code>文件，但您不知道在哪个目录，您可以这样做</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit **/*.md&lt;Tab&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><code>:edit</code>可以用于运行<code>netrw</code>（Vim的内置文件浏览器）</p>
<ul>
<li><p>使用：给<code>:edit</code>一个目录参数而不是文件名就行了</p>
</li>
<li><p>示例</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:edit .</span><br><span class="line">:edit test/unit/</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="使用find命令搜索文件"><a href="#使用find命令搜索文件" class="headerlink" title="使用find命令搜索文件"></a>使用find命令搜索文件</h2><h3 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h3><p>使用<code>:find</code>命令搜索文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:find package.json</span><br><span class="line">:find app/controllers/users_controller.rb</span><br></pre></td></tr></table></figure>

<p><code>:find</code>命令同样支持自动补全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:find p&lt;Tab&gt;                &quot; to find package.json</span><br><span class="line">:find a&lt;Tab&gt;c&lt;Tab&gt;u&lt;Tab&gt;    &quot; to find app/controllers/users_controller.rb</span><br></pre></td></tr></table></figure>



<h2 id="Find-和-Path"><a href="#Find-和-Path" class="headerlink" title="Find 和 Path"></a>Find 和 Path</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>:find</code>命令根据<code>path</code>选项配置的路径查找文件</li>
<li><code>:edit</code>不会</li>
</ul>
<p>查看一下您的<code>path</code>是什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path?</span><br></pre></td></tr></table></figure>

<p>默认情况下，您的<code>path</code>内容很可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path=.,/usr/include,,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code> 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 <strong>当前所打开的文件</strong> 所在的目录)</li>
<li><code>,</code> means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号<code>,</code>应该是表示路径之间的分割符。连续的两个<code>,,</code>（两个逗号之间为空）才表示当前目录)</li>
<li><code>/usr/include</code> 表示在C编译器头文件目录下搜索。</li>
</ul>
<p>将<code>app/controllers/</code>添加到当前<code>path</code>选项。以下是操作步骤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path+=app/controllers/</span><br></pre></td></tr></table></figure>

<p>现在您的路径已经更新，当您输入<code>:find u&lt;Tab&gt;</code>时，Vim将会在<code>app/controllers/</code>目录内搜索所有以”u”开头的文件。</p>
<p>如果您有一个嵌套的目录<code>controllers/</code>，比如<code>app/controllers/account/users_controller.rb</code>，Vim就找不到<code>users_controllers</code>了。您必须改为添加<code>:set path+=app/controllers/**</code></p>
<p>将整个项目文件夹添加到<code>path</code>中，这样当您按<code>&lt;Tab&gt;</code>，Vim将在所有文件夹内搜索您要找的文件，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path+=$PWD/**</span><br></pre></td></tr></table></figure>

<ul>
<li>建议仅仅将您最常访问的文件&#x2F;目录添加到<code>path</code></li>
<li>您可以将<code>set path+=&#123;您需要添加的目录&#125;</code>添加到您的vimrc文件中。更新<code>path</code>仅花费几秒钟，但可以为您的工作节省很多时间。</li>
</ul>
<h2 id="使用Grep命令在文件中搜索"><a href="#使用Grep命令在文件中搜索" class="headerlink" title="使用Grep命令在文件中搜索"></a>使用Grep命令在文件中搜索</h2><p>如果您想在文件内部查找（搜索文件中的词句），您可以使用grep。Vim有两个方法可以完成这个工作：</p>
<ul>
<li>内置grep （<code>:vim</code>。没错，就是<code>:vim</code>，它是<code>:vimgrep</code>的简写）。</li>
<li>外部grep (<code>:grep</code>)。</li>
</ul>
<h3 id="内置grep"><a href="#内置grep" class="headerlink" title="内置grep"></a>内置grep</h3><p><code>:vim</code>有以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vim /pattern/ file</span><br></pre></td></tr></table></figure>

<ul>
<li><code>/pattern/</code> 是您要搜索的内容的正则表达式。</li>
<li><code>file</code> 是文件参数。您可以传入多个参数。Vim将在文件中搜索所有匹配正则表达式的内容。类似于<code>:find</code>，您可以传入*和**通配符。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>比如，要在<code>app/controllers/</code>目录下所有ruby文件(<code>.rb</code>)中，查找所有的”breakfast”字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vim /breakfast/ app/controllers/**/*.rb</span><br></pre></td></tr></table></figure>

<p>输入上面的命令后，您将会被导航到第一个结果。Vim的<code>vim</code>搜索命令使用<code>quickfix</code>进行处理。要查看所有搜索结果，运行<code>:copen</code>会打开一个<code>quickfix</code>窗口。下面有一些有用的quickfix命令，可以让您提高效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:copen        打开quickfix窗口</span><br><span class="line">:cclose       关闭quickfix窗口</span><br><span class="line">:cnext        跳到下一个错误</span><br><span class="line">:cprevious    跳到前一个错误</span><br><span class="line">:colder       跳到旧的错误列表</span><br><span class="line">:cnewer       跳到新的错误列表</span><br></pre></td></tr></table></figure>

<p>缺点：慢，如果匹配结果数量较多时系统速度会变慢。这是因为Vim将每一个搜索结果读入内存。Vim加载每一个匹配的文件就像它们被编辑一样。如果Vim查到大量文件，它将消耗很多内存</p>
<h3 id="外置grep"><a href="#外置grep" class="headerlink" title="外置grep"></a>外置grep</h3><p>默认情况下，它使用终端命令<code>grep</code>。要想在<code>app/controllers/</code>目录中搜索字符串”lunch”，您可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:grep -R &quot;lunch&quot; app/controllers/</span><br></pre></td></tr></table></figure>

<p>注意这里不是使用<code>/pattern/</code>，它遵循的是终端grep的语法<code>&quot;pattern&quot;</code>，它同样使用’quickfix’来显示所有的匹配结果。</p>
<p>Vim使用<code>grepprg</code>变量来决定运行<code>:grep</code>时，应该使用哪个外部程序。所以您并不是非得使用终端的<code>grep</code>命令。稍后我将为您演示如何改变外部grep程序的默认值。</p>
<h2 id="用Netrw浏览文件"><a href="#用Netrw浏览文件" class="headerlink" title="用Netrw浏览文件"></a>用Netrw浏览文件</h2><p><a target="_blank" rel="noopener" href="https://github.com/preservim/nerdtree">NERDTree</a> 是一个很好的选择</p>
<h2 id="Fzf插件"><a href="#Fzf插件" class="headerlink" title="Fzf插件"></a>Fzf插件</h2><p>略</p>
<h1 id="第4章-Vim-语法"><a href="#第4章-Vim-语法" class="headerlink" title="第4章 Vim 语法"></a>第4章 Vim 语法</h1><p>刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用<code>gUfV</code>或<code>1GdG</code>，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。</p>
<p>这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vim语言时，我讨论并不是<br>Vimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。</p>
<h2 id="如何学习一门语言"><a href="#如何学习一门语言" class="headerlink" title="如何学习一门语言"></a>如何学习一门语言</h2><p>我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：</p>
<ol>
<li>学习语法规则</li>
<li>扩展我的词汇量</li>
<li>练习，练习，练习</li>
</ol>
<p>同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。</p>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun # 动词 + 名词</span><br></pre></td></tr></table></figure>

<p>这就类似与在英语中的祈使句：</p>
<ul>
<li>“Eat(verb) a donut(noun)”</li>
<li>“Kick(verb) a ball(noun)”</li>
<li>“Learn(verb) the Vim Editor(noun)”</li>
</ul>
<p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p>
<h2 id="名词-动作-Motion"><a href="#名词-动作-Motion" class="headerlink" title="名词(动作 Motion)"></a>名词(动作 Motion)</h2><p>我们这里将 <strong>动作 Motion</strong> 作为名词， <strong>动作Motion</strong>用来在Vim中到处移动。下面列出了一些常见的<strong>动作</strong>的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h	左</span><br><span class="line">j	下</span><br><span class="line">k	上</span><br><span class="line">l	右</span><br><span class="line">w	向前移动到下一个单词的开头</span><br><span class="line">&#125;	跳转到下一个段落</span><br><span class="line">$	跳转到当前行的末尾</span><br></pre></td></tr></table></figure>

<p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些<strong>动作</strong>也不必担心。</p>
<h2 id="动词-操作符-Operator"><a href="#动词-操作符-Operator" class="headerlink" title="动词(操作符 Operator)"></a>动词(操作符 Operator)</h2><p>根据<code>:h operator</code>，Vim共有16个<strong>操作符</strong>，然而根据我的经验，学习这3个<strong>操作符</strong>在80%的情况下就已经够用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y	yank(复制)</span><br><span class="line">d	delete(删除)</span><br><span class="line">c	change 删除文本，将删除的文本存到寄存器中，进入插入模式</span><br></pre></td></tr></table></figure>

<p>顺带说一句，当你yank一段文本后，您可以使用<code>p</code>将它粘贴到光标后，或使用<code>P</code>粘贴到光标前。</p>
<h2 id="动词（操作符-Operator）和名词（动作-motions）的结合"><a href="#动词（操作符-Operator）和名词（动作-motions）的结合" class="headerlink" title="动词（操作符 Operator）和名词（动作 motions）的结合"></a>动词（操作符 Operator）和名词（动作 motions）的结合</h2><p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则，动词和名词的结合！假设你有下面这段文本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> learn = <span class="string">&quot;Vim&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>复制当前位置到行尾的所有内容：<code>y$</code></li>
<li>删除当前位置到下一个单词的开头：<code>dw</code></li>
<li>修改当前位置到这个段落的结尾：<code>c&#125;</code></li>
</ul>
<p><strong>动作 motions</strong>也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用<code>3k</code>代替按3次<code>k</code>，数字可应用在Vim语法中。</p>
<ul>
<li>向左拷贝2个字符：<code>y2h</code></li>
<li>删除后两个单词：<code>d2w</code></li>
<li>修改后面两行：<code>c2j</code></li>
</ul>
<p>目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。唯一途径就是重复、重复再重复。</p>
<p>作为补充，行级的 <strong>操作符 operations</strong> (作用在整行中的操作符)在文本编辑中和其他的 <strong>操作符</strong> 一样，Vim允许你通过按两次 <strong>操作符</strong>使它执行行级的操作，例如<code>dd</code>，<code>yy</code>，<code>cc</code>来执行删除，复制或修改整个行。您可以使用其他operations试一下（比如<code>gUgU</code>）。</p>
<p>666!从这可以看出Vim命令的一种执行模式。但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)</p>
<h2 id="更多名词-文本对象-Text-Objects"><a href="#更多名词-文本对象-Text-Objects" class="headerlink" title="更多名词(文本对象 Text Objects)"></a>更多名词(文本对象 Text Objects)</h2><p>想象一下你现在正在某个被括号包围的文本中例如<code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？</p>
<p>答案是有的。文本通常是结构化的，特别是代码中，文本经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。</p>
<p>文本对象可以被 <strong>操作符 operations</strong> 使用，这里有两类文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i + object  内部文本对象</span><br><span class="line">a + object  外部文本对象</span><br></pre></td></tr></table></figure>

<p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多。如果你的光标位于一对括号内部，例如<code>(hello Vim)</code>中：</p>
<ul>
<li>删除括号内部的内容但保留括号：<code>di(</code></li>
<li>删除括号以及内部的内容：<code>da(</code></li>
</ul>
<p>让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在”Hello”中的”H”上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello Vim&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除整个”Hello Vim”：<code>di(</code></li>
<li>删除整个函数(被{}包含)：<code>di&#123;</code></li>
<li>删除”Hello”这个词：<code>diw</code></li>
</ul>
<p>文本对象很强大因为你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到<code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词。</p>
<p>让我们来看最后一个例子。假设你有这样一些html的标签的文本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你的光标位于”Header1”文本上：</p>
<ul>
<li>删除”Header1”：<code>dit</code></li>
<li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：<code>dat</code></li>
</ul>
<p>如果你的光标在”div”文本上：</p>
<ul>
<li>删除<code>h1</code>和所有<code>p</code>标签的行：<code>dit</code></li>
<li>删除所有文本：<code>dat</code></li>
<li>删除”div”：<code>di&lt;</code></li>
</ul>
<p>下面列举的一些通常见到的文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w     一个单词</span><br><span class="line">p     一个段落</span><br><span class="line">s     一个句子</span><br><span class="line">(或)  一对()</span><br><span class="line">&#123;或&#125;  一对&#123;&#125;</span><br><span class="line">[或]  一对[]</span><br><span class="line">&lt;或&gt;  一对&lt;&gt;</span><br><span class="line">t     XML标签</span><br><span class="line">&quot;     一对&quot;&quot;</span><br><span class="line">&#x27;     一对&#x27;&#x27;</span><br><span class="line">`     一对``</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>:h text-objects</code>了解更多</p>
<h2 id="结合性和语法"><a href="#结合性和语法" class="headerlink" title="结合性和语法"></a>结合性和语法</h2><p>在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。</p>
<p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。</p>
<p>Vim的结合性最强大之处体现在它和外部程序结合时，Vim有一个 <strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id|Name|Cuteness</span><br><span class="line">01|Puppy|Very</span><br><span class="line">02|Kitten|Ok</span><br><span class="line">03|Bunny|Ok</span><br></pre></td></tr></table></figure>

<p>这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令<code>column</code>很快的完成它，当你的光标位于”Id”上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id  Name    Cuteness</span><br><span class="line">01  Puppy   Very</span><br><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>

<p>让我们分解一下上面那条命令，动词是<code>!</code>(<strong>过滤操作符</strong>)，名词是<code>&#125;</code>(到下一个段落)。<strong>过滤操作符</strong><code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本。</p>
<p>假设你不止想格式化你的文本，还想只展示<code>Ok</code>结尾的行，你知道<code>awk</code>命令可以做这件事情，那么你可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&#125;column -t -s &quot;|&quot; | awk &#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>
<p>666！管道竟然在Vim中也能起作用。</p>
<p>这就是Vim的结合性的强大之处。你知道的动词 <strong>操作符</strong>，名词 <strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长。</p>
<p>换句话说，假设你只知道四个<strong>动作</strong>：<code>w, $, &#125;, G</code>和删除操作符(<code>d</code>)，你可以做8件事：按四种方式移动(<code>w, $, &#125;, G</code>)和删除4种文本对象(<code>dw, d$, d&#125;, dG</code>)。如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的Vim工具箱中多的不是1种工具，而是4种：<code>gUw, gU$, gU&#125;, gUG</code>。现在你的Vim工具箱中就有12种工具了。如果你知道10个<strong>动作</strong>和5个<strong>操作符</strong>，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(<code>nG</code>)给你了<code>n</code>种<strong>动作</strong>，其中<code>n</code>是你文件中的行数(例如前往第5行，<code>5G</code>)。搜索动作(<code>/</code>)实际上给你带来无限数量的<strong>动作</strong>因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(<code>!</code>)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。</p>
<p>这种具有结合性的行为也正符合Unix的哲学：<em>一个命令做好一件事</em>。<strong>动作</strong>只需要做一件事：前往X。<strong>操作符</strong>只需要做一件事：完成Y。通过结合一个<strong>操作符</strong>和一个<strong>动作</strong>，你就获得了YX：在X上完成Y。</p>
<p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造<strong>动作</strong>和<strong>操作符</strong>去丰富你的Vim工具箱，<a target="_blank" rel="noopener" href="https://github.com/kana/vim-textobj-user"><code>Vim-textobj-user</code></a>插件允许你创建自己的文本对象，同时包含有<a target="_blank" rel="noopener" href="https://github.com/kana/vim-textobj-user/wiki">一系列定义好的文本对象</a>。</p>
<p>另外，如果你不知道我刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。</p>
<h2 id="聪明地学习语法"><a href="#聪明地学习语法" class="headerlink" title="聪明地学习语法"></a>聪明地学习语法</h2><p>你刚刚学完Vim唯一的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun</span><br></pre></td></tr></table></figure>
<p>我学Vim中最大的”AHA moment”之一是当我刚学完大写命令(<code>gU</code>)时，想要把一个单词变成大写，我本能的运行了<code>gUiW</code>，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的”AHA moment”，如果之前没有的话。</p>
<p>这一章的目标是向你展现Vim中的<code>verb+noun</code>模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。</p>
<p>学习这种模式并且理解其中的含义，这是聪明的学习方式。</p>
<h1 id="第5章-在文件中移动"><a href="#第5章-在文件中移动" class="headerlink" title="第5章 在文件中移动"></a>第5章 在文件中移动</h1><p>一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。</p>
<p>这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令(motions)，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>。</p>
<h2 id="字符导航"><a href="#字符导航" class="headerlink" title="字符导航"></a>字符导航</h2><p>最基本的移动单元是上下左右移动一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h   左</span><br><span class="line">j   下</span><br><span class="line">k   上</span><br><span class="line">l   右</span><br></pre></td></tr></table></figure>

<p>你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。</p>
<p>我更喜欢<code>hjkl</code>因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过<code>~/.vimrc</code>关闭了方向键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;Up&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Down&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Left&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Right&gt; &lt;NOP&gt;</span><br></pre></td></tr></table></figure>

<p>也有一些插件可以帮助改掉这个坏习惯，其中有一个叫<a target="_blank" rel="noopener" href="https://github.com/takac/vim-hardtime">vim-hardtime</a>。 让我感到惊讶的是，我只用了几天就习惯了使用<code>hjkl</code>。</p>
<p>另外，如果你想知道为什么Vim使用<code>hjkl</code>进行移动，<em>这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把<code>hjkl</code>当做方向键</em>。</p>
<p>如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用<code>h</code>和<code>l</code>。 如果我需要在可见的范围内上下移动几行，我会使用<code>j</code>和<code>k</code>。 如果我想去更远的地方，我倾向于使用其他移动命令。</p>
<h2 id="相对行号"><a href="#相对行号" class="headerlink" title="相对行号"></a>相对行号</h2><p>我觉得设置<code>number</code>和<code>relativenumber</code>非常有用，你可以在<code>~/.vimrc</code>中设置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set relativenumber number</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这将会展示当前行号和其他行相对当前行的行号&#x3D;&#x3D;。</p>
<p>为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用<code>12j</code>去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69&#x3D;12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。</p>
<p>这是一个100%的个人偏好，你可以尝试<code>relativenumber</code>&#x2F;<code>norelativenumber</code>，<code>number</code>&#x2F;<code>nonumber</code> 然后选择自己觉得最有用的。</p>
<h2 id="对移动计数"><a href="#对移动计数" class="headerlink" title="对移动计数"></a>对移动计数</h2><p>在继续之前，让我们讨论一下”计数”参数。 一个移动(motion)可以接受一个数字前缀作为参数，上面我提到的你可以通过<code>12j</code>向下移动12行，其中<code>12j</code>中的<code>12</code>就是计数数字。</p>
<p>你使用带计数的移动的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[计数] + 移动</span><br></pre></td></tr></table></figure>

<p>你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用<code>9l</code>来代替按9次<code>l</code>。 当你学到了更多的动作时，你都可以试试给定计数参数。</p>
<h2 id="单词导航"><a href="#单词导航" class="headerlink" title="单词导航"></a>单词导航</h2><p>我们现在移动一个更长的单元：单词(word)。 你可以通过<code>w</code>移动到下一个单词的开始，通过<code>e</code>移动到下一个单词的结尾，通过<code>b</code>移动到上一个单词的开始，通过<code>ge</code>移动到前一个单词的结尾。</p>
<p>另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过<code>W</code>移动到下一个词组的开始，通过<code>E</code>移动到下一个词组的结尾，通过<code>B</code>移动到前一个词组的开头，通过<code>gE</code>移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w		移动到下一个单词的开头</span><br><span class="line">W		移动到下一个词组的开头</span><br><span class="line">e		移动到下一个单词的结尾</span><br><span class="line">E		移动到下一个词组的结尾</span><br><span class="line">b		移动到前一个单词的开头</span><br><span class="line">B		移动到前一个词组的开头</span><br><span class="line">ge	移动到前一个单词的结尾</span><br><span class="line">gE	移动到前一个词组的结尾</span><br></pre></td></tr></table></figure>

<p>词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-zA-Z0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过<code>:h word</code>和<code>:h WORD</code>了解更多。</p>
<p>例如，假如你有下面这段内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>

<p>当你光标位于这行的开头时，你可以通过<code>l</code>走到行尾，但是你需要按21下，使用<code>w</code>，你需要6下，使用<code>W</code>只需要4下。 单词和词组都是短距离移动的很好的选择。</p>
<p>然而，之后你可以通过当前行导航只按一次从<code>c</code>移动到<code>;</code>。</p>
<h2 id="当前行导航"><a href="#当前行导航" class="headerlink" title="当前行导航"></a>当前行导航</h2><p>当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过<code>0</code>跳到本行第一个字符，通过<code>$</code>跳到本行最后一个字符。 另外，你可以使用<code>^</code>跳到本行第一个非空字符，通过<code>g_</code>跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用<code>n|</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0		跳到本行第一个字符</span><br><span class="line">^		跳到本行第一个非空字符</span><br><span class="line">g_      跳到本行最后一个非空字符</span><br><span class="line">$		跳到本行最后一个字符</span><br><span class="line">n|      跳到本行第n列</span><br></pre></td></tr></table></figure>

<p>你也可以在本行通过<code>f</code>和<code>t</code>进行行内搜索，<code>f</code>和<code>t</code>的区别在于<code>f</code>会停在第一个匹配的字母上，<code>t</code>会停在第一个匹配的字母前。 因此如果你想要搜索并停留在”h”上，使用<code>fh</code>。 如果你想搜索第一个”h”并停留在它的前一个字母上，可以使用<code>th</code>。 如果你想去下一个行内匹配的位置，使用<code>;</code>，如果你想去前一个行内匹配的位置，使用<code>,</code>。</p>
<p><code>F</code>和<code>T</code>是<code>f</code>和<code>t</code>对应的向后搜索版本。如果想向前搜索”h”，可以使用<code>Fh</code>，使用<code>;</code>，保持相同的搜索方向搜索下一个匹配的字母。 注意，<code>;</code>不是总是向后搜索，<code>;</code>表示的是上一次搜索的方向，因此如果你使用的<code>F</code>，那么使用<code>;</code>时将会向前搜索使用<code>,</code>时向后搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f   在同一行向后搜索第一个匹配</span><br><span class="line">F   在同一行向前搜索第一个匹配</span><br><span class="line">t   在同一行向后搜索第一个匹配，并停在匹配前</span><br><span class="line">T   在同一行向前搜索第一个匹配，并停在匹配前</span><br><span class="line">;   在同一行重复最近一次搜索</span><br><span class="line">,   在同一行向相反方向重复最近一次搜索</span><br></pre></td></tr></table></figure>

<p>回到上一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>

<p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符”;”。 如果想去往”world”中的”w”，你可以使用<code>fw</code>。 一个建议是，&#x3D;&#x3D;在行内目标附近通过寻找重复出现最少的字母例如”j”，”x”，”z”来前往行中的该位置更快&#x3D;&#x3D;。</p>
<h2 id="句子和段落导航"><a href="#句子和段落导航" class="headerlink" title="句子和段落导航"></a>句子和段落导航</h2><p>接下来两个移动的单元是句子和段落。</p>
<p>首先我们来聊聊句子。 一个句子的定义是以<code>.!?</code>和跟着的一个换行符或空格，tab结尾的。 你可以通过<code>)</code>和<code>(</code>跳到下一个和上一个句子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(   跳到前一个句子</span><br><span class="line">)   跳到下一个句子</span><br></pre></td></tr></table></figure>

<p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用<code>(</code>和<code>)</code>感受一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :</span><br><span class="line"></span><br><span class="line">There is an empty line above me.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，如果你的Vim中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于<code>compatible</code>的模式。 运行<code>:set nocompatible</code>可以修复。 在Vi中，一个句子是以<strong>两个</strong>空格结尾的，你应该总是保持的<code>nocompatible</code>的设置。</p>
<p>接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项(<code>paragraphs</code>)中”字符对”所指定的段落宏的每个集合开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;   跳转到上一个段落</span><br><span class="line">&#125;   跳转到下一个段落</span><br></pre></td></tr></table></figure>

<p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。</p>
<p>我们来看这个例子。 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>()</code>这样的句子导航。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello. How are you? I am great, thanks!</span><br><span class="line">Vim is awesome.</span><br><span class="line">It may not easy to learn it at first...- but we are in this together. Good luck!</span><br><span class="line"></span><br><span class="line">Hello again.</span><br><span class="line"></span><br><span class="line">Try to move around with ), (, &#125;, and &#123;. Feel how they work.</span><br><span class="line">You got this.</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多。</p>
<h2 id="匹配导航"><a href="#匹配导航" class="headerlink" title="匹配导航"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过<code>%</code>跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%    Navigate to another match, usually works for (), [], &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用<code>%</code>移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define (fib n)</span><br><span class="line">  (cond ((= n 0) 0)</span><br><span class="line">        ((= n 1) 1)</span><br><span class="line">        (else</span><br><span class="line">          (+ (fib (- n 1)) (fib (- n 2)))</span><br><span class="line">        )))</span><br></pre></td></tr></table></figure>

<p>我个人喜欢使用类似<a target="_blank" rel="noopener" href="https://github.com/frazrepo/vim-rainbow">vim-rainbow</a>这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多。</p>
<h2 id="行号导航"><a href="#行号导航" class="headerlink" title="行号导航"></a>行号导航</h2><p>你可以通过<code>nG</code>调到行号为<code>n</code>的行，例如如果你想跳到第7行，你可以使用<code>7G</code>，跳到第一行使用<code>gg</code>或<code>1G</code>，跳到最后一行使用<code>G</code>。</p>
<p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用<code>70%</code>跳过去，可以使用<code>50%</code>跳到文件的中间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gg      跳转到第一行</span><br><span class="line">G       跳转到最后一行</span><br><span class="line">nG      跳转到第n行</span><br><span class="line">n%      跳到文件的n%</span><br></pre></td></tr></table></figure>

<p>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看。</p>
<h2 id="窗格导航"><a href="#窗格导航" class="headerlink" title="窗格导航"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>。</p>
<p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀。 如果你输入<code>10H</code>你会跳转到窗格顶部往下数10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H   跳转到屏幕的顶部</span><br><span class="line">M   跳转到屏幕的中间</span><br><span class="line">L   跳转到屏幕的底部</span><br><span class="line">nH  跳转到距离顶部n行的位置</span><br><span class="line">nL  跳转到距离底部n行的位置</span><br></pre></td></tr></table></figure>

<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><p>在文件中滚动，你有三种速度可以选择： 滚动一整页(<code>CTRL-F</code>&#x2F;<code>CTRL-B</code>)，滚动半页(<code>CTRL-D</code>&#x2F;<code>CTRL-U</code>)，滚动一行<code>CTRL-E</code>&#x2F;<code>CTRL-Y</code>)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-e    向下滚动一行</span><br><span class="line">Ctrl-d    向下滚动半屏</span><br><span class="line">Ctrl-f    向下滚动一屏</span><br><span class="line">Ctrl-y    向上滚动一行</span><br><span class="line">Ctrl-u    向上滚动半屏</span><br><span class="line">Ctrl-b    向上滚动一屏</span><br></pre></td></tr></table></figure>

<p>你也可以相对当前行进行滚动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zt    将当前行置于屏幕顶部附近</span><br><span class="line">zz    将当前行置于屏幕中央</span><br><span class="line">zb    将当前行置于屏幕底部</span><br></pre></td></tr></table></figure>

<h2 id="搜索导航"><a href="#搜索导航" class="headerlink" title="搜索导航"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过<code>/</code>向下搜索，也可以通过<code>?</code>向上搜索一个字段。 你可以通过<code>n</code>重复最近一次搜索，<code>N</code>向反方向重复最近一次搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/   向后搜索一个匹配</span><br><span class="line">?   向前搜素一个匹配</span><br><span class="line">n   重复上一次搜索(和上一次方向相同)</span><br><span class="line">N   重复上一次搜索(和上一次方向相反)</span><br></pre></td></tr></table></figure>

<p>假设你有一下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">one = &quot;01&quot;;</span><br><span class="line">one = &quot;one&quot;;</span><br><span class="line">let onetwo = 12;</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>/let</code>搜索”let”，然后通过<code>n</code>快速的重复搜索下一个”let”，如果需要向相反方向搜索，可以使用<code>N</code>。 如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索”let”)。</p>
<p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段。 另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>。 因为我经常使用这个功能，所以我会设置一个映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;esc&gt;&lt;esc&gt; :noh&lt;return&gt;&lt;esc&gt;</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>*</code>快速的向前搜索光标下的文本，通过<code>#</code>快速向后搜索光标下的文本。 如果你的光标位于一个字符串”one”上，按下<code>*</code>相当于<code>/\&lt;one\&gt;</code>。<br><code>/\&lt;one\&gt;</code>中的<code>\&lt;</code>和<code>\&gt;</code>表示整词匹配，使得一个更长的包含”one”的单词不会被匹配上，也就是说它会匹配”one”，但不会匹配”onetwo”。 如果你的光标在”one”上并且你想向后搜索完全或部分匹配的单词，例如”one”和”onetwo”，你可以用<code>g*</code>替代<code>*</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   向后查找光标所在的完整单词</span><br><span class="line">#   向前查找光标所在的完整单词</span><br><span class="line">g*  向后搜索光标所在的单词</span><br><span class="line">g#  向前搜索光标所在的单词</span><br></pre></td></tr></table></figure>

<h2 id="位置标记"><a href="#位置标记" class="headerlink" title="位置标记"></a>位置标记</h2><p>你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过<code>mx</code>设置一个标记，其中<code>x</code>可以是<code>a-zA-Z</code>。 有两种办法能回到标记的位置： 用<code> `x</code>精确回到(行和列)，或者用<code>&#39;x</code>回到行级位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ma    用a标签标记一个位置</span><br><span class="line">`a    精确回到a标签的位置(行和列)</span><br><span class="line">&#x27;a    跳转到a标签的行</span><br></pre></td></tr></table></figure>

<p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。</p>
<p>我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记”a”(<code>ma</code>)，然后在另一个文件中设置另一个标记”a”(<code>ma</code>)。</p>
<p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在<code>myFile.txt</code>中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目中，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。</p>
<p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-zA-Z</code>以外还有别的标签，其中有一些例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;   在当前buffer中跳转回到上一次跳转前的最后一行</span><br><span class="line">``  在当前buffer中跳转回到上一次跳转前的最后一个位置</span><br><span class="line">`[  跳转到上一次修改或拷贝的文本的开头</span><br><span class="line">`]  跳转到上一次修改或拷贝的文本的结尾</span><br><span class="line">`&lt;  跳转到最近一次可视模式下选择的部分的开头</span><br><span class="line">`&gt;  跳转到最近一次可视模式下选择的部分的结尾</span><br><span class="line">`0  跳转到退出Vim前编辑的最后一个文件</span><br></pre></td></tr></table></figure>

<p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看。</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用<code>j</code>向下移动一行就不被看做一个跳转，即使你使用<code>10j</code>向下移动10行，也不是一个跳转。 但是你通过<code>10G</code>去往第10行被算作一个跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x27;   跳转到标记的行</span><br><span class="line">`   跳转到标记的位置(行和列)</span><br><span class="line">G   跳转到行</span><br><span class="line">/   向后搜索</span><br><span class="line">?   向前搜索</span><br><span class="line">n   重复上一次搜索，相同方向</span><br><span class="line">N   重复上一次搜索，相反方向</span><br><span class="line">%   查找匹配</span><br><span class="line">(   跳转上一个句子</span><br><span class="line">)   跳转下一个句子</span><br><span class="line">&#123;   跳转上一个段落</span><br><span class="line">&#125;   跳转下一个段落</span><br><span class="line">L   跳转到当前屏幕的最后一行</span><br><span class="line">M   跳转到当前屏幕的中间</span><br><span class="line">H   跳转到当前屏幕的第一行</span><br><span class="line">[[  跳转到上一个小节</span><br><span class="line">]]  跳转到下一个小节</span><br><span class="line">:s  替换</span><br><span class="line">:tag  跳转到tag定义</span><br></pre></td></tr></table></figure>
<p>我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>。</p>
<p>为什么跳转有用呢? 因为你可以在跳转列表中通过<code>Ctrl-o</code>和<code>Ctrl-i</code>在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。</p>
<h2 id="聪明地学习导航"><a href="#聪明地学习导航" class="headerlink" title="聪明地学习导航"></a>聪明地学习导航</h2><p>如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。</p>
<p>我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从<code>h,j,k,l,w,b,G,/,?,n</code>开始，不断地重复这10个移动知道形成肌肉记忆，这花不了多少时间。</p>
<p>为了让你更擅长导航，我有两个建议：</p>
<ol>
<li>注意重复的动作。 如果你发现你自己在重复的使用<code>l</code>，你可以去找一个方法让你前进的更快，然后你会发现你可以用<code>w</code>在单词间移动。 如果你发现你自己的重复的使用<code>w</code>，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用<code>$</code>。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。</li>
<li>当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。</li>
</ol>
<p>最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。</p>
<p>慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。</p>
<h1 id="第6章-输入模式"><a href="#第6章-输入模式" class="headerlink" title="第6章 输入模式"></a>第6章 输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。</p>
<p>尽管如此，这并不代表输入模式没什么好学的。Vim的输入模式包含许多有用功能。在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。</p>
<h2 id="进入输入模式的方法"><a href="#进入输入模式的方法" class="headerlink" title="进入输入模式的方法"></a>进入输入模式的方法</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i    从光标之前的位置开始输入文本</span><br><span class="line">I    从当前行第一个非空字符之前的位置之前开始输入文本</span><br><span class="line">a    在光标之后的位置追加文本</span><br><span class="line">A    在当前行的末尾追加文本</span><br><span class="line">o    在光标位置下方新起一行并开始输入文本</span><br><span class="line">O    在光标位置的上方新起一行并开始输入文本</span><br><span class="line">s    删除当前光标位置的字符并开始输入文本</span><br><span class="line">S    删除当前行并开始输入文本</span><br><span class="line">gi   从当前缓冲区上次结束输入模式的地方开始输入文本</span><br><span class="line">gI   在当前行的第一列的位置开始输入文本</span><br></pre></td></tr></table></figure>

<p>值得注意的是这些命令的小写&#x2F;大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。</p>
<h2 id="退出输入模式的方法"><a href="#退出输入模式的方法" class="headerlink" title="退出输入模式的方法"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;esc&gt;     退出输入模式进入普通模式</span><br><span class="line">Ctrl-[    退出输入模式进入普通模式</span><br><span class="line">Ctrl-c    与 Ctrl-[ 和 &lt;esc&gt;功能相同, 但是不检查缩写</span><br></pre></td></tr></table></figure>

<p>我发现<code> esc</code>键在键盘上太远了，很难够到，所以我在我的机器上将<code> caps lock</code> 映射成了<code>esc</code>键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现<code>esc</code>键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在<code>q</code>键的左边，所以我认为将<code>caps lock</code> 映射成<code>esc</code>键是合理的。</p>
<p>另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap jj &lt;esc&gt;</span><br><span class="line">inoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure>

<h2 id="重复输入模式"><a href="#重复输入模式" class="headerlink" title="重复输入模式"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10i</span><br></pre></td></tr></table></figure>

<p>如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p>
<h2 id="在输入模式中删除大块文本"><a href="#在输入模式中删除大块文本" class="headerlink" title="在输入模式中删除大块文本"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用<code>d</code>来删除错误。或者，你能用以下命令在&#x3D;&#x3D;输入模式下就删除一个或者多个字符&#x3D;&#x3D;：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure>

<p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）</p>
<h2 id="用寄存器进行输入"><a href="#用寄存器进行输入" class="headerlink" title="用寄存器进行输入"></a>用寄存器进行输入</h2><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键<code>Ctrl-r</code>加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。</p>
<p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ayiw</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a</li>
<li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。</li>
</ul>
<p>现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r a</span><br></pre></td></tr></table></figure>

<p>Vim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。</p>
<h2 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h2><p>你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键<code>Ctrl-x</code>进入<code>Ctrl-x</code>子模式，你可以进行一些额外操作，页面滚动正是其中之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-y    向上滚动页面</span><br><span class="line">Ctrl-x Ctrl-e    向下滚动页面</span><br></pre></td></tr></table></figure>

<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>Vim在进入<code>Ctrl-x</code>子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。</p>
<p>下面列出了一些适合入门时学习的自动补全命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-l	   补全一整行</span><br><span class="line">Ctrl-x Ctrl-n	   从当前文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-i	   从引用（include）的文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-f	   补全一个文件名</span><br></pre></td></tr></table></figure>

<p>当你触发自动补全时，Vim会显示一个选项弹窗，可以使用<code>Ctrl-n</code>和<code>Ctrl-p</code>来分别向上和向下浏览选项。</p>
<p>Vim也提供了两条不需要进入<code>Ctrl-x</code>模式就能使用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-n             使用下一个匹配的单词进行补全</span><br><span class="line">Ctrl-p             使用上一个匹配的单词进行补全</span><br></pre></td></tr></table></figure>

<p>通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是”Chocolate donuts are the best”：</p>
<ul>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-x Ctrl-l</code>， Vim会进行匹配并输出这一整行的文本。</li>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-p</code>，Vim会进行匹配并输出”Chocolate”这个单词。</li>
</ul>
<p>Vim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看。</p>
<h2 id="执行普通模式下的命令"><a href="#执行普通模式下的命令" class="headerlink" title="执行普通模式下的命令"></a>执行普通模式下的命令</h2><p>你知道Vim可以在输入模式下执行普通模式的命令吗？</p>
<p>在输入模式下， 如果你按下<code>Ctrl-o</code>，你就会进入到<code>insert-normal</code>（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下<code>Ctrl-o</code>后就会变为<code>-- (insert) --</code>。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：</p>
<p><strong>设置居中以及跳转</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o zz       居中窗口</span><br><span class="line">Ctrl-o H/M/L    跳转到窗口的顶部/中部/底部</span><br><span class="line">Ctrl-o &#x27;a       跳转到标志&#x27;a处</span><br></pre></td></tr></table></figure>

<p><strong>重复文本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o 100ihello    输入 &quot;hello&quot; 100 次</span><br></pre></td></tr></table></figure>

<p><strong>执行终端命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o !! curl https://google.com    运行curl命令</span><br><span class="line">Ctrl-o !! pwd                        运行pwd命令</span><br></pre></td></tr></table></figure>

<p><strong>快速删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o dtz    从当前位置开始删除文本，直到遇到字母&quot;z&quot;</span><br><span class="line">Ctrl-o D      从当前位置开始删除文本，直到行末</span><br></pre></td></tr></table></figure>

<h2 id="聪明地学习输入模式"><a href="#聪明地学习输入模式" class="headerlink" title="聪明地学习输入模式"></a>聪明地学习输入模式</h2><p>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。</p>
<p>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。</p>
<h1 id="第7章-点命令"><a href="#第7章-点命令" class="headerlink" title="第7章 点命令"></a>第7章 点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令。</p>
<p>比如，如果你想将下面文本中的所有”let“替换为”const”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用<code>/let</code>来进行匹配。</li>
<li>接着，使用<code>cwconst&lt;esc&gt;</code>来将”let”替换成”const”。</li>
<li>第三步，使用<code>n</code>来找到下一个匹配的位置。</li>
<li>最后，使用点命令(<code>.</code>)来重复之前的操作。</li>
<li>持续地使用<code>n . n .</code>直到每一个匹配的词都被替换。</li>
</ul>
<p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。</p>
<h2 id="什么才算是修改操作？"><a href="#什么才算是修改操作？" class="headerlink" title="什么才算是修改操作？"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？</p>
<p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作。</p>
<p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作。现在假设你有以下这么一个句子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>

<p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df,</code>来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除。</p>
<p>让我们再来试试另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>

<p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f,</code>来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用<code>.</code>来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？</p>
<p>在Vim里，修改操作是不包括移动（motions）的，因为移动(motions)不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df,</code>进行一下对比的话，你会发现<code>df,</code>中的<code>f,</code>告诉删除操作<code>d</code>哪里需要删除，是整个删除命令<code>df,</code>的一部分。</p>
<p>让我们想想办法完成这个任务。在你运行<code>f,</code>并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; . ; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.</code>。</p>
<p>再来试试下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancake</span><br><span class="line">potatoes</span><br><span class="line">fruit-juice</span><br></pre></td></tr></table></figure>

<p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j . j . </code>来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>。</p>
<p>从你按下输入命令（A）开始到你退出输入模式（<esc>）之间的所有输入都算作是一整个修改操作。</p>
<h2 id="重复多行修改操作"><a href="#重复多行修改操作" class="headerlink" title="重复多行修改操作"></a>重复多行修改操作</h2><p>假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">const foo = &quot;bar&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br><span class="line">let six = &quot;6&quot;;</span><br><span class="line">let seven = &quot;7&quot;;</span><br><span class="line">let eight = &quot;8&quot;;</span><br><span class="line">let nine = &quot;9&quot;;</span><br></pre></td></tr></table></figure>

<p>你的目标是删除除了含有”foo”那一行以外的所有行。首先，使用<code>d2j</code>删除前三行。之后跳过”foo”这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是<code>d2jj..</code>。</p>
<p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动(motion)操作，而是整个删除命令的一部分。</p>
<p>我们再来看看下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zlet zzone = &quot;1&quot;;</span><br><span class="line">zlet zztwo = &quot;2&quot;;</span><br><span class="line">zlet zzthree = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br></pre></td></tr></table></figure>

<p>我们的目标是删除所有的’z’。从第一行第一个字符开始，首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个’z’字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个’z’后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个z字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>。</p>
<p>你删除一列上的三个’z‘的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。</p>
<h2 id="在修改中包含移动操作"><a href="#在修改中包含移动操作" class="headerlink" title="在修改中包含移动操作"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n . n .</code>将下面的文本中的’let’都替换成了’const’。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>

<p>其实还有更快的方法来完成整个操作。当你使用<code>/let</code>搜索后，执行<code>cgnconst&lt;Esc&gt;</code>，然后<code>. . .</code>。</p>
<p><code>gn</code>是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且 <strong>自动对匹配的文本进行可视化模式下的选取</strong>。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n . n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。</p>
<p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作。</p>
<blockquote>
<p>（译者在这里研究了一会，并做了不少实验，总结规律是：单独的motion(第4章中所说的名词)不算修改操作，而opeartor(动词)+motion(名词)时(请回顾第4章)，motion被视为一个完整的修改操作中的一部分。再看一个例子，看看<code>/</code>命令是如何被包含在一个修改操作中的：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">foo</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">foo</span><br><span class="line">e</span><br><span class="line">f</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设你的光标在第一行的a上，执行命令<code>d/foo&lt;Esc&gt;</code>，Vim会删除a,b。然后<code>.</code>，Vim会删除foo, c, d，再按<code>.</code>，Vim什么也不做，因为后面没有”foo”了。在这个例子中，<code>/foo</code>是一个motion（名词），是Vim语法(动词+名词：operator + motion)的一部分，前面的<code>d</code>则是动词。<code>d/foo&lt;Esc&gt;</code>这条命令的功能是：从当前光标所在位置开始删除，直到遇到”foo”为止。后面的点命令就重复这个功能，第二次按<code>.</code>之所以Vim什么也不做，是因为找不到下一个匹配了，所以这条命令就失效了。</p>
</blockquote>
<h2 id="聪明地学习点命令"><a href="#聪明地学习点命令" class="headerlink" title="聪明地学习点命令"></a>聪明地学习点命令</h2><p>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了。</p>
<p>在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念。</p>
<p>点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。</p>
<h1 id="第8章-寄存器"><a href="#第8章-寄存器" class="headerlink" title="第8章 寄存器"></a>第8章 寄存器</h1><p>学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。</p>
<p>你可能已经在复制或删除文本并用<code>p</code>或<code>P</code>粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？如果正确地使用Vim寄存器，将帮助您从重复的输入中解放出来。</p>
<p>在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。</p>
<h2 id="寄存器的10种类型"><a href="#寄存器的10种类型" class="headerlink" title="寄存器的10种类型"></a>寄存器的10种类型</h2><p>下面是Vim所拥有的10种寄存器类型：</p>
<ol>
<li>匿名寄存器（<code>&quot;&quot;</code>）.</li>
<li>编号寄存器(<code>&quot;0-9</code>).</li>
<li>小删除寄存器 (<code>&quot;-</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>只读寄存器 (<code>&quot;:</code>, <code>&quot;.</code>, and <code>&quot;%</code>).</li>
<li>Buffer交替文件寄存器 (<code>&quot;#</code>).</li>
<li>表达式寄存器 (<code>&quot;=</code>).</li>
<li>选取和拖放寄存器(<code>&quot;*</code> and <code>&quot;+</code>).</li>
<li>黑洞寄存器 (<code>&quot;_</code>).</li>
<li>搜索模式寄存器 (<code>&quot;/</code>).</li>
</ol>
<h2 id="寄存器命令"><a href="#寄存器命令" class="headerlink" title="寄存器命令"></a>寄存器命令</h2><p>要使用寄存器，您必须先使用命令将内容存储到寄存器，以下是一些存值到寄存器中的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y    复制</span><br><span class="line">c    删除文本并进入输入模式</span><br><span class="line">d    删除文本</span><br></pre></td></tr></table></figure>

<p>其实还有更多的寄存器写入操作（比如<code>s</code>或<code>x</code>），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。</p>
<p>想要从寄存器中取出（粘贴）文本，你可以用以下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p    在光标位置之后粘贴文本</span><br><span class="line">P    在光标位置之前粘贴文本</span><br></pre></td></tr></table></figure>

<p><code>p</code>和<code>P</code>都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用<code>10p</code>。想粘贴寄存器”a”中的文本，可以用<code>&quot;ap</code>。想将寄存器“a”中的文本粘贴10次的话，可以使用<code>10&quot;ap</code>。注意，从技术层面讲，命令<code>p</code>实际上表示的是”put”(放置)，而不是”paste”(粘贴)，使用粘贴只是因为它更符合传统习惯。</p>
<p>从某个特定寄存器中读取文本的通用语法是<code>&quot;x</code>，其中<code>x</code>是这个寄存器的标志。</p>
<h2 id="在输入模式中使用寄存器"><a href="#在输入模式中使用寄存器" class="headerlink" title="在输入模式中使用寄存器"></a>在输入模式中使用寄存器</h2><p>在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器”a”中的文本，通常可以使用<code>&quot;ap</code>来进行。不过当你在输入模式下时，你需要运行<code>Ctrl-r a</code>。在输入模式下使用寄存器的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r x</span><br></pre></td></tr></table></figure>

<p>其中<code>x</code>是寄存器标志。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。</p>
<h2 id="匿名寄存器"><a href="#匿名寄存器" class="headerlink" title="匿名寄存器(&quot;&quot;)"></a>匿名寄存器(<code>&quot;&quot;</code>)</h2><p>想从匿名寄存器中获取文本，可以使用<code>&quot;&quot;p</code>。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。</p>
<p>默认情况下，<code>p</code>(或者<code>P</code>)是和匿名寄存器相关联的（从现在起我将使用<code>p</code>而不是<code>&quot;&quot;p</code>来指代匿名寄存器）。</p>
<h2 id="编号寄存器-0-9"><a href="#编号寄存器-0-9" class="headerlink" title="编号寄存器(&quot;0-9)"></a>编号寄存器(<code>&quot;0-9</code>)</h2><p>编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(<code>0</code>)和其他编号寄存器(<code>1-9</code>)。让我们先来讨论复制寄存器。</p>
<h3 id="复制寄存器-0"><a href="#复制寄存器-0" class="headerlink" title="复制寄存器 (&quot;0)"></a>复制寄存器 (<code>&quot;0</code>)</h3><p>如果你使用<code>yy</code>来复制一整行文本，事实上Vim会将文本存放两个寄存器中：</p>
<ol>
<li>匿名寄存器 (<code>p</code>).</li>
<li>复制寄存器 (<code>&quot;0p</code>).</li>
</ol>
<p>在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器(<code>0</code>)中的内容。其他的任何操作都不会被存放在<code>0</code>号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。</p>
<p>比如，如果你：</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行(<code>dd</code>)</li>
<li>再删除另一行 (<code>dd</code>)</li>
</ol>
<p>复制寄存器中的文本仍然是第一步中复制的文本。</p>
<p>如果你:</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行 (<code>dd</code>)</li>
<li>复制另一行 (<code>yy</code>)</li>
</ol>
<p>复制寄存器中的内容则是第三步中复制的内容。</p>
<p>还有一个小技巧，在输入模式下，你可以使用<code>Ctrl-r 0</code>快速地粘贴你刚才复制的内容。</p>
<h3 id="编号寄存器-1-9"><a href="#编号寄存器-1-9" class="headerlink" title="编号寄存器 (&quot;1-9)"></a>编号寄存器 (<code>&quot;1-9</code>)</h3><p>当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（&#x3D;&#x3D;编号越小时间距离越近&#x3D;&#x3D;）</p>
<p>比如，你有以下这些文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line three</span><br><span class="line">line two</span><br><span class="line">line one</span><br></pre></td></tr></table></figure>

<p>当你的光标在文本“line three”上时,使用<code>dd</code>来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是”line one”（时间上最近的文本）， 2号寄存器则包含”line two”(时间上第二近的文本)，3号寄存器中则包含”line three”（最早删除的文本）。普通模式下可以使用<code>&quot;1p</code>来获取1号寄存器中的内容。</p>
<p>&#x3D;&#x3D;编号寄存器的编号在使用点命令时会自动增加&#x3D;&#x3D;。比如，如果你的1号编号寄存器（<code>&quot;1</code>）中的内容为”line one”， 2号寄存器（<code>&quot;2</code>）为”line two”, 三号寄存器（<code>&quot;3</code>）”line three”,你可以使用以下的技巧来连续地粘贴他们：</p>
<ul>
<li>使用<code>&quot;1p</code>来粘贴1号寄存器中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴2号寄存器（<code>&quot;2</code>）中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴3号寄存器（<code>&quot;3</code>）中的内容。</li>
</ul>
<p>在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(<code>&quot;5P</code>), 点命令<code>.</code>会执行<code>&quot;6P</code>,再次使用<code>.</code>则会执行<code>&quot;7P</code>,等等。</p>
<p>小型的删除比如单词删除（<code>dw</code>)或者单词修改(<code>cw</code>)不会被存储在编号寄存器中，它们被存储在小删除寄存器(<code>&quot;-</code>)中，我将在接下来的一小节讨论小删除寄存器。</p>
<h2 id="小删除寄存器"><a href="#小删除寄存器" class="headerlink" title="小删除寄存器(&quot;-)"></a>小删除寄存器(<code>&quot;-</code>)</h2><p>&#x3D;&#x3D;不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (<code>&quot;-</code>)中。&#x3D;&#x3D;</p>
<p>比如:</p>
<ol>
<li>删除一个单词 (<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给你第一步中删除的单词。</p>
<p>另一个例子:</p>
<ol>
<li>删除一个单词(<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一个单词 (<code>diw</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给出第三步中删除的单词。类似地, <code>&quot;1p</code> 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。</p>
<h2 id="命名寄存器-a-z"><a href="#命名寄存器-a-z" class="headerlink" title="命名寄存器 (&quot;a-z)"></a>命名寄存器 (<code>&quot;a-z</code>)</h2><p>命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。</p>
<p>为了复制一个单词到寄存器”a”中，你可以使用命令<code>&quot;ayiw</code>。</p>
<ul>
<li><code>&quot;a</code>告诉Vim下一个动作（删除&#x2F;修改&#x2F;复制）会被存储在寄存器”a”中</li>
<li><code>yiw</code>复制这个单词</li>
</ul>
<p>为了从寄存器”a”中获取文本，可以使用命令<code>&quot;ap</code>。你可以使用以26个字母命名的寄存器来存储26个不同的文本。</p>
<p>有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的”a”寄存器中已经存有文本”Hello”，如果你想继续添加”world”到寄存器”a”中，你可以先找到文本”world”然后使用<code>&quot;Aiw</code>来进行复制,即可完成追加。</p>
<h2 id="只读寄存器"><a href="#只读寄存器" class="headerlink" title="只读寄存器(&quot;:, &quot;., &quot;%)"></a>只读寄存器(<code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code>)</h2><p>Vim有三个只读寄存器：<code>.</code>,<code>:</code>和<code>%</code>，它们的用法非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.    存储上一个输入的文本</span><br><span class="line">:    存储上一次执行的命令</span><br><span class="line">%    存储当前文件的文件名</span><br></pre></td></tr></table></figure>

<p>如果你写入”Hello Vim”,之后再运行<code>&quot;.p</code>就会打印出文本”Hello Vim”。如果你想要获得当前文件的文件名，可以运行命令<code>&quot;%p</code>。如果你运行命令<code>:s/foo/bar/g</code>，再运行<code>&quot;:p</code>的话则会打印出文本”s&#x2F;foo&#x2F;bar&#x2F;g”。</p>
<h2 id="Buffer交替文件寄存器"><a href="#Buffer交替文件寄存器" class="headerlink" title="Buffer交替文件寄存器 (&quot;#)"></a>Buffer交替文件寄存器 (<code>&quot;#</code>)</h2><p>在Vim中，<code>#</code>通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令<code>&quot;#p</code>。</p>
<h2 id="表达式寄存器"><a href="#表达式寄存器" class="headerlink" title="表达式寄存器 (&quot;=)"></a>表达式寄存器 (<code>&quot;=</code>)</h2><p>Vim有一个表达式寄存器，<code>&quot;=</code>,用于计算表达式的结果。</p>
<p>你可以使用以下命令计算数学表达式<code>1+1</code>的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=1+1&lt;Enter&gt;p</span><br></pre></td></tr></table></figure>

<p>在这里，你在告诉Vim你正在使用表达式寄存器<code>&quot;=</code>，你的表达式是（<code>1+1</code>），你还需要输入<code>p</code>来得到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =1+1</span><br></pre></td></tr></table></figure>

<p>你可以使用<code>@</code>来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器”a”中获取文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=@a</span><br></pre></td></tr></table></figure>

<p>之后输入<code>&lt;enter&gt;</code>，再输入<code>p</code>。类似地，想在输入模式中得到寄存器”a”中的值可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =@a</span><br></pre></td></tr></table></figure>

<p>表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的VimScript章节中进一步讲解更多关于表达式的细节。</p>
<h2 id="选取和拖放寄存器"><a href="#选取和拖放寄存器" class="headerlink" title="选取和拖放寄存器 (&quot;*, &quot;+)"></a>选取和拖放寄存器 (<code>&quot;*</code>, <code>&quot;+</code>)</h2><p>你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：<code>quotestar</code> (<code>&quot;*</code>) 和 <code>quoteplus</code> (<code>&quot;+</code>)。你可以用它们来访问从外部程序中复制的文本。</p>
<p>如果你在运行一个外部程序（比如Chrome浏览器），然后你使用<code>Ctrl-c</code>(或者<code>Cmd-c</code>,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用<code>p</code>来粘贴这部分文本的。但是，Vim的两个寄存器<code>&quot;+</code>和<code>&quot;*</code>都是和你系统的粘贴板相连接的，所以你可以使用<code>&quot;+p</code>和<code>&quot;*p</code>来粘贴这些文本。反过来，如果你使用<code>&quot;+yiw</code>或者<code>&quot;*yiw</code>在Vim中复制了一些文本，你可以使用<code>Ctrl-v</code>（或者<code>Cmd-v</code>）。值得注意的是这个方法只在你的Vim开启了<code>+clipboard</code>选项时才有用，可以在命令行中运行<code>vim --version</code>查看这一选项。如果你看见<code>-clipboard</code>的话，则需要安装一下支持Vim粘贴板的配置。</p>
<p>你也许会想如果<code>&quot;*</code>和<code>&quot;+</code>能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是<code>quotestar</code> (<code>&quot;*</code>)寄存器作为X11的首选选项，并使用 <code>quoteplus</code> (<code>&quot;+</code>)作为粘贴板选项。这只在你的Vim配置里开启了<code>xterm_clipboard</code> 选项时才有效（<code>vim --version</code>中的<code>+xterm_clipboard</code>）。如果你的的Vim配置中没有 <code>xterm_clipboard</code>也不是什么大问题。这只是意味着<code>quotestar</code> 和<code>quoteplus</code>两个寄存器是可以互相替代的。</p>
<p>我发觉使用<code>=*p</code>或者<code>=+p</code>的话比较麻烦，为了使Vim仅使用<code>p</code>就能粘贴从外部程序复制的文本，你可以在你的<code>vimrc</code>配置文件中加入下面一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set clipboard=unnamed</span><br></pre></td></tr></table></figure>

<p>现在当我从外部程序中复制文本时，我可以使用匿名寄存器<code>p</code>来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用<code>Ctrl-v</code>来粘贴。如果你的Vim开启了 <code>+xterm_clipboard</code>设置，你或许会想同时也使用<code>unnamed</code>和<code>unnamedplus</code>的粘贴板选项。</p>
<h2 id="黑洞寄存器"><a href="#黑洞寄存器" class="headerlink" title="黑洞寄存器 (&quot;_)"></a>黑洞寄存器 (<code>&quot;_</code>)</h2><p>你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？</p>
<p>你可以使用黑洞寄存器（<code>&quot;_</code>）。想要删除一行并且不将其存储在任何寄存器中时，可以使用<code>&quot;_dd</code>命令.</p>
<p>它是和 <code>/dev/null</code> 类似的寄存器。</p>
<h2 id="搜索模式寄存器"><a href="#搜索模式寄存器" class="headerlink" title="搜索模式寄存器 (&quot;/)"></a>搜索模式寄存器 (<code>&quot;/</code>)</h2><p>为了粘贴你的上一个搜索询问（<code>/</code> 或 <code>?</code>），你可以使用搜索模式寄存器(<code>&quot;/</code>)。使用命令 <code>&quot;/p</code>就能粘贴上一个搜索的条目。</p>
<h2 id="查看所有的寄存器"><a href="#查看所有的寄存器" class="headerlink" title="查看所有的寄存器"></a>查看所有的寄存器</h2><p>你可以使用<code>:register</code>命令来查看你的所有寄存器。如果你只想查看”a”,”1”和”-“寄存器的内容的话则可以使用命令<code>:register a 1 -</code>。</p>
<p>有一个Vim的插件叫做 <a target="_blank" rel="noopener" href="https://github.com/junegunn/vim-peekaboo">vim-peekaboo</a> ,可以让你查看到寄存器的内容，在普通模式下输入<code>&quot;</code>或<code>@</code> 即可，或者在输入模式中输入<code>Ctrl-r</code>。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！</p>
<h2 id="执行寄存器"><a href="#执行寄存器" class="headerlink" title="执行寄存器"></a>执行寄存器</h2><p>命名寄存器不只可以用来存放文本，你还可以借助<code>@</code>来执行宏命令。我会在下一章节中介绍宏命令。</p>
<p>注意，因为宏命令时存储在Vim寄存器中的，使用宏时可能会覆盖存储的内容。如果你将文本”Hello Vim”存放在寄存器”a”中，并且之后你在同一个寄存器里记录了一个宏命令 (<code>qa&#123;macro-commands&#125;q</code>),那么这个宏命令将会覆盖之前存储的文本”Hello Vim”（你可以使用<code>@a</code>来执行寄存器中存储的宏命令）。</p>
<h2 id="清除寄存器"><a href="#清除寄存器" class="headerlink" title="清除寄存器"></a>清除寄存器</h2><p>从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行<code>qaq</code>，Vim就会在寄存器”a”中记录一个空的宏命令。</p>
<p>还有一种方法就是运行命令<code>:call setreg(&#39;a&#39;,&#39;hello register a&#39;)</code>,其中’a’代表的就是寄存器”a”。而”hello register a”就是你想存储的内容。</p>
<p>还有一种清除寄存器的方法就是使用表达式<code>:let @a = &#39;&#39;</code>来将寄存器”a 的值设为空的字符串。</p>
<h2 id="获取寄存器中的内容"><a href="#获取寄存器中的内容" class="headerlink" title="获取寄存器中的内容"></a>获取寄存器中的内容</h2><p>你可以使用<code>:put</code>命令来粘贴任何寄存器的内容。比如，如果你运行命令<code>:put a</code>,Vim就会打印出寄存器”a”的内容，这和<code>&quot;ap</code>非常像，唯一的区别在于在普通模式下命令<code>p</code>在当前光标位置之后打印寄存器的内容，而<code>:put</code>新起一行来打印寄存器的内容。</p>
<p>因为<code>:put</code>是一个命令行命令，您可以传一个地址给它。<code>:10put a</code>将会在当前光标下数10行，然后插入新行，内容为寄存器a中的内容。</p>
<p>一个很酷的技巧是将黑洞寄存器(<code>&quot;_</code>)传给<code>:put</code>命令。因为黑洞寄存器不保存任何值，<code>:put _</code>命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本”end”结尾的行下插入空行，使用<code>:g/end/put _</code>。在后面您将了解关于全局命令的知识。</p>
<h2 id="聪明地学习寄存器"><a href="#聪明地学习寄存器" class="headerlink" title="聪明地学习寄存器"></a>聪明地学习寄存器</h2><p>恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。</p>
<p>我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：</p>
<ol>
<li>匿名寄存器(<code>&quot;&quot;</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>编号寄存器 (<code>&quot;0-9</code>).</li>
</ol>
<p>既然匿名寄存器是默认和<code>p</code>或<code>P</code>，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。</p>
<p>普通人的短期记忆都是有极限的，大概每次只能记住5-7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器”a”开始用，之后用寄存器”b”,以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。</p>
<p>Vim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。</p>
<h1 id="第9章-宏命令"><a href="#第9章-宏命令" class="headerlink" title="第9章 宏命令"></a>第9章 宏命令</h1><p>在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。</p>
<p>在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。</p>
<h2 id="基本宏命令"><a href="#基本宏命令" class="headerlink" title="基本宏命令"></a>基本宏命令</h2><p>宏命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qa                     开始记录动作到寄存器 a</span><br><span class="line">q (while recording)    停止记录</span><br></pre></td></tr></table></figure>

<p>你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@a    Execute macro from register a</span><br><span class="line">@@    Execute the last executed macros</span><br></pre></td></tr></table></figure>

<p>假设你有如下的文本，你打算将每一行中的所有字母都变为大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">vim</span><br><span class="line">macros</span><br><span class="line">are</span><br><span class="line">awesome</span><br></pre></td></tr></table></figure>

<p>将你的光标移动到 “hello” 栏的行首，并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0gU$jq</span><br></pre></td></tr></table></figure>

<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>gU$</code> 将从光标到行尾的字母变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>调用 <code>@a</code> 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 <code>3@a</code> 去执行 <code>a</code> 命令3次。你也可以执行 <code>3@@</code> 去执行上一次执行过的宏命令3次。</p>
<h2 id="安全保护"><a href="#安全保护" class="headerlink" title="安全保护"></a>安全保护</h2><p>在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>

<p>你想将每一行的第一个词变为大写，你可以使用如下的宏命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0W~jq</span><br></pre></td></tr></table></figure>

<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 将光标选中的单词变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>我喜欢对宏命令进行超过所需次数的调用，所以我通常使用 <code>99@a</code> 命令去执行该宏命令99次。使用该命令，Vim并不会真正执行这个宏99次，当 Vim 到达最后一行执行<code>j</code>时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。</p>
<p>实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。</p>
<h2 id="命令行执行宏"><a href="#命令行执行宏" class="headerlink" title="命令行执行宏"></a>命令行执行宏</h2><p>在正常模式执行 <code>@a</code> 并不是宏命令调用的唯一方式。你也可以在命令行执行 <code>：normal @a</code> 。<code>：normal</code> 会将任何用户添加的参数作为命令去执行。例如添加 <code>@a</code>，和在 normal mode 执行 <code>@a</code> 的效果是一样的。</p>
<p><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。</p>
<h2 id="在多个文件中执行宏命令"><a href="#在多个文件中执行宏命令" class="headerlink" title="在多个文件中执行宏命令"></a>在多个文件中执行宏命令</h2><p>假如你有多个 <code>.txt</code> 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是<code>0W~j</code>(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？</p>
<p>第一个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## savory.txt</span><br><span class="line">a. cheddar jalapeno donut</span><br><span class="line">b. mac n cheese donut</span><br><span class="line">c. fried dumpling</span><br></pre></td></tr></table></figure>

<p>第二个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## sweet.txt</span><br><span class="line">a. chocolate donut</span><br><span class="line">b. chocolate pancake</span><br><span class="line">c. powdered sugar donut</span><br></pre></td></tr></table></figure>

<p>第三个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## plain.txt</span><br><span class="line">a. wheat bread</span><br><span class="line">b. plain donut</span><br></pre></td></tr></table></figure>

<p>你可以这么做:</p>
<ul>
<li><code>:args *.txt</code> 查找当前目录下的所有 <code>.txt</code> 文件。</li>
<li><code>:argdo g/donut/normal @a</code> 在 <code>:args</code> 中包含的每一个文件里执行一个全局命令 <code>g/donut/normal @a</code>。</li>
<li><code>:argdo update</code> 在 <code>:args</code> 中包含的每一个文件里执行 <code>update</code> 命令,保存修改后的内容。</li>
</ul>
<p>也许你对全局命令 <code>:g/donut/normal @a</code> 不是很了解，该命令会执行 <code>/donut/</code>搜索命令，然后在所有匹配的行中执行<code>normal @a</code> 命令。我会在后面的章节中介绍全局命令。</p>
<h2 id="递归执行宏命令"><a href="#递归执行宏命令" class="headerlink" title="递归执行宏命令"></a>递归执行宏命令</h2><p>你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏寄存器来实现。假如你有如下文本，你希望改变第一个单词的大小写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>

<p>如下命令会递归地执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qaqqa0W~j@aq</span><br></pre></td></tr></table></figure>

<p>上面命令的分解如下：</p>
<ul>
<li><code>qaq</code> 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。</li>
<li><code>qa</code> 开始录入宏命令到寄存器 “a”。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 改变光标选中的单词的大小写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>@a</code> 执行宏命令 “a”。当你记录该宏命令时，<code>@a</code> 应该是空白的，因为你刚刚调用了 <code>qaq</code>。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>现在，让我们调用 <code>@a</code> 来查看 Vim 如何递归的调用该宏命令。</p>
<p>宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 <code>j</code> 命令时，发现已经没有下一行了，就会停止执行。</p>
<h2 id="增添一个已知宏"><a href="#增添一个已知宏" class="headerlink" title="增添一个已知宏"></a>增添一个已知宏</h2><p>如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来想该寄存器中添加内容。同样的，为了在寄存器”a”中添加更多的操作，你也可以使用大写字母”A”。</p>
<p>假设寄存器a中已经存储了这个宏命令:<code>qa0W~q</code>(该宏命令将某行的第二个词组的头一个字母执行改变大小写操作)，假设你想在这个基础上添加一些操作命令序列，使得每一行末尾添加一个句点，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qAA.&lt;esc&gt;q</span><br></pre></td></tr></table></figure>

<p>分解如下:</p>
<ul>
<li><code>qA</code> 开始在寄存器 “A” 中记录宏命令。</li>
<li><code>A.&lt;esc&gt;</code> 在行的末尾加上一个句点(这里的<code>A</code>是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，当你执行<code>@a</code>时，它不仅将第二个词组的首字母转变大小写，同时还在行尾添加一个句点。</p>
<h2 id="修改一个已知宏"><a href="#修改一个已知宏" class="headerlink" title="修改一个已知宏"></a>修改一个已知宏</h2><p>如果想在一个宏的中间添加新的操作该怎么办呢？</p>
<p>假设您在寄存器a中已经存有一个宏命令<code>0W~A.&lt;Esc&gt;</code>，即改变首字母大小写，并在行尾添加句号。如果您想在改变首字母大小写和行尾添加句号之间，在单词”dount”前面加入”deep fried”。（因为唯一比甜甜圈好的东西就是炸甜甜圈）。</p>
<p>我会重新使用上一节使用过的文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>

<p>首先，让我们通过 <code>:put a</code> 调用一个已经录制好的宏命令（假设你上一节中保存在寄存器a中的宏命令还在）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~A.^[</span><br></pre></td></tr></table></figure>

<p><code>^[</code> 是什么意思呢？不记得了吗，你之前执行过 <code>0W~A.&lt;esc&gt;</code>。 <code>^[</code> 是 Vim 的 <strong>内部指令</strong>，表示 <code>&lt;esc&gt;</code>。通过这些指定的特殊键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 <code>&lt;esc&gt;</code>，<code>&lt;backspace&gt;</code>，<code>&lt;enter&gt;</code>。还有一些其他的键值组合，但这不是本章的内容。</p>
<p>回到宏命令，在改变大小写之后的键后面（<code>~</code>），让我们添加（<code>$</code>）来移动光标到行末，回退一个单词（<code>b</code>），进入插入模式（<code>i</code>），输入”deep fried “ （别忽略”fried “后面的这个空格），之后退出插入模式（<code>&lt;esc&gt;</code>）。</p>
<p>完整的命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried &lt;esc&gt;A.^[</span><br></pre></td></tr></table></figure>

<p>这里有一个问题，Vim 不能理解 <code>&lt;esc&gt;</code>。您不能依葫芦画瓢输入”<Esc>“，所以你需要将<code>&lt;Esc&gt;</code>写成内部代码的形式。在插入模式，在按下<code>&lt;esc&gt;</code>后按下 <code>Ctrl-v</code>，Vim 会打印 <code>^[</code>。 &#x3D;&#x3D;<code>Ctrl-v</code> 是一个插入模式的操作符，可以逐字地插入一个非数字字符&#x3D;&#x3D;。你的宏命令应该如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried ^[A.^[</span><br></pre></td></tr></table></figure>

<p>为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知命名寄存器中添加一个新条目的方式来实现。在一行的行首，执行 <code>&quot;ay$</code>，使用寄存器 “a”来存储复制的文本。</p>
<p>现在，但你执行 <code>@a</code> 时，你的宏命令会自动改变第一个单词的大小写，在”donut”前面添加”deep fried “，之后在行末添加“.”。</p>
<p>另一个修改宏命令的方式是通过命令行表达式。执行 <code>:let @a=&quot;</code>，之后执行 <code>Ctrl-r Ctrl-r a</code>，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（<code>&quot;</code>）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 <code>Ctrl-v</code>。</p>
<h2 id="拷贝宏"><a href="#拷贝宏" class="headerlink" title="拷贝宏"></a>拷贝宏</h2><p>你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 <code>:let @z = @a</code> 将寄存器”a” 中的命令拷贝到寄存器”z”。 <code>@a</code> 表示寄存器“a”中存储的内容，你现在执行 <code>@z</code>，将会执行和 <code>@a</code> 一样的指令。</p>
<p>我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。</p>
<h2 id="串行宏和并行宏"><a href="#串行宏和并行宏" class="headerlink" title="串行宏和并行宏"></a>串行宏和并行宏</h2><p>Vim 可以连续和同时运行宏命令，假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>

<p>假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0f&#123;gui&#123;jq</span><br></pre></td></tr></table></figure>

<p>分解如下：</p>
<ul>
<li><code>qa</code> 开始记录宏命令到 “a” 寄存器。</li>
<li><code>0</code>移动到第一行。</li>
<li><code>f&#123;</code> 查找第一个 “{” 字符。</li>
<li><code>gui&#123;</code> 把括号内的文本（<code>i&#123;</code>）变为小写（<code>gu</code>）。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，执行 <code>99@a</code> 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import foo from &quot;bar&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>

<p>执行 <code>99@a</code>，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时<code>f&#123;</code>命令会遇到错误而停止，当宏串行执行时就会发生这样的情况。当然，你仍然可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？</p>
<p>你可以并行地执行宏命令。</p>
<p>如本章前面所说，可以使用 <code>:normal</code> 去执行宏命令，（例如： <code>:3,5 normal @a</code> 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 <code>:1,$ normal @a</code>，会在所有除了包含有 “foo” 的行执行，而且它不会出错。</p>
<p>尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（<code>1,$</code>）每一行执行 <code>@a</code> 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。</p>
<h2 id="聪明地学习宏命令"><a href="#聪明地学习宏命令" class="headerlink" title="聪明地学习宏命令"></a>聪明地学习宏命令</h2><p>你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。</p>
<p>刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。</p>
<p>使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它(<code>qf</code>)。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的(<code>qn</code>)。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令默认寄存器，因为执行 <code>qq</code> 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 <code>qa</code> 到 <code>qb</code> 再到 <code>qc</code>。</p>
<p>去寻找最适合你的方法吧。</p>
<h1 id="第10章-撤销"><a href="#第10章-撤销" class="headerlink" title="第10章 撤销"></a>第10章 撤销</h1><p>所有人都会犯各种各样的输入错误。因此对于任何一个现代的软件来说，撤销都是一个很基本的功能。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持存取不同的文本形态，让你能控制你输入的所有文本。在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。 </p>
<h2 id="撤销-undo-，重做和行撤销-UNDO"><a href="#撤销-undo-，重做和行撤销-UNDO" class="headerlink" title="撤销(undo)，重做和行撤销(UNDO)"></a>撤销(undo)，重做和行撤销(UNDO)</h2><p>对于一个基本的 undo 操作，你可以执行 <code>u</code> 或者 <code>:undo</code>。</p>
<p>假设你有如下文本(注意”one”下面有一个空行)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后添加另一个文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>如果你执行 <code>u</code>，Vim 会删除 “two”。</p>
<p>Vim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。</p>
<p>要取消上一次的撤销，可以执行 <code>Ctrl-r</code> 或者 <code>:redo</code>。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 <code>Ctrl-r</code> 来恢复被删除掉的文本。</p>
<p>Vim 也有另一个命令 <code>U</code> 可以实现 行撤销 (UNDO) 的功能，执行这个命令会撤销所有最新的修改。</p>
<p>那么，<code>U</code> 和 <code>u</code> 的区别是什么呢？首先，<code>U</code> 会删除 <em>最近修改的行中所有的</em> 的修改，而 <code>u</code> 一次仅删除一次修改。 其次，执行<code>u</code> 不会被算作一次修改操作，而执行 <code>U</code> 则会被算作一次修改。</p>
<p>让我们会的之前的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>修改第二行的内容为 “three” (<code>ciwthree&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>再次修改第二行的例子为 “four” (<code>ciwfour&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>

<p>此时，如果你按下 <code>u</code>，你会看到 “three”。如果你再次按下 <code>u</code>，你会看到 “two”。然而，在第二行仍为 “four” 的时候，如果你按下 <code>U</code>，你会看到 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行 <code>U</code> 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 <code>U</code> 后 再次执行 <code>U</code> 会撤销 自己。假如你连续执行 <code>U</code>，那么你将看到第二行的文本不停地出现和消失。</p>
<p>就我个人而言，我几乎不会使用 <code>U</code>，因为很难记住文本最初的样子。（我几乎不使用它）</p>
<p>Vim 可以通过变量 <code>undolevels</code> 来选择最多可执行 undo 的次数。你可以通过 <code>:echo &amp;undolevels</code> 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 <code>:set undolevels=1000</code>。不用担心，你可以设置它为任何一个你想设置的值。</p>
<h2 id="断点插入操作"><a href="#断点插入操作" class="headerlink" title="断点插入操作"></a>断点插入操作</h2><p>在上文中我提到，<code>u</code> 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。</p>
<p>如果你执行 <code>ione two three&lt;esc&gt;</code> 之后，按下 <code>u</code>，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 <code>u</code>，你会丢失上一次输入的所有内容。 因此，假设你按下 <code>u</code> 只删除你上一次输入的一部分文本岂不是会更好。</p>
<p>幸运的是，你可以拆分它。当你在插入模式时，按下 <code>Ctrl-G u</code> 会生成一个断点。例如，如果你执行 <code>ione &lt;Ctrl-G u&gt;two &lt;Ctrl-G u&gt;three&lt;esc&gt;</code>，之后你按下<code>u</code>，你仅会失去文本 “three”，再次执行 <code>u</code>，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。&#x3D;&#x3D;在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。&#x3D;&#x3D;</p>
<p>在插入模式中，执行删除操作时插入断点也非常有用。例如通过 <code>Ctrl-W</code> 删除光标前的单词时，以及 <code>Ctrl-U</code>删除光标前的所有文本时。一个朋友建议我使用如下的映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap &lt;c-u&gt; &lt;c-g&gt;u&lt;c-u&gt;</span><br><span class="line">inoremap &lt;c-w&gt; &lt;c-g&gt;u&lt;c-w&gt;</span><br></pre></td></tr></table></figure>

<p>通过上述命令，你可以很轻松地恢复被删除的文本。</p>
<h2 id="撤销树"><a href="#撤销树" class="headerlink" title="撤销树"></a>撤销树</h2><p>Vim 将每一次修改存储在一个撤销树中。你打开一个空白文件，然后添加一段新文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再插入一段新文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>undo一次:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入一段不同的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>再次 undo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次插入另一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>现在如果你执行 undo,您将丢失刚刚添加的文本 “four” :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你再次执行 undo 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 <code>g+</code>，你会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次执行 <code>g+</code> ，你将会看到一位老朋友:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>让我们继续执行 <code>g+</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>再一次执行 <code>g+</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>

<p>在 Vim 中，你每一次执行 <code>u</code> 去做一次修改时，Vim都会通过创建一个”撤销分支”来保存之前的文本内容。在本例中，你输入”two”后, 执行 <code>u</code>，然后输入”three”，你就创建了一个叶子分支,保存了含有”two”的文本状态。此时，撤销树已经包含了至少两个叶子节点，主节点包含文本”three”（最新），而另一undo分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了”four”，那么此时会生成三个节点，一个主节点包含文本”four”, 以及另外两个节点分别存储了”three”和”two”。</p>
<p>为了在几个不同的节点状态间进行切换，你可以执行 <code>g+</code> 去获取一个较新的状态，以及执行 <code>g-</code> 去获取一个教旧的状态。 <code>u</code>， <code>Ctrl-R</code>， <code>g+</code>， 和 <code>g-</code> 之间的区别是，<code>u</code> and <code>Ctrl-R</code> 只可以在 <em>main</em> 节点之间进行切换，而<code>g+</code> 和 <code>g-</code> 可以在 <em>所有</em> 节点之间进行切换。</p>
<p>Undo 树并不可以很轻松地可视化。我发现一个插件 <a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。 </p>
<h2 id="保存撤销记录"><a href="#保存撤销记录" class="headerlink" title="保存撤销记录"></a>保存撤销记录</h2><p>当你通过 Vim 打开一个文件，并且立即按下 <code>u</code>，Vim 很可能会显示 “<em>Already at oldest change</em>” 的警告。 </p>
<p>要想从最近的一次编辑工作中（在vim关闭文件再打开，算做一次新的编辑工作），在撤销历史中回滚，可以通过 <code>:wundo</code>命令使Vim 保存一份你的 undo 历史记录。</p>
<p>创建一个文件 <code>mynumbers.txt</code>. 输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>

<p>插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>插入新的一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>现在，创建你的撤销记录文件。 语法为 <code>:wundo myundofile</code>。 如果你需要覆盖一个已存在的文件，在 <code>wundo</code> 之后添加 <code>!</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wundo! mynumbers.undo</span><br></pre></td></tr></table></figure>

<p>退出 Vim。</p>
<p>此时，在目录下，应该有<code>mynumbers.txt</code> 和 <code>mynumbers.undo</code> 两个文件。再次打开 <code>mynumbers.txt</code> 文件并且按下 <code>u</code>，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 <code>:rundo</code> 来加载 undo 历史。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rundo mynumbers.undo</span><br></pre></td></tr></table></figure>

<p>此时，如果你按下 <code>u</code>，Vim 会删除 “three”。再次按下 <code>u</code>可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。</p>
<p>如果你想要自动加载 undo 历史文件，你可以通过在你的 <code>.vimrc</code> 文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set undodir=~/.vim/undo_dir</span><br><span class="line">set undofile</span><br></pre></td></tr></table></figure>

<p>我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 <code>~/.vim</code> 目录下。 <code>undo_dir</code> 是随意的。 <code>set undofile</code> 告诉 Vim 打开 <code>undofile</code> 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用<code>undo_dir</code>目录前，请确保你已经创建了它）。</p>
<h2 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h2><p>是谁说时间旅行不存在。 Vim 可以通过 <code>:earlier</code> 命令将文本恢复为之前的状态。</p>
<p>假如有如下文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后你输入了另一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>:undolist</code> 去查看之前所做的修改。 <code>:earlier</code> 可以加上分钟 (<code>m</code>), 小时 (<code>h</code>), and 天 (<code>d</code>) 作为参数。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s    恢复到10秒前的状态</span><br><span class="line">:earlier 10m    恢复到10分钟前的状态</span><br><span class="line">:earlier 10h    恢复到10小时前的状态</span><br><span class="line">:earlier 10d    恢复到10天前的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，它同样接受一个<code>计数</code>作为参数，告诉vim恢复到老状态的次数。比如，如果运行<code>:earlier 2</code>,Vim将恢复到2次修改前的状态。功能类似于执行<code>g-</code>两次。同样，你可以运行<code>:earlier 10f</code>命令告诉vim恢复到10次保存前的状态。</p>
<p>这些参数同样作用于<code>:earlier</code>命令的对应版本:<code>:later</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:later 10s    恢复到10秒后的状态</span><br><span class="line">:later 10m    恢复到10分钟后的状</span><br><span class="line">:later 10h    恢复到10小时后的状</span><br><span class="line">:later 10d    恢复到10天后的状态</span><br><span class="line">:later 10     恢复到新状态10次</span><br><span class="line">:later 10f    恢复到10次保存后的状态</span><br></pre></td></tr></table></figure>

<h2 id="聪明地学习撤销操作"><a href="#聪明地学习撤销操作" class="headerlink" title="聪明地学习撤销操作"></a>聪明地学习撤销操作</h2><p><code>u</code> 和 <code>Ctrl-R</code> 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用<code>:earlier</code> 和 <code>:later</code>，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 <a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。</p>
<p>在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。</p>
<h1 id="第11章-可视模式"><a href="#第11章-可视模式" class="headerlink" title="第11章 可视模式"></a>第11章 可视模式</h1><p>高亮显示文本块并对其进行更改，是很多文本编辑器中的常见功能。 Vim也可以使用可视模式实现这一功能。在本章中，您将学习如何使用可视模式来有效地处理文本块。</p>
<h2 id="三种可视模式"><a href="#三种可视模式" class="headerlink" title="三种可视模式"></a>三种可视模式</h2><p>Vim有三种可视模式，分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v         逐字符可视模式</span><br><span class="line">V         逐行可视模式</span><br><span class="line">Ctrl-v    逐块可视模式</span><br></pre></td></tr></table></figure>

<p>如果您有下列文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>逐字符可视模式用于选择单个字符。在第一行的第一个字符上按<code>v</code>。然后使用<code>j</code>跳转至下一行。它高亮显示从”one”到光标位置的所有文本。现在，如果您按<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐行可视模式适用于整行。按<code>V</code>并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按<code>Ctrl-V</code>，Vim像逐字符可视模式一样高亮显示光标下的字符，但向下移动时，除非光标已经在行尾，否则不会高亮显示光标上方的整行，它跳转至下一行时高亮显示尽可能少的字符。尝试用<code>h/j/k/l</code>移动，并观察光标的移动。</p>
<p>在Vim窗口的左下方，您会看到显示<code>-- VISUAL --</code>，<code>-- VISUAL LINE --</code>或<code>-- VISUAL BLOCK --</code>以提示您所处的可视模式。</p>
<p>当您处于可视模式时，可以通过按<code>v</code>，<code>V</code>或<code>Ctrl-V</code>键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行<code>Ctrl-V</code>。试试吧！</p>
<p>有三种退出可视模式的方法：<code>esc</code>，<code>Ctrl-C</code>和与当前可视模式相同的键。后者的意思是，如果您当前处于逐行可视模式(<code>V</code>)，则可以通过再次按<code>V</code>退出它。如果您处于字符可视模式，则可以通过按<code>v</code>退出它。如果您处于逐块可视模式，请按<code>Ctrl-V</code>。</p>
<p>实际上，还有另一种进入可视模式的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gv    转到上一个可视模式</span><br></pre></td></tr></table></figure>

<p>它将在与上次相同的高亮显示的文本块上启动相同的可视模式。</p>
<h2 id="可视模式导航"><a href="#可视模式导航" class="headerlink" title="可视模式导航"></a>可视模式导航</h2><p>在可视模式下，您可以使用Vim动作(motion)扩展高亮显示的文本块。</p>
<p>让我们使用之前使用的相同文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>这次让我们从”two”行开始。按<code>v</code>进入字符可视模式(这里的方括号<code>[]</code>表示高亮显示的字符)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>按<code>j</code>，Vim将高亮显示从”two”行到”three”行的第一个字符的所有文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>

<p>假设您刚刚意识到还需要高亮显示”one”行，因此按<code>k</code>。令您沮丧的是，它现在排除了”three”高亮。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？</p>
<p>答案是肯定的。让我们先恢复光标到高亮显示”two”和”three”行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree    &lt;-- 光标</span><br></pre></td></tr></table></figure>

<p>高亮区域跟随光标移动。如果要将其向上扩展到行”one”，则需要将光标移动到”two”，现在您的光标在”three”行上。这时可以用<code>o</code>或<code>O</code>切换光标位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two     &lt;-- 光标</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>

<p>现在，当您按<code>k</code>时，它不再缩小选择，而是向上扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>

<p>在可视模式中使用<code>o</code>或<code>O</code>，光标会在高亮选择区域的开头和结尾跳转，以便与您扩展高亮区域。</p>
<h2 id="可视模式语法"><a href="#可视模式语法" class="headerlink" title="可视模式语法"></a>可视模式语法</h2><p>可视模式与普通模式使用相同的操作符(operations)。</p>
<p>例如，如果您有以下文字，然后您想在可视模式中删除前两行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>用逐行可视模式(<code>V</code>)高亮显示”one”和”two”行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>按下<code>d</code>键将删除选择，类似于普通模式。请注意，与普通模式的语法规则有所不同，动词+名词不适用可视模式。虽然存在相同的动词(<code>d</code>)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词(反过来了)，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。</p>
<p>在普通模式下，有一些命令不需要名词(motion)，例如<code>x</code>删除光标下方的单个字符，还有<code>r</code>替换光标下方的字符(<code>rx</code>将当前光标下的字符替换为<code>x</code>)。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。回到高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>运行<code>x</code>会删除所有高亮显示的文本。</p>
<p>您可以使用此行为在markdown文本中快速创建标题。假设您需要快速下面的文本转换为一级markdown标题(“&#x3D;&#x3D;&#x3D;”):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br></pre></td></tr></table></figure>

<p>首先，您使用<code>yy</code>复制文本，然后使用<code>p</code>粘贴文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">Chapter One</span><br></pre></td></tr></table></figure>

<p>现在转到第二行，以逐行可视模式选择它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">[Chapter One]</span><br></pre></td></tr></table></figure>

<p>在markdown中，您可以通过在文本下方添加一系列<code>=</code>来创建标题，因此您可以通过运行<code>r=</code>来替换整个高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">===========</span><br></pre></td></tr></table></figure>

<p>要了解有关可视模式下的运算符的更多信息，请查看<code>:h visual-operators</code>。</p>
<h2 id="可视模式和Ex命令"><a href="#可视模式和Ex命令" class="headerlink" title="可视模式和Ex命令"></a>可视模式和Ex命令</h2><p>您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式,并想将前两行的”const”替换为”let”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;;</span><br><span class="line">const two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>

<p>用 <em>任意</em> 可视模式高亮显示前两行，然后运行替换命令<code>:s/const/let/g</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;one&quot;;</span><br><span class="line">let two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>

<p>请注意，我说过您可以使用 <em>任何</em> 可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。&#x3D;&#x3D;只要您在每行上至少选择一个字符，就会应用Ex命令。&#x3D;&#x3D;</p>
<h2 id="跨多行编辑"><a href="#跨多行编辑" class="headerlink" title="跨多行编辑"></a>跨多行编辑</h2><p>您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;</span><br><span class="line">const two = &quot;two&quot;</span><br><span class="line">const three = &quot;three&quot;</span><br></pre></td></tr></table></figure>

<p>将光标放在第一行上：</p>
<ul>
<li>进入逐块可视模式，并向下两行(<code>Ctrl-V jj</code>)。</li>
<li>高亮显示到行尾(<code>$</code>)。</li>
<li>按(<code>A</code>) ，然后键入”;”。</li>
<li>退出可视模式(<code>esc</code>)。</li>
</ul>
<p>您应该看到在每一行后面附加的 “;”。666! 有两种方法可以从逐块可视模式进入输入模式：可以使用<code>A</code>在光标后输入文本，也可以使用<code>I</code>在光标前输入文本。请勿将它们与普通模式下的<code>A</code>和<code>I</code>混淆。(普通模式中，<code>A</code>表示在行尾添加内容，<code>I</code>表示在行首非空字符前插入内容)。</p>
<p>另外，您也可以使用<code>:normal</code>命令在多行添加内容：<br>-高亮显示所有3行(<code>vjj</code>)。<br>-输入<code>:normal! A;</code>。</p>
<p>记住，<code>:normal</code>命令执行普通模式命令。您可以指示它运行<code>A;</code>在该行的末尾添加文本”;”。</p>
<h2 id="递增数字"><a href="#递增数字" class="headerlink" title="递增数字"></a>递增数字</h2><p>&#x3D;&#x3D;Vim有<code>Ctrl-X</code>和<code>Ctrl-A</code>命令来减少和增加数字&#x3D;&#x3D;。与可视模式一起使用时，可以跨多行递增数字。</p>
<p>如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：</p>
<ul>
<li>将光标移动到 <strong>第二行</strong>的 “1”。</li>
<li>启动逐块可视模式，并向下移动3行(<code>Ctrl-V 3j</code>)。这高亮显示剩余的”1”，现在除了第一行，所有的”1”应该已经高亮。</li>
<li>运行<code>g Ctrl-A</code>。</li>
</ul>
<p>您应该看到以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-5&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>g Ctrl-A</code>在多行上递增数字。 <code>Ctrl-X/Ctrl-A</code>也可以增加字母。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set nrformats+=alpha</span><br></pre></td></tr></table></figure>

<p><code>nrformats</code>选项指示Vim将哪个基数视为<code>Ctrl-A</code>和<code>Ctrl-X</code>递增和递减的“数字”。通过添加<code>alpha</code>，现在将字母字符视为数字。如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>将光标放在第二个”app-a”上。使用与上述相同的技术(<code>Ctrl-V 3j</code> 然后 <code>g Ctrl-A</code>)增加ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-b&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-c&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-d&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-e&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="选择最后一个可视模式区域"><a href="#选择最后一个可视模式区域" class="headerlink" title="选择最后一个可视模式区域"></a>选择最后一个可视模式区域</h2><p>前面章节中我提到了<code>gv</code>可以快速高亮显示上一个可视模式选择的内容。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&lt;    转到上一个可视模式高亮显示的第一个位置（行）(译者注，英文原版中&#x27;&lt;&#x27;前面的符号是`，但这应该是一个错误，应该是单引号&#x27;)</span><br><span class="line">&#x27;&gt;    转到上一个可视模式高亮显示的最后位置（行）</span><br></pre></td></tr></table></figure>

<p>之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：<code>:s/const/let/g</code>。当您这样做时，您应该看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#x27;&lt;,&#x27;&gt;s/const/let/g</span><br></pre></td></tr></table></figure>

<p>您实际上是在使用(<code>&#39;&lt;, &#39;&gt;</code>) 标记作为范围来执行 <code>s/const/let/g</code>命令。这太有趣了！</p>
<p>您随时可以随时编辑这些标记。比如，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#x27;&lt;,$s/const/let/g</span><br></pre></td></tr></table></figure>

<h2 id="从插入模式进入可视模式"><a href="#从插入模式进入可视模式" class="headerlink" title="从插入模式进入可视模式"></a>从插入模式进入可视模式</h2><p>您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-O v</span><br></pre></td></tr></table></figure>

<p>回想一下，在插入模式下运行<code>Ctrl-O</code>可以使您执行普通模式命令。在普通模式命令挂起模式下，运行<code>v</code>进入逐字可视模式。请注意，在屏幕的左下方，它显示为<code>--(insert) VISUAL--</code>。该技巧适用于任何可视模式运算符：<code>v</code>，<code>V</code>，和<code>Ctrl-V</code>。</p>
<h2 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h2><p>Vim具有类似于可视模式的模式，称为<em>选择模式</em>。与可视模式一样，它也具有三种不同的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gh         逐字符选择模式</span><br><span class="line">gH         逐行选择模式</span><br><span class="line">gCtrl-h    逐块选择模式</span><br></pre></td></tr></table></figure>

<p>选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。</p>
<p>在常规编辑器中，高亮显示文本块并键入字母（例如字母”y”）后，它将删除高亮显示的文本并插入字母”y”。如果您使用逐行选择模式(<code>gH</code>)高亮显示一行文本并键入”y”，它将删除高亮显示的文本并插入字母”y”，这与常规文本编辑器非常相似。</p>
<p>将此行为与可视模式进行对比：如果您使用逐行可视模式(<code>V</code>)高亮显示一行文本并键入”y”，则高亮显示的文本不会被删除且被字母”y”代替，而是仅将其复制(yank)。在选择模式中，你不能执行对高亮文本执行普通模式的命令。</p>
<p>我个人从未使用过选择模式，但是很高兴知道它的存在。</p>
<h2 id="以聪明的方式学习可视模式"><a href="#以聪明的方式学习可视模式" class="headerlink" title="以聪明的方式学习可视模式"></a>以聪明的方式学习可视模式</h2><p>可视模式是Vim高亮显示文本的过程。</p>
<p>如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。&#x3D;&#x3D;我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。&#x3D;&#x3D;假设您需要删除一个内部单词(inner word，请回顾前面的文本对象)，如果可以只用三个按键(<code>diw</code>)，为什么要使用四个按键<code>viwd</code>（先<code>v</code>进入可视模式，然后<code>iw</code>高亮一个内部单词，最后<code>d</code>删除）呢？前者更为直接和简洁。当然，有时使用可视模式是合适的，但总的来说，更倾向于直接的方法。</p>
<h1 id="第12章-搜索和替换"><a href="#第12章-搜索和替换" class="headerlink" title="第12章 搜索和替换"></a>第12章 搜索和替换</h1><p>本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您得基于文本的共同模式搜索大量的内容。通过学习如何在搜索和替换中使用正则表达式而不是字面字符串，您将能够快速定位任何文本。</p>
<p>附带说明一下，在本章中，当谈论搜索时，我将主要使用<code>/</code>。您使用<code>/</code>进行的所有操作也可以使用<code>?</code>完成。</p>
<h2 id="智能区分大小写"><a href="#智能区分大小写" class="headerlink" title="智能区分大小写"></a>智能区分大小写</h2><p>尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本”Learn Vim”，则很容易把字母的大小写输错，从而得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项<code>ignorecase</code>闪亮的地方。只需在 vimrc 中添加<code>set ignorecase</code>，所有搜索词就不区分大小写。现在，您不必再执行<code>/Learn Vim</code>了。 <code>/learn vim</code>将起作用。</p>
<p>但是，有时您需要搜索特定大小写的短语。一种方法是用 <code>set noignorecase</code> 关闭<code>ignorecase</code>选项，但是每次需要搜索区分大小写的短语时，都得反复地打开和关闭这个选项。</p>
<p>为避免反复开关<code>ignorecase</code>选项，Vim 有一个<code>smartcase</code>选项。您可以将<code>ignorecase</code>和<code>smartcase</code>选项结合起来，当您输入的搜索词全部是小写时，进行大小写不敏感搜索；而当搜索词 <strong>至少有1个大写字母时</strong>，进行大小写敏感搜索。</p>
<p>在您的 vimrc 中，添加:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set ignorecase smartcase</span><br></pre></td></tr></table></figure>

<p>如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">HELLO</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<ul>
<li><code>/hello</code> 匹配”hello”，”HELLO”和”Hello”。</li>
<li><code>/HELLO</code> 仅匹配”HELLO”。</li>
<li><code>/Hello</code> 仅匹配”Hello”。</li>
</ul>
<p>有一个缺点。因为现在当您执行<code>/hello</code>时，Vim 将进行大小写不敏感搜索,那如果只需要搜索小写字符串怎么办？您可以在搜索词前使用<code>\C</code>模式来告诉 Vim，后续搜索词将区分大小写。如果执行<code>/\Chello</code>，它将严格匹配”hello”，而不是”HELLO”或”Hello”。</p>
<h2 id="一行中的第一个和最后一个字符"><a href="#一行中的第一个和最后一个字符" class="headerlink" title="一行中的第一个和最后一个字符"></a>一行中的第一个和最后一个字符</h2><p>您可以使用<code>^</code>匹配行中的第一个字符，并使用<code>$</code>匹配行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>/^hello</code>来定位第一个”hello”。 ‘^’后面的字符必须是一行中的第一个字符。 要定位最后一个”hello”，请运行<code>/hello$</code>。 ‘$‘ 之前的字符必须是一行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello friend</span><br></pre></td></tr></table></figure>

<p>运行<code>/hello$</code>将匹配不到任何内容，因为”friend”是该行的最后一项，而不是”hello”。</p>
<h2 id="重复搜索"><a href="#重复搜索" class="headerlink" title="重复搜索"></a>重复搜索</h2><p>您可以使用<code>//</code>重复上一个搜索。如果您只是搜索<code>/hello</code>，则运行<code>//</code>等同于运行<code>/hello</code>。此快捷键可以为您节省一些按键操作，尤其是在您刚搜索了一个很长的字符串的情况下。另外，回想一下前面的章节，您还可以使用<code>n</code>和<code>N</code>分别以相同方向和相反方向重复上一次搜索。</p>
<p>如果您想快速回忆起 第<em>n</em>个最近使用的搜索字怎么办？您可以先按<code>/</code>，然后按<code>up</code>&#x2F;<code>down</code>方向键（或<code>Ctrl-N</code>&#x2F;<code>Ctrl-P</code>），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行<code>:history /</code>。</p>
<p>在搜索过程中到达文件末尾时，Vim 会抛出一个错误:<code>&quot;搜索到达底部,未找到匹配项:&#123;your-search&#125;&quot;</code>(<code>&quot;Search hit the BOTTOM without match for: &#123;your-search&#125;&quot;</code>)。有时这个特性能成为一个安全守卫，可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用<code>set wrapscan</code>选项使 Vim 在到达文件末尾时回到文件顶部进行搜索。要关闭此功能，请执行<code>set nowrapscan</code>。</p>
<h2 id="使用候选词搜索"><a href="#使用候选词搜索" class="headerlink" title="使用候选词搜索"></a>使用候选词搜索</h2><p>一次搜索多个单词属于日常操作。 如果您需要搜索”hello vim”或”hola vim”，而不是”salve vim”或”bonjour vim”，则可以使用<code>|</code>或运算符。</p>
<p>给予这样一段文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>

<p>要同时匹配”hello”和”hola”，可以执行<code>/hello\|hola</code>。 您必须使用（<code>\</code>）转义（<code>|</code>）或运算符，否则 Vim 将按字面意义搜索字符串”|”。</p>
<p>如果您不想每次都输入<code>\|</code>，则可以在搜索开始时使用<code>magic</code>语法（<code>\v</code>）:<code>/\vhello|hola</code>。 我不会在本章中详细介绍<code>magic</code>，但是有了<code>\v</code>，您就不必再转义特殊字符了。 要了解有关<code>\v</code>的更多信息，请随时查看<code>:h \v</code>。</p>
<h2 id="设置模式匹配的开始位置和结束位置"><a href="#设置模式匹配的开始位置和结束位置" class="headerlink" title="设置模式匹配的开始位置和结束位置"></a>设置模式匹配的开始位置和结束位置</h2><p>也许您需要搜索的文本是复合词的一部分。如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11vim22</span><br><span class="line">vim22</span><br><span class="line">11vim</span><br><span class="line">vim</span><br></pre></td></tr></table></figure>

<p>如果您仅需要选择以”11”开始、以”22”结束的”vim”，您可以使用<code>\zs</code>（开始匹配）和<code>\ze</code>（结束匹配）运算符。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/11\zsvim\ze22</span><br></pre></td></tr></table></figure>

<p>Vim仍然会匹配整个模式”11vim22”，但是仅高亮显示介于<code>\zs</code>和<code>\ze</code>之间的内容。 另一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foobar</span><br><span class="line">foobaz</span><br></pre></td></tr></table></figure>

<p>如果需要在”foobaz”中搜索”foo”，而不是在”foobar”中搜索，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo\zebaz</span><br></pre></td></tr></table></figure>

<h2 id="搜索字符组"><a href="#搜索字符组" class="headerlink" title="搜索字符组"></a>搜索字符组</h2><p>到目前为止，您所有的搜索字都是字面内容。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符组<code>[ ]</code>。</p>
<p>如果您需要搜索任何数字，则可能不想每一次都输入<code>/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0</code>。相反，请使用<code>/[0-9]</code>来匹配一位数字。 <code>0-9</code>表达式表示 Vim 尝试匹配的数字范围是 0-9，因此，如果要查找 1 到 5 之间的数字，请使用<code>/[1-5]</code>。</p>
<p>数字不是 Vim 可以查找的唯一数据类型。您也可以执行<code>/[a-z]</code>来搜索小写字母，而<code>/[A-Z]</code>来搜索大写字母。</p>
<p>您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行<code>/[0-9a-fA-F]</code>。</p>
<p>要进行否定搜索，可以在字符范围括号内添加<code>^</code>。要搜索非数字，请运行<code>/[^0-9]</code>，Vim会匹配任何字符，只要它不是数字即可。请注意，范&#x3D;&#x3D;围括号内的脱符号（<code>^</code>）与行首位置符号（例如:<code>/^hello</code>）不同&#x3D;&#x3D;。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示”一行中的第一个字符”。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 <code>/^abc</code>匹配行中的第一个”abc”，而<code>/[^abc]</code>匹配除”a”，”b”或”c”以外的任何字符。</p>
<h2 id="搜索重复字符"><a href="#搜索重复字符" class="headerlink" title="搜索重复字符"></a>搜索重复字符</h2><p>如果需要在此文本中搜索两位数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1aa</span><br><span class="line">11a</span><br><span class="line">111</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>/[0-9][0-9]</code>来匹配两位数字字符，但是该方法难以扩展。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个<code>count</code>参数。</p>
<p>您可以将<code>count</code>传递给您的搜索。 它具有以下语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;n,m&#125;</span><br></pre></td></tr></table></figure>

<p>顺便说一句，当在 Vim 中使用它们时，这些<code>count</code>周围的花括号需要被转义。 <code>count</code> 运算符放在您要递增的单个字符之后。</p>
<p>这是<code>count</code>语法的四种不同变体: </p>
<ul>
<li><code>&#123;n&#125;</code>是精确匹配。 <code>/[0-9]\&#123;2\&#125;</code>匹配两个数字:”11”，以及”111”中的”11”。</li>
<li><code>&#123;n,m&#125;</code>是范围匹配。 <code>/[0-9]\&#123;2,3\&#125;</code>匹配 2 到 3 位数字:”11”和”111”。 </li>
<li><code>&#123;,m&#125;</code>是上限匹配。 <code>/[0-9]\&#123;,3\&#125;</code>匹配最多 3 个数字:”1”，”11”和”111”。</li>
<li><code>&#123;n,&#125;</code>是下限匹配。 <code>/[0-9]\&#123;2,\&#125;</code>匹配最少 2 个或多个数字:”11”和”111”。</li>
</ul>
<p>计数参数<code>\&#123;0,\&#125;</code>（零或多个）和<code>\&#123;1,\&#125;</code>（一个或多个）是最常见的搜索模式，Vim 为它们提供了特殊的操作符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）。 如果执行<code>/[0-9]*</code>，功能与<code>/[0-9]\&#123;0,\&#125;</code>相同。 它搜索零个或多个数字，会匹配””，”1”，”123”。 顺便说一句，它也将匹配非数字，例如”a”，因为在技术上，字母”a”中的数字个数为零。 在使用”*“之前，请仔细考虑。 如果执行<code>/[0-9]\+</code>，则与<code>/[0-9]\&#123;1,\&#125;</code>相同。 它搜索一个或多个数字，将匹配”1”和”12”。</p>
<h2 id="预定义的字符组"><a href="#预定义的字符组" class="headerlink" title="预定义的字符组"></a>预定义的字符组</h2><p>Vim 为常见字符组（例如数字和字母）提供了简写。 我不会在这里逐一介绍，但可以在<code>:h /character-classes</code>中找到完整列表。 下面是有用的部分:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d    数字[0-9]</span><br><span class="line">\D    非数字[^ 0-9]</span><br><span class="line">\s    空格字符（空格和制表符）</span><br><span class="line">\S    非空白字符（除空格和制表符外的所有字符）</span><br><span class="line">\w    单词字符[0-9A-Za-z_]</span><br><span class="line">\l    小写字母[a-z]</span><br><span class="line">\u    大写字符[A-Z]</span><br></pre></td></tr></table></figure>

<p>您可以像使用普通字符组一样使用它们。 要搜索任何一位数字，可以使用<code>/\d</code>以获得更简洁的语法，而不使用<code>/[0-9]</code>。</p>
<h2 id="搜索示例：在一对相似字符之间捕获文本"><a href="#搜索示例：在一对相似字符之间捕获文本" class="headerlink" title="搜索示例：在一对相似字符之间捕获文本"></a>搜索示例：在一对相似字符之间捕获文本</h2><p>如果要搜索由双引号引起来的短语:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Vim is awesome!&quot;</span><br></pre></td></tr></table></figure>

<p>运行这个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`/&quot;[^&quot;]\+&quot;`</span><br></pre></td></tr></table></figure>

<p>让我们分解一下:</p>
<ul>
<li><code>&quot;</code> 是字面双引号。它匹配第一个双引号。</li>
<li><code>[^&quot;]</code> 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。</li>
<li><code>\+</code>表示一个或多个。因为它的前面是<code>[^&quot;]</code>，因此 Vim 查找一个或多个不是双引号的字符。</li>
<li><code>&quot;</code> 是字面双引号。它与右双引号匹配。</li>
</ul>
<p>当看到第一个<code>&quot;</code>时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个<code>&quot;</code>模式并停止模式捕获。同时，两个双引号之间的所有非双引号字符都被<code>[^&quot;]\+</code> 模式捕获，在这个例子中是短语”Vim is awesome!”。这是一个通用模式（其实就是正则表达式）用于捕获 <strong>由一对类似的定界符包围的短语</strong>。</p>
<ul>
<li>要捕获被单引号包围的短语，你可以使用<code>/&#39;[^&#39;]\+&#39;</code></li>
<li>要捕获为0包围的短语，你可以使用<code>/0[^0]\+0</code></li>
</ul>
<h2 id="搜索示例：捕获电话号码"><a href="#搜索示例：捕获电话号码" class="headerlink" title="搜索示例：捕获电话号码"></a>搜索示例：捕获电话号码</h2><p>如果要匹配以连字符(<code>-</code>)分隔的美国电话号码，例如<code>123-456-7890</code>，则可以使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\d\&#123;3\&#125;-\d\&#123;3\&#125;-\d\&#123;4\&#125;</span><br></pre></td></tr></table></figure>

<p>美国电话号码的组成是：首先是三位数字，其后是另外三位数字，最后是另外四位数字。 让我们分解一下:</p>
<ul>
<li><code>\d\&#123;3\&#125;</code>与精确重复三次的数字匹配</li>
<li><code>-</code>是字面的连字符</li>
</ul>
<p>为&#x3D;&#x3D;避免转义，可使用<code>\v</code>&#x3D;&#x3D;:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;</span><br></pre></td></tr></table></figure>

<p>此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。</p>
<p>这涵盖了本章的搜索部分。 现在开始讲替换。</p>
<h2 id="基本替换"><a href="#基本替换" class="headerlink" title="基本替换"></a>基本替换</h2><p>Vim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/&#123;old-pattern&#125;/&#123;new-pattern&#125;/</span><br></pre></td></tr></table></figure>

<p>让我们从一个基本用法开始。 如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is good</span><br></pre></td></tr></table></figure>

<p>让我们用”awesome”代替”good”，因为 Vim 很棒。 运行<code>:s/good/awesome/.</code>您应该看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br></pre></td></tr></table></figure>

<h2 id="重复最后一次替换"><a href="#重复最后一次替换" class="headerlink" title="重复最后一次替换"></a>重复最后一次替换</h2><p>您可以使用普通模式命令<code>&amp;</code>或运行<code>:s</code>来重复最后一个替代命令。 如果您刚刚运行<code>:s/good/awesome/</code>，则运行<code>&amp;</code>或<code>:s</code>将会重复执行。</p>
<p>另外，在本章前面，我提到您可以使用<code>//</code>来重复先前的搜索模式。 此技巧可用于替代命令。 如果<code>/good</code>是最近被替换的单词，那么将第一个替换模式参数留为空白，例如在<code>:s//awesome/</code>中，则与运行<code>:s/good/awesome/</code>相同。</p>
<h2 id="替换范围"><a href="#替换范围" class="headerlink" title="替换范围"></a>替换范围</h2><p>就像许多 Ex 命令一样，您可以将范围参数传递给替换命令。 语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]s/old/new/</span><br></pre></td></tr></table></figure>

<p>如果您有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>

<p>要将第3行到第5行中的”let”替换为”const”，您可以执行以下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3,5s/let/const/</span><br></pre></td></tr></table></figure>

<p>下面是一些你可以使用的范围参数的变体:</p>
<ul>
<li><code>:,3s/let/const/</code> - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换到第 3 行。</li>
<li><code>:1,s/let/const/</code> - 如果逗号后没有给出任何内容，它也代表当前行。 从第 1 行替换到当前行。</li>
<li><code>:3s/let/const/</code> - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。</li>
</ul>
<p>在 Vim 中，<code>%</code>通常表示整个文件。 如果运行<code>:%s/let/const/</code>，它将在所有行上进行替换。请记住这个范围参数语法，在后面章节中很多命令行命令都遵循这个语法。</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>接下来的几节将介绍基本的正则表达式。 丰富的模式知识对于掌握替换命令至关重要。</p>
<p>如果您具有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>

<p>要在数字周围添加一对双引号:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\d/&quot;\0&quot;/</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>让我们分解一下命令:</p>
<ul>
<li><code>:%s</code> 定位整个文件以执行替换。</li>
<li><code>\d</code> 是 Vim 的预定义数字范围简写(类似使用<code>[0-9]</code>)。</li>
<li><code>&quot;\0&quot;</code> 双引号是双引号的字面值。 <code>\0</code>是一个特殊字符，代表”整个匹配的模式”。 此处匹配的模式是单个数字<code>\d</code>。</li>
</ul>
<p>另外，<code>&amp;</code>也同样代表”整个匹配的模式”，就像<code>\0</code>一样。 <code>:s/\d/&quot;&amp;&quot;/</code>也可以。</p>
<p>让我们考虑另一个例子。 给出以下表达式，您需要将所有的”let”和变量名交换位置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one let = &quot;1&quot;;</span><br><span class="line">two let = &quot;2&quot;;</span><br><span class="line">three let = &quot;3&quot;;</span><br><span class="line">four let = &quot;4&quot;;</span><br><span class="line">five let = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>为此，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\(\w\+\) \(\w\+\)/\2 \1/</span><br></pre></td></tr></table></figure>

<p>上面的命令包含太多的反斜杠，很难阅读。 使用<code>\v</code>运算符更方便:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\w+) (\w+)/\2 \1/</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>太好了！ 让我们分解该命令:</p>
<ul>
<li><code>:%s</code> 定位文件中的所有行以执行替换操作</li>
<li><code>(\w+) (\w+)</code>对模式进行分组。<code>\w</code>是 Vim 预定义的单词字符范围简写(<code>[0-9A-Za-z_]</code>)之一。 包围<code>\w</code>的<code>()</code>将匹配的单词字符进行分组。 请注意两个分组之间的空间。 <code>(\w+) (\w+)</code> 捕获两个分组。 在第一行上，第一组捕获”let”，第二组捕获”one”。(英文版中，作者写成了：第一组捕获”one”，第二组捕获”two”，可能是作者不小心的错误)。</li>
<li><code>\2 \1</code> 以相反的顺序返回捕获的组。 <code>\2</code>包含捕获的字符串”let”，而<code>\1</code>包含字符串”one”。 使<code>\2 \1</code>返回字符串”let one”。</li>
</ul>
<p>回想一下，<code>\0</code>代表整个匹配的模式。 您可以&#x3D;&#x3D;使用<code>( )</code>将匹配的字符串分成较小的组&#x3D;&#x3D;。 每个组都由<code>\1</code>, <code>\2</code>, <code>\3</code>等表示。</p>
<p>让我们再举一个例子来巩固这一匹配分组的概念。 如果您有以下数字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure>

<p>要颠倒顺序，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d)(\d)(\d)/\3\2\1/</span><br></pre></td></tr></table></figure>

<p>结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">321</span><br><span class="line">654</span><br><span class="line">987</span><br></pre></td></tr></table></figure>

<p>每个<code>(\d)</code>都匹配一个数字并创建一个分组。 在第一行上，第一个<code>(\d)</code>的值为”1”，第二个<code>(\d)</code>的值为”2”，第三个<code>(\d)</code>的值为”3”。 它们存储在变量<code>\1</code>，<code>\2</code>和<code>\3</code>中。 在替换的后半部分，新模式<code>\3\2\1</code>在第一行上产生”321”值。</p>
<p>相反，如果您运行下面的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d\d)(\d)/\2\1/</span><br></pre></td></tr></table></figure>
<p>您将获得不同的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">312</span><br><span class="line">645</span><br><span class="line">978</span><br></pre></td></tr></table></figure>

<p>这是因为您现在只有两个组。 被<code>(\d\d)</code>捕获的第一组存储在<code>\1</code>内，其值为”12”。 由<code>(\d)</code>捕获的第二组存储在<code>\2</code>内部，其值为”3”。 然后，<code>\2\1</code>返回”312”。</p>
<h2 id="替换标志"><a href="#替换标志" class="headerlink" title="替换标志"></a>替换标志</h2><p>如果您有以下句子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>

<p>要将所有 pancakes 替换为 donut，您不能只运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut</span><br></pre></td></tr></table></figure>

<p>上面的命令将仅替换第一个匹配项，返回的结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate donut, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>

<p>有两种解决方法。 一，您可以再运行两次替代命令。 二，您可以向其传递全局(<code>g</code>)标志来替换一行中的所有匹配项。</p>
<p>让我们谈谈全局标志。 运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut/g</span><br></pre></td></tr></table></figure>

<p>Vim 迅速将所有”pancake”替换为”donut”。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;    重用上一个替代命令中的标志。 必须作为第一个标志传递。</span><br><span class="line">g    替换行中的所有匹配项。</span><br><span class="line">c    要求替代确认。</span><br><span class="line">e    防止替换失败时显示错误消息。</span><br><span class="line">i    执行不区分大小写的替换</span><br><span class="line">I    执行区分大小写的替换</span><br></pre></td></tr></table></figure>

<p>我上面没有列出更多标志。 要了解所有标志，请查看<code>:h s_flags</code>。</p>
<p>顺便说一句，重复替换命令（<code>&amp;</code>和<code>:s</code>）不保留标志。 运行<code>&amp;</code>只会重复<code>:s/pancake/donut/</code>而没有<code>g</code>。 要使用所有标志快速重复最后一个替代命令，请运行<code>:&amp;&amp;</code>。</p>
<h2 id="更改定界符"><a href="#更改定界符" class="headerlink" title="更改定界符"></a>更改定界符</h2><p>如果您需要用长路径替换 URL:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mysite.com/a/b/c/d/e</span><br></pre></td></tr></table></figure>

<p>要用单词”hello”代替它，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/</span><br></pre></td></tr></table></figure>

<p>但是，很难说出哪些正斜杠（<code>/</code>）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或<code>&quot;</code>，<code>|</code>和<code>\</code>之外的字符）来更改定界符。让我们将它们替换为<code>+</code>。上面的替换命令可以重写为 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+</span><br></pre></td></tr></table></figure>

<p>现在，更容易看到分隔符在哪里。</p>
<h2 id="特殊替换"><a href="#特殊替换" class="headerlink" title="特殊替换"></a>特殊替换</h2><p>您还可以修改要替换的文本的大小写。 给出以下表达式，您的任务是将所有变量名比如 “one”, “two”, “three”等，改成大写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/\v(\w+) (\w+)/\1 \U\2/</span><br></pre></td></tr></table></figure>

<p>你会得到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ONE = &quot;1&quot;;</span><br><span class="line">let TWO = &quot;2&quot;;</span><br><span class="line">let THREE = &quot;3&quot;;</span><br><span class="line">let FOUR = &quot;4&quot;;</span><br><span class="line">let FIVE = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>这是该命令的细分:</p>
<ul>
<li><code>(\w+) (\w+)</code>捕获前两个匹配的分组，例如”let”和”one”。</li>
<li><code>\1</code>返回第一个组的值”let”</li>
<li><code>\U\2</code>大写(<code>\U</code>)第二组(<code>\2</code>)。</li>
</ul>
<p>该命令的窍门是表达式<code>\U\2</code>。<code>\U</code>将后面跟着的字符变为大写。</p>
<p>让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is the greatest text editor in the whole galaxy</span><br></pre></td></tr></table></figure>

<p>您可以运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/\&lt;./\U&amp;/g</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vim Is The Greatest Text Editor In The Whole Galaxy</span><br></pre></td></tr></table></figure>

<p>细目如下:</p>
<ul>
<li><code>:s</code> 替换当前行</li>
<li><code>\&lt;.</code> 由两部分组成:<code>\&lt;</code>匹配单词的开头，<code>.</code>匹配任何字符。 <code>\&lt;</code>运算符使后面跟着的字符表示单词的第一个字符。 由于<code>.</code>是下一个字符，因此它将匹配任意单词的第一个字符。</li>
<li><code>\U&amp;</code> 将后续符号子序列<code>&amp;</code>大写。 回想一下，<code>&amp;</code>（或<code>\0</code>）代表整个匹配。 这里它匹配单词的第一个字符。</li>
<li><code>g</code>全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。</li>
</ul>
<p>要了解替换的特殊替换符号（如<code>\u</code>和<code>\U</code>）的更多信息，请查看<code>:h sub-replace-special</code>。</p>
<h2 id="候选模式"><a href="#候选模式" class="headerlink" title="候选模式"></a>候选模式</h2><p>有时您需要同时匹配多个模式。 如果您有以下问候:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>

<p>您仅需在包含单词”hello”或”hola”的行上用”friend”代替”vim”。回想一想本章前面的知识点，你可以使用<code>|</code> 来分隔可选的模式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(hello|hola) vim)/\1 friend/g</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello friend</span><br><span class="line">hola friend</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>

<p>这是细分:</p>
<ul>
<li><code>%s</code> 在文件的每一行上运行替代命令。</li>
<li><code>(hello|hola)</code> 匹配*“hello”或”hola”，并将其视为一个组。</li>
<li><code>vim</code> 是字面意思”vim”。</li>
<li><code>\1</code> 是第一个匹配组，它是文本”hello”或”hola”。</li>
<li><code>friend</code> 是字面的“朋友”。</li>
</ul>
<h2 id="指定替换模式的开始位置和结束位置"><a href="#指定替换模式的开始位置和结束位置" class="headerlink" title="指定替换模式的开始位置和结束位置"></a>指定替换模式的开始位置和结束位置</h2><p>回想一下，您可以使用<code>\zs</code>和<code>\ze</code>来指定一个匹配的开始位置和结束位置。这个技术在替换操作中同样有效，如果你有以下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake</span><br><span class="line">strawberry sweetcake</span><br><span class="line">blueberry hotcake</span><br></pre></td></tr></table></figure>

<p>要想将”hotcake”中的”cake”替换为”dog”，得到”hotdog”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/hot\zscake/dog/g</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake</span><br><span class="line">strawberry sweetcake</span><br><span class="line">blueberry hotdog</span><br></pre></td></tr></table></figure>

<h2 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h2><p>您可以使用下面技巧，在某行中替换第n个匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.</span><br></pre></td></tr></table></figure>

<p>要想将第3个”Mississippi”替换为 “Arkansas”，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/\v(.&#123;-&#125;\zsMississippi)&#123;3&#125;/Arkansas/g</span><br></pre></td></tr></table></figure>

<p>命令分解：</p>
<ul>
<li><code>:s/</code> 替换命令。</li>
<li><code>\v</code> 魔术关键字，使您不必转义特殊字符。</li>
<li><code>.</code> 匹配任意单个字符。</li>
<li><code>&#123;-&#125;</code> 表示使用非贪婪模式匹配前面的0个或多个字符。</li>
<li><code>\zsMississippi</code> 使得从”Mississippi”开始捕获匹配。</li>
<li><code>(...)&#123;3&#125;</code> 查找第3个匹配</li>
</ul>
<p>在本章前面的内容中，你已经看到过<code>&#123;3&#125;</code>这样的语法。在本例中，&#x3D;&#x3D;<code>&#123;3&#125;</code>将精确匹配第3个匹配&#x3D;&#x3D;。这里的新技巧是<code>&#123;-&#125;</code>。它表示进行非贪婪匹配。它会找到符合给定模式的&#x3D;&#x3D;最短的匹配&#x3D;&#x3D;。在本例中，<code>(.&#123;-&#125;Mississippi)</code>匹配以任意字符开始、数量最少的”Mississippi”。对比<code>(.*Mississippi)</code>，后者会找到符合给定模式的最长匹配。</p>
<p>如果您使用<code>(.&#123;-&#125;Mississippi)</code>，你会得到5个匹配：”One Mississippi”, “Two Mississippi”,等。如果您使用<code>(.*Mississippi)</code>，您只会得到1个匹配：最后一个 “Mississippi”。<code>*</code>表示贪婪匹配，而<code>&#123;-&#125;</code>表示非贪婪匹配。要想了解更多，可以查看 <code>:h /\&#123;-</code> 和 <code>:h non-greedy</code>。</p>
<p>让我们看一个简单的例子。如果您有以下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc1de1</span><br></pre></td></tr></table></figure>

<p>用贪婪模式匹配 “abc1de1” ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a.*1</span><br></pre></td></tr></table></figure>

<p>用非贪婪模式匹配 “abc1”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a.\&#123;-&#125;1</span><br></pre></td></tr></table></figure>

<p>因此，如果您需要将最长的匹配转为大写（贪婪模式），运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/a.*1/\U&amp;/g</span><br></pre></td></tr></table></figure>

<p>会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC1DE1</span><br></pre></td></tr></table></figure>

<p>如果您需要将最短的匹配转为大写（非贪婪模式），运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/a.\&#123;-&#125;1/\U&amp;/g</span><br></pre></td></tr></table></figure>

<p>会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC1de1</span><br></pre></td></tr></table></figure>

<p>如果您是第一次接触贪婪模式与非贪婪模式这两个概念，可能会把你绕晕。围绕不同的组合去实验，知道您明白这两个概念。</p>
<h2 id="跨多个文件替换"><a href="#跨多个文件替换" class="headerlink" title="跨多个文件替换"></a>跨多个文件替换</h2><p>最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: <code>food.txt</code> 和 <code>animal.txt</code>.</p>
<p><code>food.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">corn dog</span><br><span class="line">hot dog</span><br><span class="line">chili dog</span><br></pre></td></tr></table></figure>

<p><code>animal.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">large dog</span><br><span class="line">medium dog</span><br><span class="line">small dog</span><br></pre></td></tr></table></figure>

<p>假设您的目录结构如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├ food.txt</span><br><span class="line">├ animal.txt</span><br></pre></td></tr></table></figure>

<p>首先，用<code>:args</code>同时捕获”food.txt”和”animal.txt”到参数列表中。回顾前面的章节，<code>:args</code>可用于创建文件名列表。在 Vim 中有几种方法可以做到这一点，其中一种方法是在Vim内部运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args *.txt                  捕获当前位置的所有txt文件</span><br></pre></td></tr></table></figure>

<p>测试一下，当您运行<code>:args</code>时，您应该会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[food.txt] animal.txt</span><br></pre></td></tr></table></figure>

<p>现在，所有的相关文件都已经存储在参数列表中，您可以用 <code>:argdo</code> 命令跨多文件替换，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo %s/dog/chicken/</span><br></pre></td></tr></table></figure>

<p>这条命令对所有<code>:args</code>列表中的文件执行替换操作。最终，存储修改的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo update</span><br></pre></td></tr></table></figure>

<p><code>:args</code> 和 <code>:argdo</code> 是两个有用的工具，用于跨多文件执行命令行命令。可以用其他命令结合尝试一下！</p>
<h2 id="用宏跨多个文件替换"><a href="#用宏跨多个文件替换" class="headerlink" title="用宏跨多个文件替换"></a>用宏跨多个文件替换</h2><p>另外，您也可以用宏跨多个文件运行替代命令。执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:args *.txt</span><br><span class="line">qq</span><br><span class="line">:%s/dog/chicken/g</span><br><span class="line">:wnext</span><br><span class="line">q</span><br><span class="line">99@q</span><br></pre></td></tr></table></figure>

<p>以下是步骤的细分:</p>
<ul>
<li><code>:args *.txt</code> 会将相关文件列出到<code>:args</code>列表中。</li>
<li><code>qq</code> 启动”q”寄存器中的宏。</li>
<li><code>:%s/dog/chicken/g</code>在当前文件的所有行上用”chicken”替换”dog”。</li>
<li><code>:wnext</code> 写入（保存）文件，然后转到<code>args</code>列表中的下一个文件。就像同时运行<code>:w</code>和<code>:next</code>一样。</li>
<li><code>q</code> 停止宏录制。</li>
<li><code>99@q</code> 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。</li>
</ul>
<h2 id="以聪明的方式学习搜索和替换"><a href="#以聪明的方式学习搜索和替换" class="headerlink" title="以聪明的方式学习搜索和替换"></a>以聪明的方式学习搜索和替换</h2><p>良好的搜索能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。要想掌握正则表达式，您必须在实践中去不断地使用它。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。</p>
<p>一种提高模式匹配技能的好方法是，每当您需要搜索一个模式串时（例如”hello 123”），不要直接查询文字的字面值(<code>/hello 123</code>)，去尝试使用模式串来搜索它(比如<code>/\v(\l+) (\d+)</code>)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。</p>
<p>既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><ul>
<li>使用候选词搜索</li>
<li><code>&#123;n,m&#125;</code></li>
<li>特殊的操作符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）</li>
</ul>
<h3 id="和-g"><a href="#和-g" class="headerlink" title="% 和 g"></a>% 和 g</h3><ul>
<li><p>将文档每行&#x3D;&#x3D;第一个匹配&#x3D;&#x3D;上的 <code>&lt;old string&gt;</code> 替换为 <code>&lt;new string&gt;</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/&lt;old string&gt;/&lt;new string&gt;/</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文档中&#x3D;&#x3D;所有&#x3D;&#x3D;的 <code>&lt;old string&gt;</code> 替换为 <code>&lt;new string&gt;</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/&lt;old string&gt;/&lt;new string&gt;/g</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="设置tab位4个空格"><a href="#设置tab位4个空格" class="headerlink" title="设置tab位4个空格"></a>设置tab位4个空格</h1><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>如果要修改全局Vim的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vim/vimrc1</span><br></pre></td></tr></table></figure>

<p>但是不建议这么做，可以只修改当前用户的Vim配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc1</span><br></pre></td></tr></table></figure>

<p>在配置文件中添加以下参数</p>
<ol>
<li><p>第一种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set sw=412</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set expandtab</span><br><span class="line">set autoindent123</span><br></pre></td></tr></table></figure></li>
</ol>
<p>建议使用第二种，具有兼容性</p>
<h2 id="修改已保存文件"><a href="#修改已保存文件" class="headerlink" title="修改已保存文件"></a>修改已保存文件</h2><h3 id="Tab替换为空格"><a href="#Tab替换为空格" class="headerlink" title="Tab替换为空格"></a>Tab替换为空格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set expandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>

<h3 id="空格替换为Tab"><a href="#空格替换为Tab" class="headerlink" title="空格替换为Tab"></a>空格替换为Tab</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set noexpandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>

<p>加感叹号<code>!</code>是用于处理非空白字符之后的Tab，即所有的Tab</p>
<p>若不加感叹号<code>!</code>，则只处理行首的Tab修改配置</p>
<hr>
<p>如果要修改全局Vim的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vim/vimrc1</span><br></pre></td></tr></table></figure>

<p>但是不建议这么做，可以只修改当前用户的Vim配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc1</span><br></pre></td></tr></table></figure>

<p>在配置文件中添加以下参数</p>
<ol>
<li><p>第一种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set sw=412</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set expandtab</span><br><span class="line">set autoindent123</span><br></pre></td></tr></table></figure></li>
</ol>
<p>建议使用第二种，具有兼容性</p>
<h2 id="修改已保存文件-1"><a href="#修改已保存文件-1" class="headerlink" title="修改已保存文件"></a>修改已保存文件</h2><h3 id="Tab替换为空格-1"><a href="#Tab替换为空格-1" class="headerlink" title="Tab替换为空格"></a>Tab替换为空格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set expandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>



<h3 id="空格替换为Tab-1"><a href="#空格替换为Tab-1" class="headerlink" title="空格替换为Tab"></a>空格替换为Tab</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set noexpandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>

<p>加感叹号<code>!</code>是用于处理非空白字符之后的Tab，即所有的Tab</p>
<p>若不加感叹号<code>!</code>，则只处理行首的Tab</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Qeuroal
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://qeuroal.top/2023/06/04/153/" title="153. VIM 从入门到放弃">http://qeuroal.top/2023/06/04/153/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/software/" rel="tag"><i class="fa fa-tag"></i> software</a>
              <a href="/tags/linux/" rel="tag"><i class="fa fa-tag"></i> linux</a>
              <a href="/tags/vim/" rel="tag"><i class="fa fa-tag"></i> vim</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/03/152/" rel="prev" title="152. LaTeX">
                  <i class="fa fa-angle-left"></i> 152. LaTeX
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/06/05/154/" rel="next" title="154. VIM 从放弃到偶尔">
                  154. VIM 从放弃到偶尔 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Qeuroal</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Qeuroal" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
