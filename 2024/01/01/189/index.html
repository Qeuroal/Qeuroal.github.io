<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qeuroal.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="不知道命令属于哪一类, 但是常用且重要">
<meta property="og:type" content="article">
<meta property="og:title" content="189. Linux中的命令之大杂烩">
<meta property="og:url" content="http://qeuroal.top/2024/01/01/189/index.html">
<meta property="og:site_name" content="Qeuroal&#39;s Blog">
<meta property="og:description" content="不知道命令属于哪一类, 但是常用且重要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240110083648475.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240110083427436-4846867.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240110083427436.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240110083427435.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240117080740402.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240117080740381.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240117080740436-5450060.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240117080740369.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240117080740436.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240117080740371.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640.jpeg">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240101130239775.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240101130254698.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240101130311317.jpeg">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200509.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200583.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200615.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200592.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200574.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200590.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200567.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200686.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200630.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200655.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115083200656.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240116074005713.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240116074005736.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240116074005706.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240116074005738.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240116074005759.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240116074005721.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240110080049997.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115075016976.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/01/189/640-20240115075016939.png">
<meta property="article:published_time" content="2024-01-01T00:00:00.000Z">
<meta property="article:modified_time" content="2025-12-08T06:36:58.590Z">
<meta property="article:author" content="Qeuroal">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qeuroal.top/2024/01/01/189/640-20240110083648475.png">


<link rel="canonical" href="http://qeuroal.top/2024/01/01/189/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qeuroal.top/2024/01/01/189/","path":"2024/01/01/189/","title":"189. Linux中的命令之大杂烩"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>189. Linux中的命令之大杂烩 | Qeuroal's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qeuroal's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">静幽正治</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#history"><span class="nav-number">1.</span> <span class="nav-text">history</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#history-101"><span class="nav-number">1.1.</span> <span class="nav-text">history 101</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-history"><span class="nav-number">1.2.</span> <span class="nav-text">查找 history</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%92%8C%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="nav-number">1.3.</span> <span class="nav-text">修改和执行命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4-history"><span class="nav-number">1.4.</span> <span class="nav-text">删除 history</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">1.5.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shell%E4%B8%AD2-1%E7%9A%84%E5%90%AB%E4%B9%89%E8%A7%A3%E9%87%8A"><span class="nav-number">2.</span> <span class="nav-text">shell中2&gt;&amp;1的含义解释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%8B1%E5%92%8C2%E5%9C%A8Linux%E4%B8%AD%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.</span> <span class="nav-text">首先了解下1和2在Linux中代表什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E2-1%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">关于2&gt;&amp;1的含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%882-1%E8%A6%81%E6%94%BE%E5%9C%A8%E5%90%8E%E9%9D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">为什么2&gt;&amp;1要放在后面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E6%AC%A1%E9%83%BD%E5%86%99%E2%80%9D-log2-1%E2%80%9D%E5%A4%AA%E9%BA%BB%E7%83%A6%EF%BC%8C%E8%83%BD%E7%AE%80%E5%86%99%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">每次都写”&gt;log2&gt;&amp;1”太麻烦，能简写吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E9%94%99%E8%AF%AF%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.</span> <span class="nav-text">输入、输出和错误重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stdin-stdout-%E5%92%8C-stderr"><span class="nav-number">3.1.</span> <span class="nav-text">stdin, stdout 和 stderr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.2.</span> <span class="nav-text">输出重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%98%AF%E9%A2%84%E5%85%88%E5%88%9B%E5%BB%BA%E7%9A%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">输出文件是预先创建的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%A0%E9%99%A4"><span class="nav-number">3.2.2.</span> <span class="nav-text">追加而不是删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.3.</span> <span class="nav-text">管道重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8Cstdout-stdin-%E6%98%AF%E4%B8%80%E5%9D%97%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">3.4.</span> <span class="nav-text">请注意，stdout&#x2F;stdin 是一块数据，而不是文件名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.5.</span> <span class="nav-text">输入重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.6.</span> <span class="nav-text">合并重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.7.</span> <span class="nav-text">错误重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stderr-%E9%87%8D%E5%AE%9A%E5%90%91%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.8.</span> <span class="nav-text">stderr 重定向示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E6%9D%A5%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="nav-number">3.9.</span> <span class="nav-text">我们来总结一下</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#find"><span class="nav-number">4.</span> <span class="nav-text">find</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">4.2.</span> <span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">4.3.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec"><span class="nav-number">4.4.</span> <span class="nav-text">exec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exec-%E4%B8%8E-find-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">4.4.1.</span> <span class="nav-text">exec 与 find 命令一起使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-%E5%92%8C-exec-%E5%91%BD%E4%BB%A4%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90"><span class="nav-number">4.4.2.</span> <span class="nav-text">find 和 exec 命令一起使用的一些例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">4.4.3.</span> <span class="nav-text">查找和显示文件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%B9%B6%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6"><span class="nav-number">4.4.4.</span> <span class="nav-text">查找并重命名文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%B9%B6%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.4.5.</span> <span class="nav-text">收集并保存文件的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E5%8F%82%E6%95%B0%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">4.4.6.</span> <span class="nav-text">使用特定参数删除文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E5%B7%A5%E5%85%B7%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">4.4.7.</span> <span class="nav-text">使用特定的工具执行操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">4.4.8.</span> <span class="nav-text">更改文件和目录的所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-number">4.4.9.</span> <span class="nav-text">更改文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E6%94%B6%E9%9B%86md5sum"><span class="nav-number">4.4.10.</span> <span class="nav-text">为每个文件收集md5sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-exec-%E4%B8%8E-grep-%E5%91%BD%E4%BB%A4%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">4.4.11.</span> <span class="nav-text">将 exec 与 grep 命令组合使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-exec-%E5%91%BD%E4%BB%A4"><span class="nav-number">4.4.12.</span> <span class="nav-text">使用多个 exec 命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%A1%E9%81%93pipe"><span class="nav-number">5.</span> <span class="nav-text">管道pipe</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%EF%BC%9A%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="nav-number">5.1.</span> <span class="nav-text">Linux 中的管道：总体思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%B0%86%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E4%BD%9C%E4%B8%BA%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">管道将标准输出重定向到标准输入，但不是作为命令参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">Linux 中的管道类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">5.4.</span> <span class="nav-text">匿名管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">5.5.</span> <span class="nav-text">命名管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E4%B8%8D%E4%BC%9A%E5%8D%A0%E7%94%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E7%9A%84%E4%BB%BB%E4%BD%95%E5%86%85%E5%AD%98%E3%80%82"><span class="nav-number">5.6.</span> <span class="nav-text">命名管道不会占用磁盘上的任何内存。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E7%9C%81-IO"><span class="nav-number">5.7.</span> <span class="nav-text">节省 IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">5.8.</span> <span class="nav-text">两个不同进程之间的通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%83%E4%BD%8E%E5%B1%82%E6%AC%A1%E7%9A%84%E7%AE%A1%E9%81%93%E7%90%86%E8%A7%A3%EF%BC%88%E9%92%88%E5%AF%B9%E9%AB%98%E7%BA%A7%E7%94%A8%E6%88%B7%E5%92%8C%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%89"><span class="nav-number">5.9.</span> <span class="nav-text">较低层次的管道理解（针对高级用户和开发人员）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#xargs"><span class="nav-number">6.</span> <span class="nav-text">xargs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-xargs-%E5%91%BD%E4%BB%A4"><span class="nav-number">6.1.</span> <span class="nav-text">什么是 xargs 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8-xargs-%E5%91%BD%E4%BB%A4"><span class="nav-number">6.2.</span> <span class="nav-text">怎样使用 xargs 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xargs-%E5%92%8C-find%EF%BC%9A%E4%B8%BA%E5%BD%BC%E6%AD%A4%E8%80%8C%E5%AD%98%E5%9C%A8"><span class="nav-number">6.3.</span> <span class="nav-text">xargs 和 find：为彼此而存在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E5%B8%A6%E6%9C%89%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.4.</span> <span class="nav-text">处理文件名中带有空格的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">6.5.</span> <span class="nav-text">查看正在执行的命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%BC%BA%E5%88%B6-xargs-%E6%8F%90%E7%A4%BA%E7%A1%AE%E8%AE%A4"><span class="nav-number">6.6.</span> <span class="nav-text">在运行命令之前，强制 xargs 提示确认</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.7.</span> <span class="nav-text">结合占位符的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8xargs%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="nav-number">6.8.</span> <span class="nav-text">使用xargs运行多个命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="nav-number">7.</span> <span class="nav-text">单引号与双引号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="nav-number">7.1.</span> <span class="nav-text">单引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E6%89%80%E6%9C%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="nav-number">7.2.</span> <span class="nav-text">忽略所有特殊字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="nav-number">7.3.</span> <span class="nav-text">双引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E6%96%9C%E6%9D%A0"><span class="nav-number">7.4.</span> <span class="nav-text">反斜杠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%8F%8D%E6%96%9C%E6%9D%A0%E8%BD%AC%E4%B9%89%E6%8D%A2%E8%A1%8C%E7%AC%A6"><span class="nav-number">7.5.</span> <span class="nav-text">用反斜杠转义换行符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%86%85%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A0"><span class="nav-number">7.6.</span> <span class="nav-text">双引号内的反斜杠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%BC%95%E5%8F%B7"><span class="nav-number">7.7.</span> <span class="nav-text">反引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%BC%95%E5%8F%B7%E4%B8%8D%E5%9C%A8%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8"><span class="nav-number">7.8.</span> <span class="nav-text">反引号不在建议使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">8.</span> <span class="nav-text">环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">8.1.</span> <span class="nav-text">什么是环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">8.2.</span> <span class="nav-text">打印环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-printenv-%E5%91%BD%E4%BB%A4"><span class="nav-number">8.2.1.</span> <span class="nav-text">使用 printenv 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-echo-%E5%91%BD%E4%BB%A4"><span class="nav-number">8.2.2.</span> <span class="nav-text">使用 echo 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-env-%E5%91%BD%E4%BB%A4"><span class="nav-number">8.2.3.</span> <span class="nav-text">使用 env 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-declare-%E5%91%BD%E4%BB%A4"><span class="nav-number">8.2.4.</span> <span class="nav-text">使用 declare 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-set-%E5%91%BD%E4%BB%A4"><span class="nav-number">8.2.5.</span> <span class="nav-text">使用 set 命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-envsubst-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">8.3.</span> <span class="nav-text">使用 envsubst 命令替换环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6"><span class="nav-number">8.3.1.</span> <span class="nav-text">将输出重定向到特定文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5-shell-%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9B%BF%E6%8D%A2-envsubst-%E5%91%BD%E4%BB%A4%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E5%8F%98%E9%87%8F"><span class="nav-number">8.3.2.</span> <span class="nav-text">以 shell 的方式替换 envsubst 命令中的特定变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PATH%E5%8F%98%E9%87%8F"><span class="nav-number">8.4.</span> <span class="nav-text">PATH变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-PATH"><span class="nav-number">8.4.1.</span> <span class="nav-text">查看 PATH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%B4%E6%97%B6-PATH-%E5%8F%98%E9%87%8F"><span class="nav-number">8.4.2.</span> <span class="nav-text">设置临时 PATH 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%B0%B8%E4%B9%85-PATH-%E5%8F%98%E9%87%8F"><span class="nav-number">8.4.3.</span> <span class="nav-text">设置永久 PATH 变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#apropos"><span class="nav-number">9.</span> <span class="nav-text">apropos</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-apropos-%E6%90%9C%E7%B4%A2-Linux-%E5%91%BD%E4%BB%A4"><span class="nav-number">9.1.</span> <span class="nav-text">使用 apropos 搜索 Linux 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">9.2.</span> <span class="nav-text">多个关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%85%E6%90%9C%E7%B4%A2%E7%94%A8%E6%88%B7%E6%88%96%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="nav-number">9.3.</span> <span class="nav-text">仅搜索用户或系统命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tee"><span class="nav-number">10.</span> <span class="nav-text">tee</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tee-%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="nav-number">10.1.</span> <span class="nav-text">tee 命令示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6"><span class="nav-number">10.2.</span> <span class="nav-text">显示命令输出并将其保存到文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">10.3.</span> <span class="nav-text">显示命令输出并将其保存到多个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%90%8C%E6%97%B6%E5%B0%86%E5%85%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">10.4.</span> <span class="nav-text">将命令输出解析到另一个命令，同时将其保存到文件中</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="nav-number">11.</span> <span class="nav-text">花括号扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90"><span class="nav-number">11.1.</span> <span class="nav-text">一些例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97"><span class="nav-number">11.2.</span> <span class="nav-text">使用字母序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">11.3.</span> <span class="nav-text">实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E7%B3%BB%E5%88%97%E6%96%87%E4%BB%B6"><span class="nav-number">11.3.1.</span> <span class="nav-text">创建一系列文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6"><span class="nav-number">11.3.2.</span> <span class="nav-text">创建备份文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E8%8A%B1%E6%8B%AC%E5%8F%B7"><span class="nav-number">11.3.3.</span> <span class="nav-text">使用多个花括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E8%B7%AF%E5%BE%84%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%88%96%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="nav-number">11.3.4.</span> <span class="nav-text">在路径中使用或括号扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E9%9D%9E%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9%E9%83%BD%E5%8F%AF%E6%89%A9%E5%B1%95"><span class="nav-number">11.4.</span> <span class="nav-text">并非所有内容都可扩展</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">12.</span> <span class="nav-text">分析二进制文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#file"><span class="nav-number">12.1.</span> <span class="nav-text">file</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ldd"><span class="nav-number">12.2.</span> <span class="nav-text">ldd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ltrace"><span class="nav-number">12.3.</span> <span class="nav-text">ltrace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hexdump"><span class="nav-number">12.4.</span> <span class="nav-text">Hexdump</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strings"><span class="nav-number">12.5.</span> <span class="nav-text">strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readelf"><span class="nav-number">12.6.</span> <span class="nav-text">readelf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objdump"><span class="nav-number">12.7.</span> <span class="nav-text">objdump</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strace"><span class="nav-number">12.8.</span> <span class="nav-text">strace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nm"><span class="nav-number">12.9.</span> <span class="nav-text">nm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gdb"><span class="nav-number">12.10.</span> <span class="nav-text">gdb</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mapfile"><span class="nav-number">13.</span> <span class="nav-text">mapfile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#source"><span class="nav-number">14.</span> <span class="nav-text">source</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#source-%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-number">14.1.</span> <span class="nav-text">source 命令是如何工作的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F"><span class="nav-number">14.2.</span> <span class="nav-text">关于变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E-shell-%E5%8F%98%E9%87%8F"><span class="nav-number">14.3.</span> <span class="nav-text">环境变量与 shell 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#source-%E5%92%8C-bash"><span class="nav-number">14.4.</span> <span class="nav-text">source 和 bash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-source-%E5%91%BD%E4%BB%A4%E5%88%B7%E6%96%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">14.5.</span> <span class="nav-text">使用 source 命令刷新环境变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">15.</span> <span class="nav-text">#!</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84shebang%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">15.1.</span> <span class="nav-text">shell脚本中的shebang是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-shebang-%E5%9C%A8-shell-%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">15.2.</span> <span class="nav-text">为什么 shebang 在 shell 脚本中很重要？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-shebang-%E6%8C%87%E5%AE%9A-shell-%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">15.3.</span> <span class="nav-text">使用 shebang 指定 shell 解释器的重要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8C%87%E5%AE%9A%E4%BA%86-shell%EF%BC%8C%E9%82%A3%E4%B9%88-shebang-%E5%B0%86%E4%BC%9A%E8%A2%AB%E5%BF%BD%E7%95%A5"><span class="nav-number">15.4.</span> <span class="nav-text">如果运行时指定了 shell，那么 shebang 将会被忽略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shebang-%E6%98%AF%E6%80%8E%E6%A0%B7%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">15.5.</span> <span class="nav-text">shebang 是怎样工作的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%86%8D%E6%9D%A5%E6%98%8E%E7%A1%AE%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">15.6.</span> <span class="nav-text">最后，我们再来明确几个注意事项：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-1"><span class="nav-number">16.</span> <span class="nav-text">环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%A7%8D%E7%B1%BB"><span class="nav-number">16.1.</span> <span class="nav-text">配置文件种类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#etc-profile"><span class="nav-number">16.1.1.</span> <span class="nav-text">&#x2F;etc&#x2F;profile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#etc-profile-d-sh"><span class="nav-number">16.1.2.</span> <span class="nav-text">&#x2F;etc&#x2F;profile.d&#x2F;*.sh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bash-profile"><span class="nav-number">16.1.3.</span> <span class="nav-text">~&#x2F;.bash_profile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bashrc"><span class="nav-number">16.1.4.</span> <span class="nav-text">~&#x2F;.bashrc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#etc-bashrc"><span class="nav-number">16.1.5.</span> <span class="nav-text">&#x2F;etc&#x2F;bashrc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="nav-number">16.2.</span> <span class="nav-text">配置文件加载顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%97%A5%E5%BF%97"><span class="nav-number">16.2.1.</span> <span class="nav-text">添加日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E7%BB%88%E7%AB%AF%E6%9F%A5%E7%9C%8B"><span class="nav-number">16.2.2.</span> <span class="nav-text">开启终端查看</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%89%B9%E7%82%B9"><span class="nav-number">16.3.</span> <span class="nav-text">配置文件特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">16.3.1.</span> <span class="nav-text">配置文件加载的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%90%AF%E7%BB%88%E7%AB%AF"><span class="nav-number">16.3.1.1.</span> <span class="nav-text">新启终端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#source%E5%91%BD%E4%BB%A4%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD"><span class="nav-number">16.3.1.2.</span> <span class="nav-text">source命令重新加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95"><span class="nav-number">16.3.2.</span> <span class="nav-text">登录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E6%80%81"><span class="nav-number">16.3.3.</span> <span class="nav-text">登录态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1%E3%80%81no-login"><span class="nav-number">16.3.3.1.</span> <span class="nav-text">3.2.1、no login</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%B9%E8%B1%A1"><span class="nav-number">16.3.4.</span> <span class="nav-text">服务的用户对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1%E3%80%81%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7"><span class="nav-number">16.3.4.1.</span> <span class="nav-text">3.3.1、系统用户</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2%E3%80%81%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7joy"><span class="nav-number">16.3.4.2.</span> <span class="nav-text">3.3.2、普通用户joy</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">16.4.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D"><span class="nav-number">16.4.1.</span> <span class="nav-text">系统默认自定义命令别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D"><span class="nav-number">16.4.2.</span> <span class="nav-text">自定义命令别名</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qeuroal"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qeuroal</p>
  <div class="site-description" itemprop="description">大人者，不失其赤子之心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Qeuroal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qeuroal" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2024/01/01/189/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="189. Linux中的命令之大杂烩 | Qeuroal's Blog">
      <meta itemprop="description" content="不知道命令属于哪一类, 但是常用且重要">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          189. Linux中的命令之大杂烩
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-01 08:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T08:00:00+08:00">2024-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">不知道命令属于哪一类, 但是常用且重要</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="history"><a href="#history" class="headerlink" title="history"></a>history</h1><p>使用history命令可以使工作更高效。</p>
<p>随着我使用终端的时间越来越多，我一直在寻找一些能让我提高效率的命令。history 是一个可以改变我日常工作的命令。</p>
<p>history 命令保存了从终端会话开始后的所有其他命令的列表，允许你重新使用这些命令，而不是再次输入。如果你是一个经验丰富的终端用户，那么你应该知道 history，但是对于一些新的系统管理员来说，history是一个可以产生即时效益的工具。</p>
<p>首先，history 命令实际上不是一个真正的命令。你可以通过在系统中查找命令来验证这一点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> <span class="built_in">history</span></span><br><span class="line"><span class="built_in">which</span>: no <span class="built_in">history</span> <span class="keyword">in</span> (/usr/local/bin:/usr/bin:/bin:/usr/games:/usr/local/sbin)</span><br></pre></td></tr></table></figure>

<p>你会看到在计算机中找不到 history 命令，因为它是 shell 的一个内置关键字。也正是因为它是写在 shell 中的，所以根据你使用的是 Bash, tcsh, Zsh, dash, fish, ksh 等等，history 会有一些不同。本文是基于Bash来描述的，因此某些函数可能无法在其他 shell 中工作。但大多数的基本功能是相同的。</p>
<h2 id="history-101"><a href="#history-101" class="headerlink" title="history 101"></a>history 101</h2><p>要查看 history 历史记录，在linux系统中打开终端，然后输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span></span><br></pre></td></tr></table></figure>

<p>你会看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line">sudo dnf update -y</span><br><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure>

<p>history 命令显示你启动终端会话以来所输入的命令列表。有意思的是，你可以使用以下命令来重新调用列表中的任何一个（历史命令）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !3</span><br></pre></td></tr></table></figure>

<p>这个 <code>!3</code> 命令是告诉 shell 执行历史记录表中的第三行命令。此外也可以通过输入以下命令来访问该命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !sudo dnf</span><br></pre></td></tr></table></figure>

<p>这个是让 history 搜索与你提供的表达式相匹配的最后一个命令（在上面这个例子中，这个表达式是dnf）并运行它。</p>
<h2 id="查找-history"><a href="#查找-history" class="headerlink" title="查找 history"></a>查找 history</h2><p>你还可以使用 history 来重新运行上次输入的命令，方法是键入：!!. 通过将它与 grep 配对，可以搜索与文本模式匹配的命令，或者通过将它与 tail 一起使用，可以找到最后执行的几个命令。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span> | grep dnf</span><br><span class="line">3  sudo dnf update -y</span><br><span class="line">5  <span class="built_in">history</span> | grep dnf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span> | <span class="built_in">tail</span> -n 3</span><br><span class="line">4  <span class="built_in">history</span></span><br><span class="line">5  <span class="built_in">history</span> | grep dnf</span><br><span class="line">6  <span class="built_in">history</span> | <span class="built_in">tail</span> -n 3</span><br></pre></td></tr></table></figure>

<p>获取此搜索功能的另一种方法是键入 Ctrl-R 以调用对命令历史记录的递归搜索。键入后，提示变为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(reverse-i-search)`<span class="string">&#x27;:</span></span><br></pre></td></tr></table></figure>

<p>这样你可以通过点击回车（Enter）或者回退（Return）来选择匹配的命令。</p>
<h2 id="修改和执行命令"><a href="#修改和执行命令" class="headerlink" title="修改和执行命令"></a>修改和执行命令</h2><p>你还可以通过 history 来修改命令以返回一个新的命令。比如我想要将 <code>history | grep dnf</code> 改为 <code>history | grep ssh</code>, 可以执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ^dnf^ssh^</span><br></pre></td></tr></table></figure>

<p>命令将被执行，但会以ssh来替换dnf，也就是说，会执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span> | grep ssh</span><br></pre></td></tr></table></figure>

<h2 id="删除-history"><a href="#删除-history" class="headerlink" title="删除 history"></a>删除 history</h2><p>有时候你可能会要删除部分或者所有的历史命令。如果要删除部分历史命令，使用 <code>history -d &lt;line number&gt;</code>, 如果要清除所有的历史记录，可以执行 <code>history -c</code>.</p>
<p>history列表存储在一个用户可以修改的文件中。Bash用户可以在你的home路径中找到它，文件名是 .bash_history.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>你还可以用 history 来做一些其他事情：</p>
<ul>
<li>将 history 缓冲区的大小设置为某一数值；</li>
<li>记录历史记录中每一行的日期和时间；</li>
<li>阻止某些命令被记录在 history 记录中。</li>
</ul>
<p>有关 history 命令的其他信息或者有意思的用法，可以看一下 Seth Kenlon 关于parsing history,  history 搜索修饰符的文章，或者 GNU Bash 的操作手册。</p>
<blockquote>
<p>reference: </p>
<ul>
<li>Steve Morris</li>
<li>原文地址：<a target="_blank" rel="noopener" href="https://opensource.com/article/18/6/history-command">https://opensource.com/article/18/6/history-command</a></li>
</ul>
</blockquote>
<h1 id="shell中2-1的含义解释"><a href="#shell中2-1的含义解释" class="headerlink" title="shell中2&gt;&amp;1的含义解释"></a>shell中2&gt;&amp;1的含义解释</h1><h2 id="首先了解下1和2在Linux中代表什么"><a href="#首先了解下1和2在Linux中代表什么" class="headerlink" title="首先了解下1和2在Linux中代表什么"></a>首先了解下1和2在Linux中代表什么</h2><p>在Linux系统中<code>0 1 2</code>是一个文件描述符</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>代码</strong></th>
<th><strong>操作符</strong></th>
<th><strong>Java中表示</strong></th>
<th><strong>Linux 下文件描述符（Debian 为例)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>标准输入(stdin)</td>
<td>0</td>
<td><code>&lt;</code> 或 <code>&lt;&lt;</code></td>
<td><code>System.in</code></td>
<td><code>/dev/stdin -&gt; /proc/self/fd/0 -&gt; /dev/pts/0</code></td>
</tr>
<tr>
<td>标准输出(stdout)</td>
<td>1</td>
<td><code>&gt;, &gt;&gt;, 1&gt;</code> 或 <code>1&gt;&gt;</code></td>
<td><code>System.out</code></td>
<td><code>/dev/stdout -&gt; /proc/self/fd/1 -&gt; /dev/pts/0</code></td>
</tr>
<tr>
<td>标准错误输出(stderr)</td>
<td>2</td>
<td><code>2&gt;</code> 或者 <code>2&gt;&gt;</code></td>
<td><code>System.error</code></td>
<td><code>/dev/stderr -&gt; /proc/self/fd/2 -&gt; /dev/pts/0</code></td>
</tr>
</tbody></table>
<p>从上表看的出来，我们平时使用的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; t.log</span><br></pre></td></tr></table></figure>

<p>其实也可以写成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> 1&gt; t.log</span><br></pre></td></tr></table></figure>

<h2 id="关于2-1的含义"><a href="#关于2-1的含义" class="headerlink" title="关于2&gt;&amp;1的含义"></a>关于2&gt;&amp;1的含义</h2><p>（关于输入&#x2F;输出重定向本文就不细说了，主要是要了解<code>&gt;</code> <code>&lt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&lt;&amp;</code> <code>&gt;&amp;</code> 这6个符号的使用）</p>
<p>1）含义：<strong>将标准错误输出重定向到标准输出</strong></p>
<p>2）<strong>符号&gt;&amp;是一个整体</strong>，不可分开，分开后就不是上述含义了。</p>
<p>比如有些人可能会这么想：2是标准错误输出，1是标准输出，&gt;是重定向符号，那么”将标准错误输出重定向到标准输出”是不是就应该写成”<code>2&gt;1</code>“就行了？是这样吗？</p>
<p>如果是尝试过，你就知道<code>2&gt;1</code>的写法其实是将标准错误输出重定向到名为”1”的文件里去了</p>
<p>3）写成<code>2&amp;&gt;1</code>也是不可以的。</p>
<h2 id="为什么2-1要放在后面"><a href="#为什么2-1要放在后面" class="headerlink" title="为什么2&gt;&amp;1要放在后面"></a>为什么2&gt;&amp;1要放在后面</h2><p>考虑如下一条shell命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -jar app.jar &gt;<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>(最后一个&amp;表示把条命令放到后台执行，不是本文重点，不懂的可以自行Google)</p>
<p>为什么<code>2&gt;&amp;1</code>一定要写到<code>&gt;log</code>后面，才表示标准错误输出和标准输出都定向到log中？</p>
<p>我们不妨把1和2都理解是一个指针,然后来看上面的语句就是这样的：</p>
<ul>
<li>本来1—–&gt;屏幕（1指向屏幕）</li>
<li>执行<code>&gt;log</code>后， 1—–&gt;log (1指向log)</li>
<li>执行<code>2&gt;&amp;1</code>后， 2—–&gt;1 (2指向1，而1指向log,因此2也指向了log)</li>
</ul>
<p>再来分析下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -jar app.jar 2&gt;&amp;1 &gt;<span class="built_in">log</span>&amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>本来1—–&gt;屏幕（1指向屏幕）</li>
<li>执行<code>2&gt;&amp;1</code>后， 2—–&gt;1 (2指向1，而1指向屏幕,因此2也指向了屏幕)</li>
<li>执行<code>&gt;log</code>后， 1—–&gt;log (1指向log，2还是指向屏幕)</li>
</ul>
<p>所以这就不是我们想要的结果。</p>
<p>简单做个试验测试下上面的想法：</p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Htest</span> &#123;</span><br><span class="line">    publicstatic <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;out1&quot;</span>);</span><br><span class="line">       System.err.println(<span class="string">&quot;error1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javac编译后运行下面指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Htest 2&gt;&amp;1 &gt; <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>你会在终端上看到只输出了”error1”，log文件中则只有”out1”</p>
<h2 id="每次都写”-log2-1”太麻烦，能简写吗？"><a href="#每次都写”-log2-1”太麻烦，能简写吗？" class="headerlink" title="每次都写”&gt;log2&gt;&amp;1”太麻烦，能简写吗？"></a>每次都写”&gt;log2&gt;&amp;1”太麻烦，能简写吗？</h2><p>有以下两种简写方式</p>
<ul>
<li><code>&amp;&gt;log</code></li>
<li><code>&gt;&amp;log</code></li>
</ul>
<p>比如上面小节中的写法就可以简写为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> java -jar app.jar &amp;&gt;<span class="built_in">log</span> &amp;</span><br></pre></td></tr></table></figure>

<p>上面两种方式都和”<code>&gt;log 2&gt;&amp;1</code>“一个语义。</p>
<p>那么上面两种方式中<code>&amp;&gt;</code>和<code>&gt;&amp;</code>有区别吗？</p>
<p>语义上是没有任何区别的，但是第一种方式是最佳选择，一般使用第一种。</p>
<h1 id="输入、输出和错误重定向"><a href="#输入、输出和错误重定向" class="headerlink" title="输入、输出和错误重定向"></a>输入、输出和错误重定向</h1><p>我们都知道 Linux 命令的功能，它接受一个输入，然后给你一个输出。在这里起作用的包含一些重要的角色，我们今天就来介绍一下这些角色。</p>
<h2 id="stdin-stdout-和-stderr"><a href="#stdin-stdout-和-stderr" class="headerlink" title="stdin, stdout 和 stderr"></a>stdin, stdout 和 stderr</h2><p>当你运行 Linux 命令时，有三个数据流在其中起作用：</p>
<table>
<thead>
<tr>
<th>数据流</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stdin </code></td>
<td>（Standard input，标准输入）是输入数据的源。<br>默认情况下，<code>stdin</code> 是从键盘输入的任何文本，它的流 ID（stream ID） 为 0；</td>
</tr>
<tr>
<td><code>stdout</code></td>
<td>（Standard output，标准输出）是命令的输出结果。<br>默认情况下，它会显示在屏幕上，它的流 ID（stream ID） 为 1；</td>
</tr>
<tr>
<td><code>stderr</code></td>
<td>（Standard error，标准错误）是命令产生的错误消息（如果有）。<br>默认情况下，屏幕上也会显示 stderr。它的流 ID（stream ID）是2。</td>
</tr>
</tbody></table>
<p>这些流包含存储在内存缓冲区(buffer memory)中的纯文本数据。</p>
<img data-src="/2024/01/01/189/640-20240110083648475.png" class="" title="图片">

<p>把它想象成一个水流，你需要水源，比如水龙头，用管道连接到它，可以将其存储在水桶（<strong>文件</strong>）中，也可以给植物浇水（<strong>打印</strong>）。如果需要，还可以将其连接到另外一个水龙头上，也就是改变水的流向（<strong>重定向</strong>）。</p>
<p>Linux 中也有这种重定向的概念。你可以将 <code>stdin</code>, <code>stdout</code> 和 <code>stderr</code> 从其原本的目标，重定向到另一个文件或命令（甚至是打印机等外围设备）。</p>
<p>接下来我们来介绍一下重定向是如何工作的，以及如何使用它。</p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><img data-src="/2024/01/01/189/640-20240110083427436-4846867.png" class="" title="图片">

<p>第一种也是最简单的重定向形式是输出重定向，也称为<strong>标准输出重定向</strong>。</p>
<p>默认情况下，命令的输出是显示在屏幕上。比如，我使用 <code>ls</code> 命令列出当前目录下的所有文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span></span><br><span class="line">appstxt  new.txt  static-ip.txt</span><br></pre></td></tr></table></figure>

<p>通过输出重定向，可以将输出重定向到文件。如果此输出文件不存在，那么 shell 将创建它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; file</span><br></pre></td></tr></table></figure>

<p>比如，我们将上述 ls 命令的输出保存到名为 output.txt 的文本文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> &gt; output.txt</span><br></pre></td></tr></table></figure>

<h3 id="输出文件是预先创建的"><a href="#输出文件是预先创建的" class="headerlink" title="输出文件是预先创建的"></a>输出文件是预先创建的</h3><p>那么这个 output.txt 文件的内容是什么呢？我们用 <code>cat</code> 命令来看一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> output.txt </span><br><span class="line">appstxt</span><br><span class="line">new.txt</span><br><span class="line">output.txt</span><br><span class="line">static-ip.txt</span><br></pre></td></tr></table></figure>

<p>有没有注意到里面也包含 output.txt？将输出重定向输出到的文件（output.txt）<strong>是在运行预期命令之前创建的</strong>。为什么呢？因为它需要准备好输出的目的地，输出将被发送到该目的地。</p>
<h3 id="追加而不是删除"><a href="#追加而不是删除" class="headerlink" title="追加而不是删除"></a>追加而不是删除</h3><p>一个经常被忽略的问题是，如果重定向到一个已经存在的文件，shell 将首先删除该文件。这意味着输出文件的现有内容将<strong>被删除</strong>，并<strong>替换</strong>为命令的输出。</p>
<p>如果不想删除原有的内容，而只是追加，那么可以使用 <code>&gt;&gt;</code> 重定向语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt;&gt; file</span><br></pre></td></tr></table></figure>

<p>你可以在当前的 shell 会话中禁止删除，使用 <code>set -C</code></p>
<p>将输出重定向到文件，可以将输出的内容保存起来以供将来参考；另外如果输出的内容太多，占用了大篇幅的屏幕时，将内容保存到文件，就更方便查看和分析了，这就像收集日志文件一样。</p>
<h2 id="管道重定向"><a href="#管道重定向" class="headerlink" title="管道重定向"></a>管道重定向</h2><img data-src="/2024/01/01/189/640-20240110083427436.png" class="" title="图片">

<p>在介绍 stdin 重定向之前，我们先来了解一下管道重定向，这是更加常见的，我们会经常使用管道重定向。</p>
<p>关于管道重定向，可以参阅我们先前的文章：<a href="#%E7%AE%A1%E9%81%93pipe">管道pipe</a></p>
<p>通过管道重定向，可以<strong>将命令的标准输出发送到另一个命令的标准输入</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> 1 | <span class="built_in">command</span> 2</span><br></pre></td></tr></table></figure>

<p>我们来举个例子，如果我们要查看当前目录中文件的数量，可以使用 <code>ls -1</code>（注意是数字1，不是字母L）来显示当前目录中的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> -1</span><br><span class="line">appstxt</span><br><span class="line">new.txt</span><br><span class="line">output.txt</span><br><span class="line">static-ip.txt</span><br></pre></td></tr></table></figure>

<p>我们知道 <code>wc</code> 命令用于计算文件中的行数，所以我们可以结合这个命令，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> -1 | <span class="built_in">wc</span> -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>使用管道，两个命令<strong>共享相同的内存缓冲区</strong>，第一个命令的输出存储在缓冲区中，然后该缓冲区将用作下一个命令的输入。</p>
<p>你将看到管道中最后一个命令的结果。这一点很明显，因为先前命令的 <code>stdout</code> 被重定向到下一个命令，而不是打印在屏幕上。</p>
<p>管道重定向或管道不限于仅连接两个命令，你也可以连接多个命令，只要一个命令的输出可用作下一个命令输入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command_1 | command_2 | command_3 | command_4</span><br></pre></td></tr></table></figure>

<h2 id="请注意，stdout-stdin-是一块数据，而不是文件名"><a href="#请注意，stdout-stdin-是一块数据，而不是文件名" class="headerlink" title="请注意，stdout&#x2F;stdin 是一块数据，而不是文件名"></a>请注意，stdout&#x2F;stdin 是一块数据，而不是文件名</h2><p>一些新的Linux用户在使用重定向时会感到困惑，如果命令返回一组文件名作为输出，则不能将这些文件名用作参数。</p>
<p>比如，使用 find 命令查找扩展名为 .txt 的文件，无法通过管道将查找到的这些文件移动到新的目录，不能这样操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | <span class="built_in">mv</span> destination_directory</span><br></pre></td></tr></table></figure>

<p>这就是为什么我们经常会看到 <strong>find 命令与 exec 或 xargs 命令组合使用</strong>的原因。这些命令可以将大量的文本“文件名”转换为文件名，且可作为参数传递。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs -t -I&#123;&#125; <span class="built_in">mv</span> &#123;&#125; ../new_dir</span><br></pre></td></tr></table></figure>

<p>关于find 与 exec 或 xargs 命令组合使用的相关内容，可参考：<a href="#xargs">使用xargs命令</a></p>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><img data-src="/2024/01/01/189/640-20240110083427435.png" class="" title="图片">

<p>使用 stdin 重定向可以将文本文件的内容传递给终端命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt; file</span><br></pre></td></tr></table></figure>

<p>但是这种<strong>并不常用</strong>，因为大多数 Linux 命令都可以<strong>接受文件名作为参数</strong>，因此通常不需要 stdin 重定向。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> &lt; filename.txt</span><br></pre></td></tr></table></figure>

<p>上面的命令可以直接写为：<code>head filename.ext</code>（也就是不用重定向符号 <code>&lt;</code>）。</p>
<p>也不是说 <code>stdin</code> 重定向完全没有用，有些命令是依赖于它的。以 <code>tr</code> 命令为例，这个命令可以做很多事情，但在下面的例子中，它将输入文本从小写转为大写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> a-z A-Z &lt; filename.txt</span><br></pre></td></tr></table></figure>

<p>事实上，建议在管道上使用标准输入重定向，以避免不必要地使用 <code>cat</code> 命令。</p>
<p>比如上面的例子，很多人就习惯使用 <code>cat</code>，然而这里并没有必要使用<code>cat</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename.txt | <span class="built_in">tr</span> a-z A-Z</span><br></pre></td></tr></table></figure>

<h2 id="合并重定向"><a href="#合并重定向" class="headerlink" title="合并重定向"></a>合并重定向</h2><p>你可以根据需要组合使用 stdin，stdout 和管道重定向。</p>
<p>比如，下面的命令列出当前目录下所有的 txt 文件，然后统计一下文件的总数，并将这个结果保存到一个新文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.txt | <span class="built_in">wc</span> -l &gt; count.txt</span><br></pre></td></tr></table></figure>

<h2 id="错误重定向"><a href="#错误重定向" class="headerlink" title="错误重定向"></a>错误重定向</h2><p>有时候，当你运行一些命令或脚本时，会在屏幕上看到一条错误信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> -l ffffff &gt; output.txt</span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;ffffff&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>

<p>在本文的开头，我们提到过有三种数据流，stderr 是其中之一，它默认将输出显示在屏幕上。</p>
<p>你也可以重定向 stderr。由于它是一个输出数据流，因此可以使用与标准输出重定向相同的 <code>&gt;</code> 或 <code>&gt;&gt;</code> 重定向符号。</p>
<p>但是，当 stdout 和 stderr 都作为输出数据流时，如何区分它们呢？通过它们的<strong>流 ID</strong>（stream ID，也称为文件描述符）。</p>
<table>
<thead>
<tr>
<th><strong>Data stream</strong></th>
<th>**stream ID **</th>
</tr>
</thead>
<tbody><tr>
<td><code>stdin</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>stdout</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>stderror</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>-t</code></td>
<td><code>-list</code></td>
</tr>
<tr>
<td><code>-u</code></td>
<td><code>-update</code></td>
</tr>
<tr>
<td><code>-x</code></td>
<td><code>–extract, –get</code></td>
</tr>
<tr>
<td><code>-j</code></td>
<td><code>–bzip2</code></td>
</tr>
<tr>
<td><code>-z</code></td>
<td><code>–gzip, –gunzip, –ungzip</code></td>
</tr>
</tbody></table>
<p>默认情况下，当你使用输出重定向符号 <code>&gt;</code> 时，它实际上是 <code>1 &gt;</code>。换句话说，<strong>ID 为 1</strong> 的数据流是在这里输出。</p>
<p>所以当你要重定向 stderr 时，可以使用它的ID，比如 2&gt; 或者 2&gt;&gt;。这表示输出重定向用于数据流 stderr（ID为2）。</p>
<h2 id="stderr-重定向示例"><a href="#stderr-重定向示例" class="headerlink" title="stderr 重定向示例"></a>stderr 重定向示例</h2><p>我们来举几个例子。假如我们只想要保存错误信息，那么可以这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> fffff 2&gt; error.txt</span><br><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> error.txt </span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;fffff&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这个很简单。我们再来个稍微复杂一点的（并且很有用的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> -l new.txt ffff &gt; output.txt 2&gt; error.txt </span><br><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> output.txt </span><br><span class="line">-rw-rw-r-- 1 gliu gliu 0 May  5 10:25 new.txt</span><br><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> error.txt </span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;ffff&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>ls</code> 命令尝试显示两个文件的信息。其中一个文件能成功，另一个会出错。所以我在这里做的是将 stdout 输出重定向到 output.txt 文件中，将 stderr 重定向到 error.txt 中（使用 <code>2&gt;</code>）。</p>
<p>此外，我们还可以将 stdout 和 stderr 重定向到同一个文件，是有办法做到这一点的。</p>
<p>在下面的例子中，我使用追加模式（append mode）将 stderr 重定向到文件 combined.txt 中（使用 <code>2&gt;&gt;</code>）；然后，同样使用追加模式将标准输出 stdout 重定向到同一个文件 combined.txt 中（使用 <code>&gt;&gt;</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> -l new.txt fff 2&gt;&gt; combined.txt &gt;&gt; combined.txt </span><br><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> combined.txt </span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;fff&#x27;</span>: No such file or directory</span><br><span class="line">-rw-rw-r-- 1 gliu gliu 0 May  5 10:25 new.txt</span><br></pre></td></tr></table></figure>

<p>另一种方法，也是首选的方法，是使用类似于 <code>2&gt;&amp;1</code> 的东西，可以大致的翻译为“将 stderr 重定向到与 stdout 相同的地址中”。</p>
<p>我们以前面的示例为例，这次使用 <code>2&gt;&amp;1</code> 将 stdout 和 stderr 重定向到同一个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span> -l new.txt fff &gt; output.txt 2&gt;&amp;1</span><br><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> output.txt </span><br><span class="line"><span class="built_in">ls</span>: cannot access <span class="string">&#x27;fff&#x27;</span>: No such file or directory</span><br><span class="line">-rw-rw-r-- 1 gliu gliu 0 May  5 10:25 new.txt</span><br></pre></td></tr></table></figure>

<p>在这里需要注意的一点是，不能想当然的以为 <code>2&gt;&gt;&amp;1</code> 为追加模式，因为 <code>2&gt;&amp;1</code> 本身就是<strong>追加模式</strong>。</p>
<p>此外，你也可以先使用 <code>2&gt;</code>，然后使用 <code>1&gt;&amp;2</code> 将 stdout 重定向到与 stderr 相同的文件上。基本上，<code>&gt;&amp;</code> 是将一个输出数据流重定向到另一个上。</p>
<h2 id="我们来总结一下"><a href="#我们来总结一下" class="headerlink" title="我们来总结一下"></a>我们来总结一下</h2><ol>
<li><p>有三种数据流，其中一个是输入数据流 stdin（0），两个输出数据流为 stdout（1） 和 stderr（2）；</p>
</li>
<li><p>键盘输入是默认的标准输入设备，屏幕是默认的输出设备；</p>
</li>
<li><p>输出重定向使用 <code>&gt;</code> 或者 <code>&gt;&gt;</code>（用于追加模式）；</p>
</li>
<li><p>输入重定向使用 <code>&lt;</code>；</p>
</li>
<li><p>stderr 可以使用 <code>2&gt;</code> 或者 <code>2&gt;&gt;</code>；</p>
</li>
<li><p>stderr 和 stdout 可以组合为：<code>2&gt;&amp;1</code>。</p>
</li>
</ol>
<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find  path  -option  [  -<span class="built_in">print</span> ]  [ -<span class="built_in">exec</span>  -ok  <span class="built_in">command</span> ]  &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 <code>-</code> <code>( )</code> <code>!</code> 之前的部分为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 <code>-print</code> 为预设 expression。</p>
<p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部分。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-mount, -xdev</code></td>
<td>只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</td>
</tr>
<tr>
<td><code>-amin n</code></td>
<td>在过去 n 分钟内被读取过</td>
</tr>
<tr>
<td><code>-anewer file</code></td>
<td>比文件 file 更晚被读取过的文件</td>
</tr>
<tr>
<td><code>-atime n</code></td>
<td>在过去n天内被读取过的文件</td>
</tr>
<tr>
<td><code>-cmin n</code></td>
<td>在过去 n 分钟内被修改过</td>
</tr>
<tr>
<td><code>-cnewer file</code></td>
<td>文件 file 更新的文件</td>
</tr>
<tr>
<td><code>-ctime n</code></td>
<td>在过去n天内被修改过的文件</td>
</tr>
<tr>
<td><code>-empty</code></td>
<td>空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</td>
</tr>
<tr>
<td><code>-ipath p, -path p</code></td>
<td>路径名称符合 p 的文件，ipath 会忽略大小写</td>
</tr>
<tr>
<td><code>-name name, -iname name</code></td>
<td>文件名称符合 name 的文件。iname 会忽略大小写</td>
</tr>
<tr>
<td><code>-size n</code></td>
<td>文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。</td>
</tr>
<tr>
<td><code>-type c</code></td>
<td>文件类型是 c 的文件。</td>
</tr>
<tr>
<td><code>d</code></td>
<td>目录</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字型装置文件</td>
</tr>
<tr>
<td><code>b</code></td>
<td>区块装置文件</td>
</tr>
<tr>
<td><code>p</code></td>
<td>具名贮列</td>
</tr>
<tr>
<td><code>f</code></td>
<td>一般文件</td>
</tr>
<tr>
<td><code>l</code></td>
<td>符号连结</td>
</tr>
<tr>
<td><code>s</code></td>
<td>socket</td>
</tr>
<tr>
<td><code>-pid n</code></td>
<td>process id 是 n 的文件</td>
</tr>
</tbody></table>
<p>你可以使用 <code>()</code> 将运算式分隔，并使用下列运算。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exp1 -and exp2</span><br><span class="line">! <span class="built_in">expr</span></span><br><span class="line">-not <span class="built_in">expr</span></span><br><span class="line">exp1 -or exp2</span><br><span class="line">exp1, exp2</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:</span></span><br><span class="line">$ find . -name <span class="string">&quot;*.c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将目前目录其其下子目录中所有一般文件列出</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将当前目录及其子目录下所有最近 20 天内更新过的文件列出:</span></span><br><span class="line">$ find . -ctime -20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</span></span><br><span class="line">$ find /var/log -<span class="built_in">type</span> f -mtime +7 -ok <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</span></span><br><span class="line">$ find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</span></span><br><span class="line">$ find / -<span class="built_in">type</span> f -size 0 -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>有两种方法可以对find命令的结果执行其他命令：分别是使用 <strong>xargs</strong> 和 <strong>exec</strong> 命令。</p>
<h3 id="exec-与-find-命令一起使用"><a href="#exec-与-find-命令一起使用" class="headerlink" title="exec 与 find 命令一起使用"></a>exec 与 find 命令一起使用</h3><p>使用 exec 执行 find 命令的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [path] [arguments] -<span class="built_in">exec</span> [<span class="built_in">command</span>] &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上述语法中：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[command]</code></td>
<td>是要对 <code>find</code> 命令的输出结果执行的操作（后续命令）；</td>
</tr>
<tr>
<td><code>&#123;&#125;</code></td>
<td>是一个占位符，用于保存 <code>find</code> 命令输出的结果；</td>
</tr>
<tr>
<td><code>\;</code></td>
<td>表示对于每个找到的结果，都会执行一次<code>[command]</code>，在这里需要对分号 <code>;</code> 进行转义，因此需要在前面使用反斜杠 <code>\</code> 。</td>
</tr>
</tbody></table>
<p>注意，在 <code>&#123;&#125;</code> 和 <code>\;</code> 之间需要有一个空格。</p>
<p>还有另外一种用法，与上面的方式有所不同，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [path] [arguments] -<span class="built_in">exec</span> [<span class="built_in">command</span>] &#123;&#125; +</span><br></pre></td></tr></table></figure>

<p>这里，加号 <code>+</code> 表示对于 <code>find</code> 命令的所有结果，<code>[command]</code> 只会执行一次，也就是所有结果都作为参数一起传递给 <code>[command]</code>。这里的加号 <code>+</code> <strong>不需要</strong>使用反斜杠 <code>\</code> 进行转义。</p>
<p><strong><code>&#123;&#125; \;</code> 如同下面的执行（为每一个结果都单独执行一次）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls file1.txt</span><br><span class="line"></span><br><span class="line">ls file2.txt</span><br><span class="line"></span><br><span class="line">ls file3.txt</span><br></pre></td></tr></table></figure>



<p><strong><code>&#123;&#125; +</code> 如下所示（使用所有的输出作为参数，执行命令一次）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure>

<p>通过如上表述，使用 <code>&#123;&#125; +</code> 似乎是个更好的选择，但事实恰恰相反。如果 find 命令有50个结果，就不能将它们作为参数一起传递，因为在命令行中有最大长度限制。</p>
<p>这就是为什么你最好使用 <code>&#123;&#125; \;</code> 的原因，除非你特别清楚将要执行的操作。</p>
<h3 id="find-和-exec-命令一起使用的一些例子"><a href="#find-和-exec-命令一起使用的一些例子" class="headerlink" title="find 和 exec 命令一起使用的一些例子"></a>find 和 exec 命令一起使用的一些例子</h3><p>接下来我们分享一些常用的关于 find 和 exec 命令结合使用的例子，以便大家能更好的理解它们。</p>
<h3 id="查找和显示文件属性"><a href="#查找和显示文件属性" class="headerlink" title="查找和显示文件属性"></a>查找和显示文件属性</h3><p>下面的这个例子，将显示 &#x2F;tmp 目录下所有的 lock 文件，并显示它们的属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /tmp/ -<span class="built_in">type</span> f -name *lock -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sagar@LHB:~$ sudo find /tmp/ -<span class="built_in">type</span> f -name *lock -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123;&#125; \; </span><br><span class="line">-r--r--r-- 1 gdm gdm 11 Jul 17 08:01 /tmp/.X1024-lock</span><br><span class="line">-r--r--r-- 1 gdm gdm 11 Jul 17 08:01 /tmp/.X1025-lock</span><br></pre></td></tr></table></figure>

<h3 id="查找并重命名文件"><a href="#查找并重命名文件" class="headerlink" title="查找并重命名文件"></a>查找并重命名文件</h3><p>使用 find 和 exec 可以很方便的重命名文件（重命名文件，可以使用 mv 命令）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home/sagar/Downloads/ -<span class="built_in">type</span> f -name <span class="string">&#x27;ubuntu*&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">mv</span> &#123;&#125; &#123;&#125;_renamed \;</span><br></pre></td></tr></table></figure>

<p>上面的命令查找以 ubuntu 开头的文件，并将其存储在占位符中。一旦该过程结束，它将在存储在占位符中的每个文件的末尾添加 “_renamed”。</p>
<img data-src="/2024/01/01/189/640-20240117080740402.png" class="" title="图片">

<h3 id="收集并保存文件的大小"><a href="#收集并保存文件的大小" class="headerlink" title="收集并保存文件的大小"></a>收集并保存文件的大小</h3><p>在本例中，我们将展示如何收集特定目录下可用文件的大小，并创建一个文件来保存给定的输出。</p>
<p>我们将在 &#x2F;tmp 目录下收集每个文件的大小，并将输出保存在 &#x2F;root 目录下，文件名为：du_data.out</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /tmp/ -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">du</span> -sh &#123;&#125; \; &gt; /root/du_data.out</span><br></pre></td></tr></table></figure>

<p>那现在，我们在 &#x2F;root 目录下查看一下创建的文件内容是什么：</p>
<img data-src="/2024/01/01/189/640-20240117080740381.png" class="" title="图片">

<h3 id="使用特定参数删除文件"><a href="#使用特定参数删除文件" class="headerlink" title="使用特定参数删除文件"></a>使用特定参数删除文件</h3><p>自动删除文件时请格外小心。如果你不注意，这可能是灾难性的。可以将交互式删除与 <code>rm -i</code> 一起使用，也可以先查看 find 命令的结果。</p>
<p>find 与 exec 命令组合使用的另一个常见例子是查找大于某个值的文件并将其删除。比如，清理一些大的日志文件。</p>
<p>下面这个例子，我们将会删除桌面上大于 100MB 的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/Desktop -size +100M -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>类似，也可以根据文件创建的时间来删除，比如，我们删除超过10天的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /tmp/ -<span class="built_in">type</span> f -mtime +10 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上述命令中的 <code>-mtime</code> 选项，表示文件的修改时间，后面的数字单位是<strong>天</strong>，<code>+10</code>表示超过10天。</p>
<h3 id="使用特定的工具执行操作"><a href="#使用特定的工具执行操作" class="headerlink" title="使用特定的工具执行操作"></a>使用特定的工具执行操作</h3><p>在某些情况下，你可能希望在找到文件后，启动某些工具或软件包，来执行后续操作。</p>
<p>比如，我们搜索 <code>mp3</code> 文件，然后运行 <code>id3v2</code>，来显示 mp3 文件的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.mp3&quot;</span> -<span class="built_in">exec</span> id3v2 -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p><code>id3v2</code> 是一个包，它将显示有关 mp3 文件的详细信息，<code>-l</code> 用于显示与找到的 mp3 相关的每个 mp3 标记。</p>
<img data-src="/2024/01/01/189/640-20240117080740436-5450060.png" class="" title="图片">

<h3 id="更改文件和目录的所有权"><a href="#更改文件和目录的所有权" class="headerlink" title="更改文件和目录的所有权"></a>更改文件和目录的所有权</h3><p>使用 find 和 exec 组合命令，还可以更改文件或目录的所有权，这也是一个很常见的应用场景。</p>
<p>下面的例子，我们查找用户 sagar 所拥有的文件，然后将其用户所有权更改为 milan:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home/sagar/disk/Downloads -user sagar -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chown</span> milan &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240117080740369.png" class="" title="图片">

<h3 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h3><p>另外一个很常用的例子，就是更改文件的权限。</p>
<p>看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home/sagar/disk/Downloads -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chmod</span> 644 &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上述命令，用于查找 Downloads 目录下所有的文件（使用 <code>-type f</code> 选项），然后将其权限更改为 644。</p>
<img data-src="/2024/01/01/189/640-20240117080740436.png" class="" title="图片">

<h3 id="为每个文件收集md5sum"><a href="#为每个文件收集md5sum" class="headerlink" title="为每个文件收集md5sum"></a>为每个文件收集md5sum</h3><p>在下面的例子中，我们将演示如何为 &#x2F;tmp 目录下的每个可用文件收集 <code>md5sum</code> 信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /tmp/ -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">md5sum</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>如下图所示，上述命令会打印每个可用文件的名称和 md5sum 信息：</p>
<img data-src="/2024/01/01/189/640-20240117080740371.png" class="" title="图片">

<p>那么，怎么样才能将上面的输出保存到一个文件中呢？可使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /tmp/ -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">md5sum</span> &#123;&#125; \; &gt; /Documents/checksumdata.out</span><br></pre></td></tr></table></figure>

<h3 id="将-exec-与-grep-命令组合使用"><a href="#将-exec-与-grep-命令组合使用" class="headerlink" title="将 exec 与 grep 命令组合使用"></a>将 exec 与 grep 命令组合使用</h3><p><code>find</code> 命令根据文件名查找，<code>grep</code> 命令可在文件内容中查找。</p>
<p>使用 <code>find</code> 和 <code>grep</code> 以及 <code>exec</code> 命令的组合，就可以得到一个功能强大的搜索工具。</p>
<p>比如下面的命令，搜索扩展名为 <code>.hbs</code> 的文件，然后使用 <code>grep</code>，将在这些文件中，搜索包含字符串 “excerpt” 的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.hbs&quot;</span> -<span class="built_in">exec</span> grep -iH excerpt &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>使用 <code>-H</code> 选项，<code>grep</code> 命令将显示每个匹配的文件名。以下是输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sagar@LHB:~/Downloads/casper-hyvor$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.hbs&quot;</span> -<span class="built_in">exec</span> grep -iH excerpt &#123;&#125; \;</span><br><span class="line">./author.hbs:                &lt;div class=<span class="string">&quot;post-card-excerpt&quot;</span>&gt;&#123;&#123;bio&#125;&#125;&lt;/div&gt;</span><br><span class="line">./partials/post-card.hbs:            &#123;&#123;<span class="comment">#if excerpt&#125;&#125;</span></span><br><span class="line">./partials/post-card.hbs:                &lt;div class=<span class="string">&quot;post-card-excerpt&quot;</span>&gt;&#123;&#123;excerpt&#125;&#125;&lt;/div&gt;</span><br><span class="line">./post.hbs:        &#123;&#123;<span class="comment">#if custom_excerpt&#125;&#125;</span></span><br><span class="line">./post.hbs:            &lt;p class=<span class="string">&quot;article-excerpt&quot;</span>&gt;&#123;&#123;custom_excerpt&#125;&#125;&lt;/p&gt;</span><br><span class="line">./tag.hbs:                &lt;div class=<span class="string">&quot;post-card-excerpt&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用多个-exec-命令"><a href="#使用多个-exec-命令" class="headerlink" title="使用多个 exec 命令"></a>使用多个 exec 命令</h3><p>是的，你可以在单个 <code>find</code> 命令中，组合使用多个 <code>exec</code> 命令。</p>
<p>我们对上一个命令做一下修改，使用两个 exec 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.hbs&quot;</span> -<span class="built_in">exec</span> <span class="built_in">echo</span> &#123;&#125; \; -<span class="built_in">exec</span> grep excerpt &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>上述命令，首先搜索扩展名为 <code>.hbs</code> 的文件，然后第一个 <code>exec</code> 命令用于显示搜索到的文件名称；然后，第二个 <code>exec</code> 命令将在这些文件中搜索包含字符串 “excerpt” 的内容。</p>
<p>其输出与上一个命令略有不同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sagar@LHB:~/Downloads/casper-hyvor$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.hbs&quot;</span> -<span class="built_in">exec</span> <span class="built_in">echo</span> &#123;&#125; \; -<span class="built_in">exec</span> grep excerpt &#123;&#125; \;</span><br><span class="line">./index.hbs</span><br><span class="line">./page.hbs</span><br><span class="line">./default.hbs</span><br><span class="line">./author.hbs</span><br><span class="line">                &lt;div class=<span class="string">&quot;post-card-excerpt&quot;</span>&gt;&#123;&#123;bio&#125;&#125;&lt;/div&gt;</span><br><span class="line">./error-404.hbs</span><br><span class="line">./error.hbs</span><br><span class="line">./partials/icons/twitter.hbs</span><br><span class="line">./partials/icons/fire.hbs</span><br><span class="line">./partials/icons/lock.hbs</span><br><span class="line">./partials/icons/loader.hbs</span><br><span class="line">./partials/icons/rss.hbs</span><br><span class="line">./partials/icons/avatar.hbs</span><br><span class="line">./partials/icons/facebook.hbs</span><br><span class="line">./partials/post-card.hbs</span><br><span class="line">            &#123;&#123;<span class="comment">#if excerpt&#125;&#125;</span></span><br><span class="line">                &lt;div class=<span class="string">&quot;post-card-excerpt&quot;</span>&gt;&#123;&#123;excerpt&#125;&#125;&lt;/div&gt;</span><br><span class="line">./post.hbs</span><br><span class="line">        &#123;&#123;<span class="comment">#if custom_excerpt&#125;&#125;</span></span><br><span class="line">            &lt;p class=<span class="string">&quot;article-excerpt&quot;</span>&gt;&#123;&#123;custom_excerpt&#125;&#125;&lt;/p&gt;</span><br><span class="line">./tag.hbs</span><br><span class="line">                &lt;div class=<span class="string">&quot;post-card-excerpt&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>find 是一个功能强大的命令，用于根据给定条件搜索文件，exec 命令可以让我们很方便的处理 find 命令的输出结果。我们上面介绍的也只是一个大概，在实际应用中使用 find 与 exec 命令的组合，为我们在 Linux 命令行中执行操作提供了无限可能。</p>
<h1 id="管道pipe"><a href="#管道pipe" class="headerlink" title="管道pipe"></a>管道pipe</h1><p>我们在命令行中经常会用到类似 <code>cmd0 | cmd1 | cmd2</code> 的写法。其实，这是管道重定向（pipe redirection），用于将一个命令的输出作为输入重定向到下一个命令。</p>
<p>那么，你知道它具体是怎么工作的吗？今天我们来详细了解一下。</p>
<p>注：本文中会有多个地方使用 Unix 这个术语（而不是Linux），因为管道的概念起源于 Unix。</p>
<h2 id="Linux-中的管道：总体思路"><a href="#Linux-中的管道：总体思路" class="headerlink" title="Linux 中的管道：总体思路"></a>Linux 中的管道：总体思路</h2><p>以下是关于“什么是 Unix 管道？”的内容：</p>
<p><em>Unix 管道是一种 IPC（Inter Process Communication，进程间通信）机制，它将一个程序的输出转发到另一程序的输入。</em></p>
<p>现在，我们换一种更加专业且易懂的语言重新解释一下：</p>
<p><em>Unix 管道是一种 IPC（Inter Process Communication，进程间通信）机制，它接收程序的标准输出（<strong>stdout</strong>），并通过缓冲区将其转发给另一个程序的标准输入（<strong>stdin</strong>）。</em></p>
<p>这样的描述，大家应该能理解了。参考下图可以了解管道的工作原理：</p>
<img data-src="/2024/01/01/189/640.jpeg" class="" title="图片">

<p>管道命令的最简单示例之一是将一些命令输出传递给 grep 命令以搜索特定字符串。</p>
<p>比如，我们可以搜索名称包含txt的文件，如下所示：</p>
<img data-src="/2024/01/01/189/640-20240101130239775.png" class="" title="图片">

<h2 id="管道将标准输出重定向到标准输入，但不是作为命令参数"><a href="#管道将标准输出重定向到标准输入，但不是作为命令参数" class="headerlink" title="管道将标准输出重定向到标准输入，但不是作为命令参数"></a>管道将标准输出重定向到标准输入，但不是作为命令参数</h2><p>有个非常重要的一点需要注意，管道命令将标准输出（stdout）传递到另一个命令的标准输入（stdin），但不是作为参数。下面我们举个例子来说明这一点。</p>
<p>如果我们不带任何参数使用 cat 命令，它默认会从 stdin 读取内容。看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span></span><br><span class="line">Hello, my friend.</span><br><span class="line">^D</span><br><span class="line">Hello, my friend.</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，没有带任何参数使用了 cat，因此它默认会读取 stdin。接下来，我写了一行文字，然后按键 <code>Ctrl+d</code> 告诉它我写完了（<code>Ctrl+d</code> 表示 <code>EOF</code> 或文件结束）。随后，<code>cat</code> 命令读取 <code>stdin</code>，然后把之前我写的那行文字输出到了终端中。</p>
<p>现在，看如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hey | <span class="built_in">cat</span></span><br></pre></td></tr></table></figure>

<p>管道右边的命令并<strong>不等于</strong> <code>cat hey</code>。这里，标准输出（stdout）”hey” 被放在了缓冲区（buffer），并被传输到了 cat 命令的标准输入（stdin）。由于没有命令行参数，所以 cat 默认读取 stdin，而 stdin 中恰好有了内容（即“hey”），因此 cat 读取了这个内容，并将其打印到 stdout。</p>
<p>为了演示这个区别，我们可以创建一个名为 hey 的文件，并在其中添加一些文本。参见下图：</p>
<img data-src="/2024/01/01/189/640-20240101130254698.png" class="" title="图片">

<h2 id="Linux-中的管道类型"><a href="#Linux-中的管道类型" class="headerlink" title="Linux 中的管道类型"></a>Linux 中的管道类型</h2><p>Linux 中有两种类型的管道：</p>
<p>1）匿名管道，也就是未命名管道；</p>
<p>2）命名管道。</p>
<h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>顾名思义，匿名管道就是没有名称。当你使用 <code>|</code> 符号时，它们就会由 Unix shell 动态创建了。</p>
<p>我们通常所说的管道，就是指的匿名管道。它用起来很方便，作为最终用户，我们不需要跟踪它的运行，shell 自动会处理这一切。</p>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>这个稍有不同，命名管道在文件系统中确实存在。它们像普通文件一样存在，可以使用下面的命令创建命名管道：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkfifo</span> pipe</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 <code>pipe</code> 的文件，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l pipe</span><br><span class="line">prw-r--r--. 1 admin admin 0 Aug 4 17:23 pipe</span><br></pre></td></tr></table></figure>

<p>请注意开头的“p”，这意味着该文件是一个管道。现在我们来使用这个管道。</p>
<p>如前所述，管道将命令的输出转发给另一个命令的输入。这就像快递服务，你把包裹从一个地址送到另一个地址。因此，第一步是提供包裹。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hey &gt; pipe</span><br></pre></td></tr></table></figure>

<p>我们会看到 echo 信息没有打印出来，看起来像是被挂起了。新打开一个终端，尝试读取该文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> pipe</span><br></pre></td></tr></table></figure>

<p>我们看下两个终端的输出结果，如下图所示：</p>
<img data-src="/2024/01/01/189/640-20240101130311317.jpeg" class="" title="图片">

<p>惊讶吗？这两个命令同时完成了执行。</p>
<p>这是普通文件和命名管道之间的基本区别之一。在其他进程读取管道之前，不会将任何内容写入管道。</p>
<p>那么，为什么要使用命名管道呢？我们来看一下。</p>
<h2 id="命名管道不会占用磁盘上的任何内存。"><a href="#命名管道不会占用磁盘上的任何内存。" class="headerlink" title="命名管道不会占用磁盘上的任何内存。"></a>命名管道不会占用磁盘上的任何内存。</h2><p>如果我们执行命令 <code>du -s pipe</code>，就会发现它不会占用任何空间。这是因为命名管道就像从内存缓冲区读写的端点。写入命名管道的任何内容实际上都存储在临时内存缓冲区中，当从另一个进程执行读取操作时，该缓冲区将被刷新。</p>
<h2 id="节省-IO"><a href="#节省-IO" class="headerlink" title="节省 IO"></a>节省 IO</h2><p>因为写入命名管道意味着将数据存储到内存中的缓冲区中，因此如果涉及大文件的操作的话，就会大幅减少磁盘 I&#x2F;O。</p>
<h2 id="两个不同进程之间的通信"><a href="#两个不同进程之间的通信" class="headerlink" title="两个不同进程之间的通信"></a>两个不同进程之间的通信</h2><p>通过使用命名管道，可以高效地从另一个进程实时获取事件的输出。因为读和写同时发生，所以没有等待时间。</p>
<h2 id="较低层次的管道理解（针对高级用户和开发人员）"><a href="#较低层次的管道理解（针对高级用户和开发人员）" class="headerlink" title="较低层次的管道理解（针对高级用户和开发人员）"></a>较低层次的管道理解（针对高级用户和开发人员）</h2><p>接下来我们更深入的讨论一下管道，以及具体的实现。这些需要对以下内容有基本的了解：</p>
<ul>
<li>C 程序工作原理；</li>
<li>什么是系统调用；</li>
<li>什么是进程；</li>
<li>什么是文件描述符。</li>
</ul>
<p>我们不会很详细的介绍这些概念，只讨论与管道相关的内容。对于大多数Linux用户来说，下面的内容可以选择性的阅读。</p>
<p>为了进行编译，在文章最后提供了一个示例 makefile。当然，这只是用来说明的伪代码。</p>
<p>看以下程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// pipe.c</span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"></span><br><span class="line">extern int errno;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    signed int fd[2];</span><br><span class="line">    pid_t pid;</span><br><span class="line">    static char input[50];</span><br><span class="line">    static char buf[50];</span><br><span class="line"></span><br><span class="line">    pipe(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==-1)&#123;</span><br><span class="line">        int err=errno;</span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        close(fd[1]);</span><br><span class="line">        <span class="built_in">read</span>(fd[0], buf, 50);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The message read from child: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a message from parent: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i=0; (input[i]=getchar())!=EOF &amp;&amp; input[i]!=<span class="string">&#x27;\n&#x27;</span> &amp;&amp; i&lt;49; i++)</span><br><span class="line">            write(fd[1], input, 50);</span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第16行，我使用 <code>pipe()</code> 函数创建了一个匿名管道，传递了一个长度为 2 的带符号整数数组。</p>
<p>这是因为管道只是一个包含两个无符号整数的数组，代表两个文件描述符。一个用于写，一个用于读。它们都指向内存上的缓冲区位置，通常为1mb。</p>
<p>这里我将变量命名为fd。fd[0] 是输入文件描述符，fd[1] 是输出文件描述符。在该程序中，一个进程将字符串写入 fd[1] 文件描述符，另一个进程从 fd[0] 文件描述符读取。</p>
<p>命名管道也一样，使用命名管道（而不是两个文件描述符），你可以从任何一个进程中打开一个文件，并像其他文件一样对其进行操作。同时应记住管道的特性。</p>
<p>下面是一个示例程序，它执行与前一个程序相同的操作，但它创建的不是匿名管道，而是命名管道：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fifo.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fifo <span class="string">&quot;npipe&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> input[<span class="number">50</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">mknod</span>(fifo, S_IFIFO|<span class="number">0700</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> err=errno;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        fd=<span class="built_in">open</span>(fifo, O_RDONLY);</span><br><span class="line">        <span class="built_in">read</span>(fd, buf, <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The output is : %s&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">remove</span>(fifo);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fd=<span class="built_in">open</span>(fifo, O_WRONLY);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; (input[i]=<span class="built_in">getchar</span>())!=EOF &amp;&amp; input[i]!=<span class="string">&#x27;\n&#x27;</span> &amp;&amp; i&lt;<span class="number">49</span>; i++);</span><br><span class="line">        <span class="built_in">write</span>(fd, input, <span class="built_in">strlen</span>(input));</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我使用 <code>mknod</code> 系统调用来创建命名管道。如你所见，虽然在完成时删除了管道，但你可以不使用它，只需要打开并写入本例中的 npipe 文件，就可以轻松的实现在不同进程之间的通信。</p>
<p>其实现实中，我们也不必创建两个管道来实现双向通信，匿名管道就是这样的。</p>
<p>以下是一个简单的 Makefile 的源代码示例（只是示例），将其与前面的程序放在同一个目录中（分别为 pipe.c 和 fifo.c）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS?=-Wall -g -O2 -Werror</span><br><span class="line">CC?=clang</span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">    $(CC) $(CFLAGS) -o pipe pipe.c</span><br><span class="line">    $(CC) $(CFLAGS) -o fifo fifo.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -rf pipe fifo</span><br></pre></td></tr></table></figure>

<h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><h2 id="什么是-xargs-命令"><a href="#什么是-xargs-命令" class="headerlink" title="什么是 xargs 命令"></a>什么是 xargs 命令</h2><p>xargs命令从标准输入或另一个命令的输出中读取文本行，并将其转换为命令并执行。</p>
<p>我们经常会看到 xargs 命令与 find 命令一起使用。find 命令提供文件名列表，xargs 命令可以让我们逐个使用这些文件名，把它们当作是另一个命令的输入一样使用。</p>
<p>由于 rargs 会处理重定向，所以你需要提前了解关于标准输入、输出以及管道重定向相关的知识。关于管道重定向，可以参考<a href="#%E7%AE%A1%E9%81%93pipe">这里</a>。</p>
<h2 id="怎样使用-xargs-命令"><a href="#怎样使用-xargs-命令" class="headerlink" title="怎样使用 xargs 命令"></a>怎样使用 xargs 命令</h2><p>xargs 命令的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xargs [options] [<span class="built_in">command</span> [initial-arguments]]</span><br></pre></td></tr></table></figure>

<p>但一般我们不这样用，它的一个重要功能是将一个命令的输出组合到另一个命令中。我们看一个例子：</p>
<p>假如在当前路径下有一些txt文件，以各种鲜花名称命名，然后还有一个flowers.txt，记录了所有这些txt文件的名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">ls</span></span><br><span class="line">flowers.txt  lily.txt  one_lotus.txt  rose.txt  three_lotus.txt  two_lotus.txt</span><br><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> flowers.txt </span><br><span class="line">lily.txt</span><br><span class="line">one_lotus.txt</span><br><span class="line">rose.txt</span><br><span class="line">three_lotus.txt</span><br><span class="line">two_lotus.txt</span><br></pre></td></tr></table></figure>

<p>现在我们的目标是查看 flowers.txt 中提到的所有文件的文件大小。根据以往的经验，我们可以使用 cat 命令来显示所有文件名，然后通过管道将其传输到 du 命令来检查文件大小。</p>
<p>但是如果我们直接使用管道的话，它不会给出 flowers.txt 中提到的每个文件的大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">du</span> -h52K.[admin@fedora work]$ <span class="built_in">cat</span> flowers.txt | <span class="built_in">du</span> -h52K.</span><br></pre></td></tr></table></figure>

<p>为什么呢？首先，du 命令不接受标准输入；其次，cat 命令的输出不是单个的文件名，而是由换行符隔开的一个文本。</p>
<p>而 xargs 命令的神奇之处在于，它将把这个由空格或换行符分割的文本转换为下一个命令的单独输入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">cat</span> flowers.txt | xargs <span class="built_in">du</span> -h</span><br><span class="line">4.0Klily.txt</span><br><span class="line">4.0Kone_lotus.txt</span><br><span class="line">16Krose.txt</span><br><span class="line">4.0Kthree_lotus.txt</span><br><span class="line">16Ktwo_lotus.txt</span><br></pre></td></tr></table></figure>

<p>这相当于将这些文件名提供给 du 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ <span class="built_in">du</span> -h lily.txt one_lotus.txt rose.txt three_lotus.txt two_lotus.txt </span><br><span class="line">4.0Klily.txt</span><br><span class="line">4.0Kone_lotus.txt</span><br><span class="line">16Krose.txt</span><br><span class="line">4.0Kthree_lotus.txt</span><br><span class="line">16Ktwo_lotus.txt</span><br></pre></td></tr></table></figure>

<p>怎么样，意识到 xargs 命令的强大了吗？</p>
<h2 id="xargs-和-find：为彼此而存在"><a href="#xargs-和-find：为彼此而存在" class="headerlink" title="xargs 和 find：为彼此而存在"></a>xargs 和 find：为彼此而存在</h2><p>xargs 命令经常和 find 命令结合使用。</p>
<p>find 命令搜索文件和目录并返回它们的名称，有了 xargs 命令，你就可以将 find 命令的结果用于特定目的，如重命名、移动、删除等等。</p>
<p>比如，我们要搜索所有包含 red 一词的txt文件，可以在 xargs 的帮助下结合 find 和</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep 命令：</span><br><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs grep -l red</span><br><span class="line">./three_lotus.txt</span><br><span class="line">./two_lotus.txt</span><br><span class="line">./rose.txt</span><br></pre></td></tr></table></figure>

<p>find 与 exec 命令组合的工作原理类似。不过我们今天只集中讨论 xargs 命令。</p>
<h2 id="处理文件名中带有空格的文件"><a href="#处理文件名中带有空格的文件" class="headerlink" title="处理文件名中带有空格的文件"></a>处理文件名中带有空格的文件</h2><p>如果文件名中有空格，会稍微麻烦点。比如我们将上面的文件three_lotus.txt重命名为 three lotus.txt，那么当使用 xargs 处理时，会被认为是两个独立的文件，three 和 lotus.txt：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs grep -l red</span><br><span class="line">./two_lotus.txt</span><br><span class="line">grep: ./three: No such file or directory</span><br><span class="line">grep: lotus.txt: No such file or directory</span><br><span class="line">./rose.txt</span><br></pre></td></tr></table></figure>

<p>在这种情况下，可以使用 find 命令的 <code>-print0</code> 选项，它使用 ASCII null 字符来换行，而不是换行符；同时，xargs 命令也需要带 <code>-0</code> 选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -print0 -name <span class="string">&quot;*.txt&quot;</span> | xargs -0 grep -l red./two_lotus.txt./three lotus.txt./rose.txt</span><br></pre></td></tr></table></figure>

<h2 id="查看正在执行的命令"><a href="#查看正在执行的命令" class="headerlink" title="查看正在执行的命令"></a>查看正在执行的命令</h2><p>xargs 命令的 <code>-t</code> 选项，会打印正在执行的实际命令，所以可以用来查看正在执行的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs -t <span class="built_in">touch</span></span><br><span class="line"><span class="built_in">touch</span> ./three_lotus.txt ./two_lotus.txt ./lily.txt ./rose.txt</span><br></pre></td></tr></table></figure>

<h2 id="在运行命令之前，强制-xargs-提示确认"><a href="#在运行命令之前，强制-xargs-提示确认" class="headerlink" title="在运行命令之前，强制 xargs 提示确认"></a>在运行命令之前，强制 xargs 提示确认</h2><p>有些情况需要格外小心，比如删除文件，最好看看要执行什么命令，必要的话可以选择拒绝执行。</p>
<p>可以使用 <code>-p</code> 选项，在执行前进行确认：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs -p <span class="built_in">rm</span></span><br><span class="line"><span class="built_in">rm</span> ./three_lotus.txt ./two_lotus.txt ./lily.txt ./rose.txt ?...n</span><br></pre></td></tr></table></figure>

<h2 id="结合占位符的使用"><a href="#结合占位符的使用" class="headerlink" title="结合占位符的使用"></a>结合占位符的使用</h2><p>默认情况下，xargs命令将标准输入作为参数添加到命令末尾。当需要在最后一个参数之前使用时，这会产生问题。</p>
<p>比如，使用 move 命令，首先需要一个源，然后需要一个目标作为参数；如果要将找到的文件移动的目标文件，那么将不起作用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs -p <span class="built_in">mv</span> new_dir</span><br><span class="line"><span class="built_in">mv</span> new_dir ./three_lotus.txt ./two_lotus.txt ./lily.txt ./rose.txt ?...y</span><br><span class="line"><span class="built_in">mv</span>: target <span class="string">&#x27;./rose.txt&#x27;</span> is not a directory</span><br></pre></td></tr></table></figure>

<p>这时候，可以用 <code>-I</code> 选项来使用占位符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs -p -I &#123;&#125; <span class="built_in">mv</span> &#123;&#125; new_dir</span><br><span class="line"><span class="built_in">mv</span> ./three_lotus.txt new_dir ?...n</span><br><span class="line"><span class="built_in">mv</span> ./two_lotus.txt new_dir ?...n</span><br><span class="line"><span class="built_in">mv</span> ./lily.txt new_dir ?...n</span><br><span class="line"><span class="built_in">mv</span> ./rose.txt new_dir ?...n</span><br></pre></td></tr></table></figure>

<p>上述命令中，xargs 从 find 命令中获取所有的文件名，将其保存在 {} 中，然后转到 mv 命令并提供 {} 中的内容。</p>
<p>这里有一个主要的区别，它不是将所有文件名放在同一个命令中，而是逐个添加。这就是每个参数都会单独调用 mv 命令的原因。</p>
<p>注：上述命令中使用 <code>&#123;&#125;</code> 作为占位符，你可以使用其他字符作为占位符。<code>&#123;&#125;</code> 是安全的，易于理解和区分。</p>
<h2 id="使用xargs运行多个命令"><a href="#使用xargs运行多个命令" class="headerlink" title="使用xargs运行多个命令"></a>使用xargs运行多个命令</h2><p>可以使用 xargs 的占位符来运行多个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora work]$ find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> | xargs -I &#123;&#125; sh -c <span class="string">&#x27;ls -l &#123;&#125;; du -h &#123;&#125;&#x27;</span> </span><br><span class="line">-rw-rw-r-- 1 admin admin 0 May 28 17:02 ./three_lotus.txt</span><br><span class="line">0./three_lotus.txt</span><br><span class="line">-rw-rw-r-- 1 admin admin 0 May 28 17:02 ./two_lotus.txt</span><br><span class="line">0./two_lotus.txt</span><br><span class="line">-rw-rw-r-- 1 admin admin 0 May 28 17:02 ./lily.txt</span><br><span class="line">0./lily.txt</span><br><span class="line">-rw-rw-r-- 1 admin admin 0 May 28 17:02 ./rose.txt</span><br><span class="line">0./rose.txt</span><br></pre></td></tr></table></figure>

<p>这里需要注意下，占位符不会扩展到下一个管道重定向或者其他命令，这就是上述命令中为什么会使用 sh 命令的原因。</p>
<p>本文主要介绍了常用的 find 和 xargs 命令的使用，但 xargs 命令不是仅限于和find一起用。xargs 命令的一个很实际的例子是当要停止所有正在运行的 docker 容器时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -q | xargs docker stop</span><br></pre></td></tr></table></figure>

<p>与其他 Linux 命令一样，xargs 也有很多选项。关于详细信息，大家可以查阅 xargs 命令的 man 手册。</p>
<h1 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h1><p>我们在 Linux 命令中经常会用到引号，比如处理文件名中的空格，或者处理特殊字符的时候。</p>
<p>本文将介绍不同类型的引号及其在 shell 脚本中的用法。</p>
<p>总结一下，大概有四种类型的引号：</p>
<ul>
<li>单引号：&#39;</li>
<li>双引号：&quot;</li>
<li>反斜杠：\</li>
<li>反引号：`</li>
</ul>
<p>除了反斜杠以外，其余三个都是成对出现。下面我们来详细看一下。</p>
<h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><p>shell 会忽略单引号中所有的特殊字符，其中的所有内容都会被当作一个元素。</p>
<p>我们举个例子，假如有一个文本文件，里面记录了一些人名，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> cricket </span><br><span class="line">Allan Donald, South Africa</span><br><span class="line">Steve Waugh, Australia</span><br><span class="line">Mark Waugh, Australia</span><br><span class="line">Henry Olonga, Zimbabwe</span><br><span class="line">Sachin Tendulkar, India</span><br></pre></td></tr></table></figure>

<p>现在我们使用 grep 命令在其中搜索 “Waugh”，会得到两个结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep Waugh cricket</span><br><span class="line">Steve Waugh, Australia</span><br><span class="line">Mark Waugh, Australia</span><br></pre></td></tr></table></figure>

<p>但是如果我们更精确一点，搜索 Steve Waugh，就会出现错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep Steve Waugh cricket</span><br><span class="line">grep: Waugh: No such file or directory</span><br><span class="line">cricket:Steve Waugh, Australia</span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？因为<strong>空格在命令行中用于分割命令、选项和参数</strong>。在上面的例子中，我们原本是要搜索 Steve Waugh，但 shell 会将 Steve 作为 grep 的第一个参数，然后将 Waugh 和 cricket 作为被搜索的文件，很显然，没有 Waugh 这个文件，所以就报错了。同时，输出中显示了文件 cricket 的结果。</p>
<p>如果我们使用单引号，来搜索 ‘Steve Waugh’，它会被视为一个整体，那这样就得到了我们期望的搜索结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">&#x27;Steve Waugh&#x27;</span> cricket</span><br><span class="line">Steve Waugh, Australia</span><br></pre></td></tr></table></figure>

<p>基本上，***<u>当shell看到第一个单引号时，它会忽略任何特殊字符（空格也是一个特殊字符），直到找到另一个单引号（右引号）</u>***。</p>
<h2 id="忽略所有特殊字符"><a href="#忽略所有特殊字符" class="headerlink" title="忽略所有特殊字符"></a>忽略所有特殊字符</h2><p>如果用单引号引起来，所有特殊字符都会失去其原本的意义。下面我们举几个例子。</p>
<p>我们在shell中声明一个变量，如果用<code>$</code>回显变量名，它将显示变量的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var=my_variable</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">my_variable</span><br></pre></td></tr></table></figure>

<p>但如果用单引号引起来，<code>$</code> 将失去其特殊的功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;$var&#x27;</span><span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>另一个例子，回车键（回车字符）也放在单引号里面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;how are</span></span><br><span class="line"><span class="string">&gt; you?&#x27;</span></span><br><span class="line">how are</span><br><span class="line">you?</span><br></pre></td></tr></table></figure>

<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>双引号几乎与单引号相似。这里之所以说“几乎”是因为他们也会忽略所有特殊字符，除了：</p>
<ul>
<li>美元符号：$</li>
<li>反引号：`</li>
<li>反斜杠：\</li>
</ul>
<p>由于美元符号 <code>$</code> 不会被忽略，所以我们可以使用变量名，得到变量的值；但是单引号就不能这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ var=my_variable</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span></span><br><span class="line">my_variable</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;$var&#x27;</span></span><br><span class="line"><span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>双引号还可用于在shell中转义单引号（即将其转义为普通字符）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ var=My <span class="string">&#x27;own villa&#x27;</span> is yellow</span><br><span class="line">own villa: <span class="built_in">command</span> not found</span><br><span class="line">$ var=<span class="string">&quot;My &#x27;own villa&#x27; is yellow&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">My <span class="string">&#x27;own villa&#x27;</span> is yellow</span><br></pre></td></tr></table></figure>

<p>反过来用（用单引号转义双引号），也可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ var=he said, <span class="string">&quot;Awesome!&quot;</span></span><br><span class="line">said,: <span class="built_in">command</span> not found</span><br><span class="line">$ var=<span class="string">&#x27;he said, &quot;Awesome!&quot;&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">he said, <span class="string">&quot;Awesome!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h2><p>反斜杠用于转义特殊字符。看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ var=variable</span><br><span class="line">$ <span class="built_in">echo</span> \var</span><br><span class="line">var</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">variable</span><br><span class="line">$ <span class="built_in">echo</span> \<span class="variable">$var</span></span><br><span class="line"><span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>因为 v 没有什么特别的含义，<code>echo \var</code> 只是简单的打印了 <code>var</code>。另一方面，当使用 <code>$var</code> 的时候，反斜杠转义了 <code>$</code> 符号，所以打印出了 <code>$var</code>。</p>
<h2 id="用反斜杠转义换行符"><a href="#用反斜杠转义换行符" class="headerlink" title="用反斜杠转义换行符"></a>用反斜杠转义换行符</h2><p>我们可以使用<strong>反斜杠来转义换行符</strong>，这样就可以<u>将单个命令换行继续编写</u>。</p>
<p>当命令太长或是多个命令的组合时，你会看到一些网站使用反斜杠在多行中显示单个命令。这可以使命令或代码更具可读性。</p>
<p>看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name server --network net -v html:/usr/share/nginx/html -v <span class="variable">$PWD</span>/custom-config.conf:/etc/nginx/nginx.conf -p 80:80 --restart on-failure -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>现在我们使用反斜杠，将上述命令分解为多行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name server --network net \</span><br><span class="line">-v html:/usr/share/nginx/html \</span><br><span class="line">-v <span class="variable">$PWD</span>/custom-config.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-p 80:80 --restart on-failure -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>这样看起来容易多了。</p>
<h2 id="双引号内的反斜杠"><a href="#双引号内的反斜杠" class="headerlink" title="双引号内的反斜杠"></a>双引号内的反斜杠</h2><p>在双引号内，\ （反斜杠）、$ （美元符号）以及 ` （反引号）是不被转义的三个符号。</p>
<p>这样的话，我们就可以使用反斜杠来转义双引号中的美元符号、双引号以及反引号了。</p>
<p>看下面的例子，其中的 <code>$5</code> 会被认为是一个未声明的变量，且没有被赋值，所以在 echo 命令中会将其忽略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Meal costs <span class="variable">$5</span>.25&quot;</span></span><br><span class="line">Meal costs .25</span><br></pre></td></tr></table></figure>

<p>要避免上述情况，可以使用 <code>\</code> 来转义 <code>$</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Meal costs \$5.25&quot;</span></span><br><span class="line">Meal costs <span class="variable">$5</span>.25</span><br></pre></td></tr></table></figure>

<h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h2><p>反引号（ ` ）有一个特殊含义，用于<strong>命令替换</strong>。</p>
<p>Shell 具有此命令替换功能，其中指定的命令将替换为命令的输出。</p>
<p>在下面的例子中，<code>date</code> 会被替换为 <code>date</code> 命令的输出信息，即系统的当前日期和时间而输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> The current <span class="built_in">date</span> and time is `<span class="built_in">date</span>`</span><br><span class="line">The current <span class="built_in">date</span> and time is Monday 23 August 2021 04:55:18 PM IST</span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，<strong>只有当反引号之间是一个命令的时候，才会进行替换，否则，将会按原内容显示</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;The current date and time is `late`&#x27;</span></span><br><span class="line">The current <span class="built_in">date</span> and time is `late`</span><br></pre></td></tr></table></figure>

<p>如前文所述，将反引号放在双引号中，不会被转义，但是放在单引号中，会被转义为普通字符。</p>
<h2 id="反引号不在建议使用"><a href="#反引号不在建议使用" class="headerlink" title="反引号不在建议使用"></a>反引号不在建议使用</h2><p>很长时间以来，反引号都用于 Shell 脚本中的命令替换，但是现在，现代 Unix 和 Linux 系统更提倡使用 <code>$(command)</code> 结构，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> The current <span class="built_in">date</span> and time is $(<span class="built_in">date</span>)</span><br><span class="line">The current <span class="built_in">date</span> and time is Monday 23 August 2021 05:55:47 PM IST</span><br></pre></td></tr></table></figure>

<p>所以，反引号已经不再使用了。</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>环境变量取决于某些特定的环境，是特定于当前系统环境的变量，比如，当前登录的用户存储在 USER 变量中。</p>
<h2 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h2><p>环境变量与你的桌面环境无关。</p>
<p><code>HOSTNAME</code> 是我们遇到的最基本的环境变量之一，一般情况下它的拼写字母是大写的，为什么会这样呢？</p>
<p>因为大多数环境变量都是由系统预定义的，并且是全局变量，所以它们通常都是用大写字母书写的。</p>
<p>那么，为什么首先要使用环境变量呢？</p>
<p>假设你是一名程序员，并且你的代码需要访问你的数据库密钥，该密钥不应公开共享。</p>
<p>那么，如果将代码共享到 <code>git</code>  上的时候，应该怎样避免密码泄露呢？一般的做法是，将数据库密钥封装为环境变量。</p>
<p>通过这种方式，将 <code>git</code> 上的指令设置为“如果要使代码正常运行，需要用数据库密钥来替换此变量”。</p>
<p>当然，这是使用环境变量的一种方式，下面是Linux系统中常见的一些环境变量：</p>
<blockquote>
<p>注: 下面的变量不一定存在, 具体是什么, 使用 <code>env</code> 查看</p>
</blockquote>
<table>
<thead>
<tr>
<th>**环境变量 **</th>
<th>**描述 **</th>
</tr>
</thead>
<tbody><tr>
<td><code>HOME</code></td>
<td>显示当前用户主目录</td>
</tr>
<tr>
<td><code>HOST</code> 或 <code>HOSTNAME</code></td>
<td>系统的主机名, 通常存储在<code>/etc/hostname</code>文件中</td>
</tr>
<tr>
<td><code>USER</code> 或 <code>LOGNAME</code></td>
<td>当前登录用户的用户名</td>
</tr>
<tr>
<td><code>LANG</code></td>
<td>指定系统默认的语言设置</td>
</tr>
<tr>
<td><code>PWD</code></td>
<td>显示当前工作目录的路径</td>
</tr>
<tr>
<td><code>UID</code></td>
<td>存储用户的唯一ID</td>
</tr>
<tr>
<td><code>SHELL</code></td>
<td>显示当前正在使用的 shell 路径</td>
</tr>
<tr>
<td><code>BASH_VERSION</code></td>
<td>当前使用的 bash 实例的版本</td>
</tr>
<tr>
<td><code>HISTFILE</code></td>
<td>保存命令历史记录的文件路径</td>
</tr>
<tr>
<td><code>TERM</code></td>
<td>显示正在使用的终端类型</td>
</tr>
<tr>
<td><code>PATH</code></td>
<td>显示已列分割的文件和目录的路径</td>
</tr>
<tr>
<td><code>TMP</code> 或 <code>TEMP</code></td>
<td>指定临时文件的存储路径</td>
</tr>
<tr>
<td><code>LD_LIBRARY_PATH</code></td>
<td>指定动态链接库的搜索路径</td>
</tr>
<tr>
<td><code>PS1</code></td>
<td>定义命令行提示符的格式</td>
</tr>
</tbody></table>
<h2 id="打印环境变量"><a href="#打印环境变量" class="headerlink" title="打印环境变量"></a>打印环境变量</h2><p>在 Linux 中有多种方法来打印环境变量，我们从最简单的方式开始。</p>
<h3 id="使用-printenv-命令"><a href="#使用-printenv-命令" class="headerlink" title="使用 printenv 命令"></a>使用 printenv 命令</h3><p><code>printenv</code> 程序用于打印当前 shell 的环境变量。</p>
<p>假如我们要使用 <code>printenv</code> 打印 <code>USERNAME</code> 变量的值，那么命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printenv</span> USERNAME</span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200509.png" class="" title="图片">

<p>同样，可以使用 <code>printenv</code> 打印多个环境变量，使用空格分割，比如，使用 <code>printenv</code> 打印 <code>HOME</code> 和 <code>USERNAME</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printenv</span> HOME USERNAME</span><br></pre></td></tr></table></figure>

<p>上述命令，首先会打印当前登录用户的主目录，然后第二行显示主机名，如下图所示：</p>
<img data-src="/2024/01/01/189/640-20240115083200583.png" class="" title="图片">

<p>那么，如何打印当前 shell 中所有可用环境变量呢？只需要运行 <code>printenv</code> 命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printenv</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200615.png" class="" title="图片">

<h3 id="使用-echo-命令"><a href="#使用-echo-命令" class="headerlink" title="使用 echo 命令"></a>使用 echo 命令</h3><p>经常使用 Linux 的用户会比较习惯使用 <code>echo</code> 命令。比如，如下命令将会打印 <code>USERNAME</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$USERNAME</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200592.png" class="" title="图片">

<p>那么，使用 <code>echo</code> 命令打印多个环境变量该怎么做呢？使用如下语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;$&lt;variable 1&gt; \n&lt;variable 2&gt; \n&lt;variable 3&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>比如，使用如下命令同时打印 <code>HOME</code>, <code>USERNAME</code>, <code>HOSTNAME</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$USERNAME</span> \n<span class="variable">$HOME</span> \n<span class="variable">$HOSTNAME</span>&quot;</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200574.png" class="" title="图片">

<h3 id="使用-env-命令"><a href="#使用-env-命令" class="headerlink" title="使用 env 命令"></a>使用 env 命令</h3><p>shell 脚本通常使用 <code>env</code> 命令启动正确的解释器，但我们也可以使用 <code>env</code> 指令列出可用的环境变量。</p>
<p>使用不带任何参数的 <code>env</code> 命令，会打印所有可用的环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">env</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200590.png" class="" title="图片">

<p>那么，如果想要获取某个特定环境变量的值，需要怎样做呢？可以使用 <code>grep</code> 来对结果进行过滤。下面我们演示如何打印 <code>HOME</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">env</span> | grep HOME</span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200567.png" class="" title="图片">

<h3 id="使用-declare-命令"><a href="#使用-declare-命令" class="headerlink" title="使用 declare 命令"></a>使用 declare 命令</h3><p><code>declare</code> 命令用于声明和打印shell中变量的值。与上面介绍的其他命令一样，不带任何参数的使用 <code>declare</code> 命令会打印出所有可用的环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200686.png" class="" title="图片">

<p>前面我们使用过grep过滤结果，其实，可以使用它来过滤多个结果，语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> | grep <span class="string">&#x27;&lt;variable 1&gt;\|&lt;variable 2&gt;\|&lt;variable 3&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面命令打印 <code>HOSTNAME</code> 和 <code>USERNAME</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> | grep <span class="string">&#x27;HOSTNAME\|USERNAME&#x27;</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200630.png" class="" title="图片">

<h3 id="使用-set-命令"><a href="#使用-set-命令" class="headerlink" title="使用 set 命令"></a>使用 set 命令</h3><p>通常，<code>set</code> 命令用于在 shell 中设置或者取消设置配置项，以设置进程信息。除此以外，<code>set</code> 命令也可以用来打印当前 shell 的环境变量。如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200655.png" class="" title="图片">

<p>同样可以使用 grep 来过滤 set 命令的结果。下面的例子展示如何使用 <code>grep</code> 命令打印多个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> | grep <span class="string">&#x27;HISTFILESIZE\|HISTFILE\|GNOME_SHELL_SESSION_MODE&#x27;</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115083200656.png" class="" title="图片">

<p>以上我们介绍了打印环境变量的多个方法，但是建议使用第一种方法，因为它的语法最简单。</p>
<h2 id="使用-envsubst-命令替换环境变量"><a href="#使用-envsubst-命令替换环境变量" class="headerlink" title="使用 envsubst 命令替换环境变量"></a>使用 envsubst 命令替换环境变量</h2><p>在写脚本或者运行脚本的时候，很多时候都会用到环境变量，不过有时候使用的变量可能会带来安全风险。所以这时候我们可以使用 envsubst 来代替环境变量。</p>
<p>envsubst 命令用于获取环境变量的替代项（可能这就是这个命令名称的由来：environment substitute）。</p>
<p>但是它不会直接改变环境变量，首先会根据模式查找变量（比如 <code>$VARIABLE</code> 或者 <code>[$VARIABLE]</code>）；然后，它会用一个 bash 变量替换找到的环境变量。</p>
<blockquote>
<p>注意：envsubst 命令只识别导出的变量（exported variables）。</p>
</blockquote>
<p>使用 envsubst 命令替换环境变量，可参考如下语法模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envsubst [OPTION] [SHELL-FORMAT]</span><br></pre></td></tr></table></figure>

<p>接下来我们来看看具体怎么做。</p>
<p>首先我们准备一个文本文件，比如将其命名为 confidential.txt，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A sample file containg password and username!</span><br><span class="line"></span><br><span class="line">And should not be shared by any means.</span><br><span class="line"></span><br><span class="line">My loging credentials are:</span><br><span class="line"></span><br><span class="line">        username=<span class="variable">$USERNAME</span></span><br><span class="line">        password=<span class="variable">$PASSWORD</span></span><br></pre></td></tr></table></figure>

<p>然后，为了替换 <code>$USERNAME</code> 和 <code>$PASSWORD</code>，我们首先创建并导出两个变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> USERNAME=abhiman</span><br><span class="line"><span class="built_in">export</span> PASSWORD=strongphrase</span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240116074005713.png" class="" title="图片">

<p>导出变量值后，可以为创建的文件调用 <code>envsubst</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envsubst &lt; confidential.txt</span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240116074005736.png" class="" title="图片">

<p>如上图所示，变量的值已经被改变了。</p>
<p>另外，还可以使用 unset 命令取消变量值的设置。首先，<code>unset</code> 使用 <code>export</code> 命令设置的变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> USERNAME PASSWORD</span><br></pre></td></tr></table></figure>

<p>现在，再次运行 <code>envsubst</code> 命令，可看到变量的值已经没有了：</p>
<img data-src="/2024/01/01/189/640-20240116074005706.png" class="" title="图片">

<p>因为 <code>envsubst</code> 命令只适用于导出的变量，当我们使用 <code>unset</code> 命令的时候，将变量的值设置为了 <code>null</code>。然后当 <code>envsubst</code> 命令找不到要替换的值的时候，就会出现空内容。</p>
<h3 id="将输出重定向到特定文件"><a href="#将输出重定向到特定文件" class="headerlink" title="将输出重定向到特定文件"></a>将输出重定向到特定文件</h3><p>我们可以选择将输出重定向到某个文件，以保存输出内容，可使用重定向符号 <code>&gt;</code> 来实现。比如，我们将上述输出重定向到 Output.txt：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envsubst &lt; confidential.txt &gt; Output.txt</span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240116074005738.png" class="" title="图片">

<h3 id="以-shell-的方式替换-envsubst-命令中的特定变量"><a href="#以-shell-的方式替换-envsubst-命令中的特定变量" class="headerlink" title="以 shell 的方式替换 envsubst 命令中的特定变量"></a>以 shell 的方式替换 envsubst 命令中的特定变量</h3><p>假如你导出了多个环境变量，但是只想替换其中的一小部分。这种情况下，可以使用 shell 的方式来实现。</p>
<p>其语法非常灵活，只需要在单引号 <code>&#39;&#39;</code> 中指定变量即可，可通过多种方式使用它，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envsubst <span class="string">&#x27;$variable&#x27;</span> &gt; file</span><br></pre></td></tr></table></figure>

<p>或者添加多个变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envsubst <span class="string">&#x27;$variable1 $variable1 $variable3&#x27;</span> &gt; file</span><br></pre></td></tr></table></figure>

<p>也可以添加文本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envsubst <span class="string">&#x27;subsitute the $variable1 and $variable2&#x27;</span> &gt; file</span><br></pre></td></tr></table></figure>

<p>下面这个例子，我们使用一个名为 Substitute.txt 的文本文件，其内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello, My name is <span class="variable">$USER</span>.</span><br><span class="line"></span><br><span class="line">And these are login credentials <span class="keyword">for</span> <span class="variable">$SERVICE</span>:</span><br><span class="line"></span><br><span class="line">        username=<span class="variable">$USERNAME</span></span><br><span class="line">        password=<span class="variable">$PASSWORD</span></span><br><span class="line"></span><br><span class="line">Not meant <span class="keyword">for</span> public use!</span><br></pre></td></tr></table></figure>

<p>接下来，我将导出上面文件中使用的每个变量的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> USER=sagar <span class="built_in">export</span> SERVICE=AWS <span class="built_in">export</span> USERNAME=LHB <span class="built_in">export</span> PASSWORD=randomphrase  </span><br></pre></td></tr></table></figure>

<p>在不替换任何特定变量的情况下，它应该会得到以下输出：</p>
<img data-src="/2024/01/01/189/640-20240116074005759.png" class="" title="图片">

<p>如果我只希望 <code>$USER</code> 和 <code>$SERVICE</code> 的值反映在输出中，可使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envsubst <span class="string">&#x27;$USER $SERVICE&#x27;</span> &lt; Substitute.txt</span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240116074005721.png" class="" title="图片">

<p>如上图所示，输出只显示了 <code>$USER</code> 和 <code>$SERVICE</code> 的值，但是 <code>$USERNAME</code> 和 <code>$PASSWORD</code> 仍旧保持原值。</p>
<h2 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h2><p>无论您是使用Linux、BSD还是macOS，编辑 <code>$PATH</code> 对于任何 POSIX 初学者来说都是一项重要的技能。</p>
<p>当你在Linux系统的终端中输入一个命令的时候，所有你的操作都是运行一个程序。比如 ls, mkdir, rm 等，通常是存储在<code>/usr/bin</code>目录中的小程序。除此之外，其他地方也存储有可执行程序，比如：<code>/usr/local/bin</code>, <code>/usr/local/sbin</code> 和 <code>/usr/sbin</code>。可执行程序为什么会在这些目录中不在本文的讨论范围内，但是你需要知道，<strong>可执行程序的存储位置不会局限于其中一个目录</strong>。</p>
<p>当您在 Linux shell 中键入命令时，它不会在每个目录中查找是否有同名程序。它只看你指定的那些。它如何知道在上面提到的目录中查找？很简单：它们是名为 <code>$PATH</code> 的环境变量的一部分，您的shell检查该变量以知道在哪里查找。</p>
<h3 id="查看-PATH"><a href="#查看-PATH" class="headerlink" title="查看 PATH"></a>查看 PATH</h3><p>有时候，你可能希望将程序安装到计算机的其他位置，但是运行程序的时候不希望指定程序的确切位置。这时候可以通过在<code>$PATH</code>中添加一个环境变量来实现。要查看当前 $PATH 中的内容，需要在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>这样你可以在上面看到一些目录，这些目录就是保存可执行程序的位置，他们之间使用<strong>冒号分隔</strong>。那现在我们添加一些其他的目录。</p>
<h3 id="设置临时-PATH-变量"><a href="#设置临时-PATH-变量" class="headerlink" title="设置临时 PATH 变量"></a>设置临时 PATH 变量</h3><p>假设你编写了一个名为hello.sh的shell脚本，并将其放在名为 <code>/place/with/the/file</code> 的目录中。这个脚本为当前目录中的所有文件提供了一些有用的函数，无论你当前在哪个目录中，都希望能够执行这些函数。</p>
<p>只需执行以下命令将 <code>/place/with/the/file</code> 添加到 $PATH 变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/place/with/the/file</span><br></pre></td></tr></table></figure>

<p>现在，只要输入脚本的名称，就可以在系统的任何地方执行脚本，而不必在命令中包含完整路径。</p>
<h3 id="设置永久-PATH-变量"><a href="#设置永久-PATH-变量" class="headerlink" title="设置永久 PATH 变量"></a>设置永久 PATH 变量</h3><p>以上命令是设置了一个临时的环境变量，当机器重启后，就不起作用了。变量 <code>$PATH</code> 由shell在每次启动时设置，但是你可以对其重新设置，以便每次打开新shell时都包含你设置的路径。具体的方法取决于你运行的是哪个shell。</p>
<p>如果你使用的是普通的Linux发行版，并且没有修改过默认值的话，一般运行的是bash。要查看运行的是哪个shell，可以通过以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br></pre></td></tr></table></figure>

<p>这样一个echo命令后面跟着一个 <code>$0</code>,如果是bash，你就会看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">-bash</span><br></pre></td></tr></table></figure>

<p>对于bash，只需要将上面的 <code>export PATH=$PATH:/place/with/the/file</code> 添加到shell启动时要执行的文件，比如 <code>~/.bash_profile</code>、<code>~/.bashrc</code> 或 <code>~/.profile</code>，如果你不确定放在那里，那就放在 <code>~/.bashrc</code> 里面吧。</p>
<p>对于其他shell，您需要先找到适当的位置来配置；ksh配置通常出现在<code>~/.kshrc</code>中，zsh使用 <code>~/.zshrc</code> 。可以先检查shell的说明文档来确定配置文件的位置。</p>
<h1 id="apropos"><a href="#apropos" class="headerlink" title="apropos"></a>apropos</h1><p>使用 apropos 搜索可用的 Linux 命令.</p>
<p>如果你使用过某个命令，（当再次用的时候）却想不起具体名称了。</p>
<p>（这种情况下）可以在终端中使用 <code>ctrl + r</code> 快捷键，反向搜索 shell 历史记录。</p>
<p>如果你在同一个系统上使用过该命令，那么上述方法是可以的。但是，如果你在其他的Linux系统上使用的，或者只是在某个论坛或网站上偶然看到过，该怎么办呢？</p>
<p>好消息是，有一个专用的 Linux 命令，允许你在系统可用的命令中，使用字符串进行搜索。</p>
<h2 id="使用-apropos-搜索-Linux-命令"><a href="#使用-apropos-搜索-Linux-命令" class="headerlink" title="使用 apropos 搜索 Linux 命令"></a>使用 apropos 搜索 Linux 命令</h2><p>apropos 命令可以让你使用关键词，在<code>man</code>手册的名称和简介中进行搜索。</p>
<p>大多数情况下，这都会帮助你查找到你想要的命令。</p>
<p>使用<code>apropos</code>命令很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apropos [options] keyword</span><br></pre></td></tr></table></figure>

<p>举一个简单的例子，假如你正在查找一个与 CPU 有关的命令，可以使用 apropos 这样查找：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apropos cpu</span><br></pre></td></tr></table></figure>

<p>它会在 man 手册的名称和简介中查找所有包含 CPU 的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@learnubuntu:~<span class="comment"># apropos cpu</span></span><br><span class="line">chcpu (8)            - configure CPUs</span><br><span class="line">cpuid (4)            - x86 CPUID access device</span><br><span class="line">cpuset (7)           - confine processes to processor and memory node subsets</span><br><span class="line">lscpu (1)            - display information about the CPU architecture</span><br><span class="line">msr (4)              - x86 CPU MSR access device</span><br><span class="line"><span class="built_in">sched</span> (7)            - overview of CPU scheduling</span><br><span class="line">taskset (1)          - <span class="built_in">set</span> or retrieve a process<span class="string">&#x27;s CPU affinity</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，搜索不区分大小写，关键字可以是正则表达式。这就是为什么会看到很多返回结果，如<code>CPU</code>、<code>CPUID</code>等。</p>
<p>如果需要精确匹配，可以使用选项 <code>-e</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@learnubuntu:~<span class="comment"># apropos -e cpu</span></span><br><span class="line">lscpu (1)            - display information about the CPU architecture</span><br><span class="line">msr (4)              - x86 CPU MSR access device</span><br><span class="line"><span class="built_in">sched</span> (7)            - overview of CPU scheduling</span><br><span class="line">taskset (1)          - <span class="built_in">set</span> or retrieve a process<span class="string">&#x27;s CPU affinity</span></span><br></pre></td></tr></table></figure>

<h2 id="多个关键字"><a href="#多个关键字" class="headerlink" title="多个关键字"></a>多个关键字</h2><p>如果提供了多个关键字，<code>apropos</code> 将会返回所有与给定关键字匹配的结果。比如下面例子，会有307个条目与 network 或 pro 匹配：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@learnubuntu:~<span class="comment"># apropos network pro | wc -l</span></span><br><span class="line">307</span><br></pre></td></tr></table></figure>

<p>如果你搜索的单个命令包含多个词（单词之间有空格），那么可以使用<strong>引号</strong>来告诉<code>apropos</code>你搜索的是一整个命令而不是多个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@learnubuntu:~<span class="comment"># apropos &quot;network pro&quot;</span></span><br><span class="line">mtr-packet (8)       - send and receive network probes</span><br></pre></td></tr></table></figure>

<p>上面的示例要求你将所有关键字放在一起。可以使用 <code>-a</code> 选项，让条目以任何顺序匹配所有关键字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@learnubuntu:~<span class="comment"># apropos -a network pro</span></span><br><span class="line">ip-netns (8)         - process network namespace management</span><br><span class="line">mtr-packet (8)       - send and receive network probes</span><br></pre></td></tr></table></figure>

<h2 id="仅搜索用户或系统命令"><a href="#仅搜索用户或系统命令" class="headerlink" title="仅搜索用户或系统命令"></a>仅搜索用户或系统命令</h2><p>你可能发现了 <code>apropos</code> 命令会返回大量的结果，但并非所有的结果都是命令。</p>
<p>这是因为它搜索的是整个<code>man</code>手册。</p>
<p>如果你熟悉 <code>man</code> 手册，你会知道第 1 节包含有用户命令，第 8 节包含系统命令。如下表：</p>
<ul>
<li>用户命令（User Commands）</li>
<li>系统调用（System Calls）</li>
<li>C库函数（C Library Functions）</li>
<li>设备和特殊文件（Devices and Special Files）</li>
<li>文件格式和约定（File Formats and Conventions）</li>
<li>游戏等（Games etc）</li>
<li>杂项（Miscellanea）</li>
<li>系统管理工具和守护程序（System Administration tools and Daemons）</li>
</ul>
<p>所以，当你搜索CPU时，它显示了所有部分的结果。注意每个“命令”后面的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@learnubuntu:~<span class="comment"># apropos cpu</span></span><br><span class="line">chcpu (8)            - configure CPUs</span><br><span class="line">cpuid (4)            - x86 CPUID access device</span><br><span class="line">cpuset (7)           - confine processes to processor and memory node subsets</span><br><span class="line">lscpu (1)            - display information about the CPU architecture</span><br><span class="line">msr (4)              - x86 CPU MSR access device</span><br><span class="line"><span class="built_in">sched</span> (7)            - overview of CPU scheduling</span><br><span class="line">taskset (1)          - <span class="built_in">set</span> or retrieve a process<span class="string">&#x27;s CPU affinity</span></span><br></pre></td></tr></table></figure>

<p>你可以优化返回结果，（使用 <code>-s</code> 选项）只要指定的部分（sections）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@learnubuntu:~<span class="comment"># apropos -s 1,8 cpu</span></span><br><span class="line">chcpu (8)            - configure CPUs</span><br><span class="line">lscpu (1)            - display information about the CPU architecture</span><br><span class="line">taskset (1)          - <span class="built_in">set</span> or retrieve a process<span class="string">&#x27;s CPU affinity</span></span><br></pre></td></tr></table></figure>

<p>有很多方式可以在 Linux 命令行中获得帮助，apropos 命令就是其中之一，不过似乎很少人知道这个。</p>
<h1 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h1><p>tee 命令从标准输入读取数据，同时写入到标准输出和文件中。</p>
<p>也就是说，tee 命令的结果是，你既可以在屏幕上看到命令的输出，同时还可以将输出保存到文件中。</p>
<p>换言之，你有一个输入，它会被引导到两个输出。</p>
<img data-src="/2024/01/01/189/640-20240110080049997.png" class="" title="图片">



<p>要理解这个问题，首先你需要知道 Linux 中重定向的概念。关于重定向，可以参阅：</p>
<ul>
<li><a href="#%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E9%94%99%E8%AF%AF%E9%87%8D%E5%AE%9A%E5%90%91">输入、输出和错误重定向</a></li>
<li><a href="#%E7%AE%A1%E9%81%93pipe">管道pipe</a></li>
</ul>
<p>该命令以电力、管道系统和其他行业中使用的 <code>T</code> 形接头命名，它们被称为“T”，因为它们类似于字母“T”。</p>
<h2 id="tee-命令示例"><a href="#tee-命令示例" class="headerlink" title="tee 命令示例"></a>tee 命令示例</h2><p><code>tee</code>命令有一个简单的语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tee</span> [OPTION] [FILE]</span><br></pre></td></tr></table></figure>

<p><code>tee</code> 命令从标准输入读取数据，所以它总是和与另外一个命令一块被使用。</p>
<p>我们来看几个例子。</p>
<h2 id="显示命令输出并将其保存到文件"><a href="#显示命令输出并将其保存到文件" class="headerlink" title="显示命令输出并将其保存到文件"></a>显示命令输出并将其保存到文件</h2><p>比如我们想要计算某个文件中有多少行文字，我们要在屏幕上看到它到底有多少行，同时还想要把这个行数保存到另一个文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora~]$ <span class="built_in">wc</span> -l testfile.txt | <span class="built_in">tee</span> count.txt</span><br><span class="line">20 testfile.txt</span><br></pre></td></tr></table></figure>

<p>文件 count.txt 原本并不存在，因此它将创建一个名为 count.txt 的新文件。如果你查看文件 count.txt 的内容，会发现其与显示在屏幕上的内容是相同的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora~]$ <span class="built_in">cat</span> count.txt </span><br><span class="line">20 testfile.txt</span><br></pre></td></tr></table></figure>

<p>注意：默认情况下，tee 命令会覆盖原文件的内容。如果需要，可以使用 <code>-a</code> 选项来让其在文件中追加（而不是删除）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l testfile.txt | <span class="built_in">tee</span> -a count.txt</span><br></pre></td></tr></table></figure>

<h2 id="显示命令输出并将其保存到多个文件"><a href="#显示命令输出并将其保存到多个文件" class="headerlink" title="显示命令输出并将其保存到多个文件"></a>显示命令输出并将其保存到多个文件</h2><p>如果要将命令输出保存到多个文件，也可以使用 <code>tee</code> 命令，只需指定文件即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora~]$ <span class="built_in">wc</span> -l testfile.txt | <span class="built_in">tee</span> count1.txt count2.txt</span><br><span class="line">20 testfile.txt</span><br></pre></td></tr></table></figure>

<p>可以验证上述两个文件中是否存储了相同的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora~]$ <span class="built_in">cat</span> count1.txt count2.txt </span><br><span class="line">20 testfile.txt</span><br><span class="line">20 testfile.txt</span><br></pre></td></tr></table></figure>

<p>在 Linux 中，是可以通过 cat 命令来查看多个文件的。</p>
<h2 id="将命令输出解析到另一个命令，同时将其保存到文件中"><a href="#将命令输出解析到另一个命令，同时将其保存到文件中" class="headerlink" title="将命令输出解析到另一个命令，同时将其保存到文件中"></a>将命令输出解析到另一个命令，同时将其保存到文件中</h2><p>我们并不总是需要查看命令输出，由于它是标准输出，因此可以通过管道将其传输到另一个命令。</p>
<p>看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora~]$ <span class="built_in">ls</span> -l | <span class="built_in">tee</span> count.txt | <span class="built_in">wc</span> -l</span><br><span class="line"> 7</span><br></pre></td></tr></table></figure>

<p>上述命令中，<code>ls -l</code> 命令的输出通过管道传输到 <code>tee</code> 命令，<code>tee</code> 命令将 <code>ls -l</code> 的输出保存在 count.txt 文件中。然后，输出信息没有显示在屏幕上，而是又通过管道传输到了 <code>wc -l</code> 命令，该命令用于计算行数。</p>
<p>在本例中，我们通过屏幕看到的是 <code>wc -l</code> 命令的输出。<code>ls -l</code> 命令的输出被存储在了文件 count.txt 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[admin@fedora~]$ <span class="built_in">cat</span> count.txt </span><br><span class="line"> total 20</span><br><span class="line"> -r--r--r-- 1 admin admin  456 Dec 11 21:29 testfile.txt</span><br><span class="line"> -rw-r--r-- 1 admin admin    0 Jan 10 16:03 count.txt</span><br><span class="line"> -rw-r--r-- 1 admin admin  356 Dec 17 11:39 file1.txt</span><br><span class="line"> -rw-r--r-- 1 admin admin  356 Dec 17 09:59 file2.txt</span><br><span class="line"> -rw-r--r-- 1 admin admin  356 Dec 11 21:35 sherlock.txt</span><br><span class="line"> drwxr-xr-x 3 admin admin 4096 Jan  4 20:10 target</span><br></pre></td></tr></table></figure>

<p>我们可以在平时工作中，依实际情况尽可能的发挥想象力，来使用 <code>tee</code> 命令。比如在分析一个很长的输出（比如日志文件）时，使用它会很方便。实时查看并将其存储在文件中以供将来参考也是非常有用的一个操作。</p>
<h1 id="花括号扩展"><a href="#花括号扩展" class="headerlink" title="花括号扩展"></a>花括号扩展</h1><p>花括号扩展（Brace expansion） <code>&#123;..&#125;</code> 是 Linux 中使用率很高的一个 shell 功能。你可以使用它打印数字或字母序列，将两个整数或字母使用花括号中的两个点分隔开，然后会看到神奇的结果。</p>
<p>我们举个最简单的例子，看如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;1..10&#125;</span><br></pre></td></tr></table></figure>

<p>上述一行 echo 代码的输出将会是什么呢？如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>

<p>输出结果，会打印在同一行中，中间使用空格隔开。</p>
<p>为了让大家可以更好的理解它的功能，我们接下来列举几个其他例子。</p>
<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>假如我们想要得到一个从 7 到 1 的数字序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;7..1&#125;</span><br><span class="line">7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>

<p>可以添加前缀 0：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;01..10&#125;</span><br><span class="line">01 02 03 04 05 06 07 08 09 10</span><br></pre></td></tr></table></figure>

<p>可以使用 {x..y..z} 形式的花括号来扩展生成从 x 到 y 的值，递增（步长）为 z。比如我们想要打印 15 以内的偶数序列，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;0..15..2&#125;</span><br><span class="line">0 2 4 6 8 10 12 14</span><br></pre></td></tr></table></figure>

<p>或者奇数序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1..15..2&#125;</span><br><span class="line">1 3 5 7 9 11 13 15</span><br></pre></td></tr></table></figure>

<p>步长可以指定为任何数值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;100..1000..99&#125;</span><br><span class="line">100 199 298 397 496 595 694 793 892 991</span><br></pre></td></tr></table></figure>

<p>也可以采用负数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;3..-4&#125;</span><br><span class="line">3 2 1 0 -1 -2 -3 -4</span><br></pre></td></tr></table></figure>

<p>注意：花括号中的点之间<strong>不能有空格</strong>，否则，扩展将不起作用。</p>
<h2 id="使用字母序列"><a href="#使用字母序列" class="headerlink" title="使用字母序列"></a>使用字母序列</h2><p>我们上面的例子，介绍的是使用数字序列。但是也可以使用它生成字母序列。看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;A..H&#125;</span><br><span class="line">A B C D E F G H</span><br></pre></td></tr></table></figure>

<p>也可以将顺序反过来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;H..A&#125;</span><br><span class="line">H G F E D C B A</span><br></pre></td></tr></table></figure>

<p>或者指定步长：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;H..A..2&#125;</span><br><span class="line">H F D B</span><br></pre></td></tr></table></figure>

<p>或者使用小写字母：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a..f&#125;</span><br><span class="line">a b c d e f</span><br></pre></td></tr></table></figure>

<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>上面我们介绍了花括号扩展的具体用法，下面来介绍一些关于它的实际应用。</p>
<h3 id="创建一系列文件"><a href="#创建一系列文件" class="headerlink" title="创建一系列文件"></a>创建一系列文件</h3><p>我们可以利用花括号扩展来创建一系列具有相同文件名规则的文件，看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> file_&#123;1..10&#125;.txt</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">file_10.txt  file_2.txt  file_4.txt  file_6.txt  file_8.txt</span><br><span class="line">file_1.txt   file_3.txt  file_5.txt  file_7.txt  file_9.txt</span><br></pre></td></tr></table></figure>

<h3 id="创建备份文件"><a href="#创建备份文件" class="headerlink" title="创建备份文件"></a>创建备份文件</h3><p>当我们在编辑配置文件时，一般建议先对其进行备份，按照大多数人的习惯，是在原始文件名中添加 .bak 扩展名，这表示它是对原文件的一个备份。</p>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -p long_filename.txt long_filename.txt.bak</span><br></pre></td></tr></table></figure>

<p>现在我们来使用花括号扩展来完成这个工作，如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -p long_filename.txt&#123;,.bak&#125;</span><br></pre></td></tr></table></figure>

<p>是的，这里的 <code>&#123;,text&#125;</code> 不是上面的那种 <code>&#123;X..Y&#125;</code> 的模式，但是你需要知道有这样一个用法的存在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -p long_filename.txt&#123;,.bak&#125;</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">long_filename.txt long_filename.txt.bak</span><br></pre></td></tr></table></figure>

<p>上述 <code>cp</code> 命令的 <code>-p</code> 选项表示需要保留原文件的属性，比如所有权、时间戳等。</p>
<h3 id="使用多个花括号"><a href="#使用多个花括号" class="headerlink" title="使用多个花括号"></a>使用多个花括号</h3><p>可以使用多个花括号来创建具有相似名称和不同扩展名的文件，看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> &#123;a,b,c&#125;.&#123;hpp,cpp&#125;</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">a.cpp  a.hpp  b.cpp  b.hpp  c.cpp  c.hpp</span><br></pre></td></tr></table></figure>

<h3 id="在路径中使用或括号扩展"><a href="#在路径中使用或括号扩展" class="headerlink" title="在路径中使用或括号扩展"></a>在路径中使用或括号扩展</h3><p>假设有两个路径，其目录结构是类似的，只有很少的一部分不一样（比如中间某个文件夹名称不同），这个时候，花括号扩展会非常有用。看下面代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> project/&#123;new,old&#125;/dir/file</span><br></pre></td></tr></table></figure>

<p>其相当于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> project/new/dir/file project/old/dir/file</span><br></pre></td></tr></table></figure>

<h2 id="并非所有内容都可扩展"><a href="#并非所有内容都可扩展" class="headerlink" title="并非所有内容都可扩展"></a>并非所有内容都可扩展</h2><p>这是不言而喻的。如果你希望创建一个序列，给出的条件应该是可以创建成序列的东西。如果你使用的是一个很奇怪的组合，将不能被扩展。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1..Z&#125;</span><br><span class="line">&#123;1..Z&#125;</span><br></pre></td></tr></table></figure>

<p>另外，也<strong>不能</strong>使用小数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1..5..0.5&#125;</span><br><span class="line">&#123;1..5..0.5&#125;</span><br></pre></td></tr></table></figure>

<p>一些奇怪的组合，也会生成奇怪的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a..F&#125;</span><br><span class="line">a ` _ ^ ]  [ Z Y X W V U T S R Q P O N M L K J I H G F</span><br></pre></td></tr></table></figure>

<p>当你刚开始接触花括号扩展时，会觉得它很麻烦。但是，手动打字会更耗费时间。一旦你熟悉了它，那你的 Linux 技能会更上一个台阶。</p>
<h1 id="分析二进制文件"><a href="#分析二进制文件" class="headerlink" title="分析二进制文件"></a>分析二进制文件</h1><p>“世界上有10种人：懂二进制的和不懂二进制的。”</p>
<p>我们每天都在处理二进制文件，但很多人对其了解的还不够多。这里说的二进制文件，是指可执行文件，包括通过命令行执行的，或者其他应用程序。</p>
<p>Linux 提供了很多工具，可以分析二进制文件。无论你的具体工作是什么，只要你在Linux系统上工作，了解这些工具会让你更好的理解Linux系统。</p>
<p>本文将会介绍一些关于解析二进制文件的比较流行的工具和命令，其中大多数是默认在系统中安装了的，还有一部分需要手动安装。</p>
<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>功能：帮助确定文件类型。</p>
<p>这个应该作为你分析二进制文件的起点。我们每天都会处理很多文件，并非所有的文件都是可执行的。文件有很多种，在开始分析之前，你需要首先确定文件的类型。它们是二进制文件，库文件，文本文件，视频文件，图片，PDF，还是数据库文件？</p>
<p>file 命令会帮助你确定要处理文件的文件类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ file /bin/ls</span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=94943a89d17e9d373b2794dcb1f7e38c95b66c86, stripped</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br></pre></td></tr></table></figure>

<h2 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h2><p>功能：显示共享对象的依赖关系。</p>
<p>如果你在一个可执行的二进制文件上使用了 <code>file</code> 命令，那么应该会从输出内容中看到有“<strong>dynamically linked（动态链接）</strong>”的相关信息，这是什么意思呢？</p>
<p>在开发软件的时候，如果遇到一些常用功能且已经有现有工具的话，会使用现有的工具，就是“我们不会重新发明轮子”。大多数软件都会有一些常见的任务，比如打印输出，或者从标准输入读取、打开文件等等。这些常见的任务通常会被抽象为一组函数，所有人都能使用这些函数。这些函数通常会放在名为 libc 或 glibc 的库中。</p>
<p>如何知道可执行文件依赖于哪些库呢？使用 <code>ldd</code> 命令可以做到这一点，它可以显示二进制文件所有的依赖库及其路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ldd /bin/ls</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffef5ba1000)</span><br><span class="line">        libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007fea9f854000)</span><br><span class="line">        libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007fea9f64f000)</span><br><span class="line">        libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00007fea9f446000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fea9f079000)</span><br><span class="line">        libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007fea9ee17000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fea9ec13000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fea9fa7b000)</span><br><span class="line">        libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007fea9ea0e000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fea9e7f2000)</span><br></pre></td></tr></table></figure>

<h2 id="ltrace"><a href="#ltrace" class="headerlink" title="ltrace"></a>ltrace</h2><p>功能：库调用跟踪器。</p>
<p>我们现在知道了如何使用 <code>ldd</code> 命令查找可执行程序依赖的库。然而，一个库可能会包含数百个函数。在这数百个函数中，我们的二进制代码使用的实际函数是哪个呢？</p>
<p><code>ltrace</code> 命令显示在运行时从库中调用的所有函数。在下面的示例中，我们可以看到正在调用的函数名，以及传递给该函数的参数，还可以在输出的最右侧看到这些函数返回的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ltrace <span class="built_in">ls</span></span><br><span class="line">__libc_start_main(0x4028c0, 1, 0x7ffd94023b88, 0x412950 &lt;unfinished ...&gt;</span><br><span class="line">strrchr(<span class="string">&quot;ls&quot;</span>, <span class="string">&#x27;/&#x27;</span>)                                                                  = nil</span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>)                                                               = <span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line">bindtextdomain(<span class="string">&quot;coreutils&quot;</span>, <span class="string">&quot;/usr/share/locale&quot;</span>)                                    = <span class="string">&quot;/usr/share/locale&quot;</span></span><br><span class="line">textdomain(<span class="string">&quot;coreutils&quot;</span>)                                                             = <span class="string">&quot;coreutils&quot;</span></span><br><span class="line">__cxa_atexit(0x40a930, 0, 0, 0x736c6974756572)                                      = 0</span><br><span class="line">isatty(1)                                                                           = 1</span><br><span class="line">getenv(<span class="string">&quot;QUOTING_STYLE&quot;</span>)                                                             = nil</span><br><span class="line">getenv(<span class="string">&quot;COLUMNS&quot;</span>)                                                                   = nil</span><br><span class="line">ioctl(1, 21523, 0x7ffd94023a50)                                                     = 0</span><br><span class="line">&lt;&lt; <span class="string">snip &gt;&gt;</span></span><br><span class="line"><span class="string">fflush(0x7ff7baae61c0)                                                              = 0</span></span><br><span class="line"><span class="string">fclose(0x7ff7baae61c0)                                                              = 0</span></span><br><span class="line"><span class="string">+++ exited (status 0) +++</span></span><br></pre></td></tr></table></figure>

<h2 id="Hexdump"><a href="#Hexdump" class="headerlink" title="Hexdump"></a>Hexdump</h2><p>功能：以ASCII、十进制、十六进制或八进制显示文件内容。</p>
<p>通常，当你打开一个未知文件的时候，系统可能不知道如何处理该文件。如果尝试使用vim打开可执行文件或视频文件，我们通常会看到一堆乱码。</p>
<p>使用 <code>hexdump</code> 命令打开未知文件可以帮助我们查看文件到底包含什么。此外还可以选择使用一些命令行选项查看文件中数据的ASCII表示，这会帮助我们了解它是什么类型的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ hexdump -C /bin/ls | <span class="built_in">head</span></span><br><span class="line">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|</span><br><span class="line">00000010  02 00 3e 00 01 00 00 00  d4 42 40 00 00 00 00 00  |..&gt;......B@.....|</span><br><span class="line">00000020  40 00 00 00 00 00 00 00  f0 c3 01 00 00 00 00 00  |@...............|</span><br><span class="line">00000030  00 00 00 00 40 00 38 00  09 00 40 00 1f 00 1e 00  |....@.8...@.....|</span><br><span class="line">00000040  06 00 00 00 05 00 00 00  40 00 00 00 00 00 00 00  |........@.......|</span><br><span class="line">00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|</span><br><span class="line">00000060  f8 01 00 00 00 00 00 00  f8 01 00 00 00 00 00 00  |................|</span><br><span class="line">00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|</span><br><span class="line">00000080  38 02 00 00 00 00 00 00  38 02 40 00 00 00 00 00  |8.......8.@.....|</span><br><span class="line">00000090  38 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |8.@.............|</span><br></pre></td></tr></table></figure>

<h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>功能：输出文件中可打印的字符串。</p>
<p>如果你想在二进制文件中查找一些可打印的字符，那么可以使用 strings 命令。</p>
<p>在开发软件时，会向其中添加一些文本信息，比如打印消息，调试信息，帮助信息，错误信息等等。如果这些信息都以二进制形式存在，那么使用 strings 命令可以将其输出到屏幕中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strings /bin/ls</span><br></pre></td></tr></table></figure>

<h2 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h2><p>功能：显示ELF文件的信息。</p>
<p>ELF（可执行和可链接文件格式）是可执行文件或二进制文件的主要文件格式，不仅在Linux上，在各种UNIX系统上也是如此。如果您使用了诸如<code>file</code>命令之类的工具，该命令告诉你文件是<strong>ELF格式</strong>的，那么下一个逻辑步骤将是使用<code>readelf</code> 命令及其各种选项来进一步分析文件。</p>
<p>使用 <code>readelf</code> 命令的时候，可参考 ELF 规范，<a target="_blank" rel="noopener" href="http://www.skyfree.org/linux/references/ELF_Format.pdf">点击这里</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h /bin/ls</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x4042d4</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          115696 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         31</span></span><br><span class="line"><span class="string">  Section header string table index: 30</span></span><br></pre></td></tr></table></figure>

<h2 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h2><p>功能：显示对象文件中的信息。</p>
<p>二进制文件是你在编写完源代码后，由编译器将源代码编译后形成的。该编译器会将源代码编译为机器代码，然后由CPU执行给定任务。这种机器代码可以通过汇编语言来解释。汇编语言是一组指令，可以帮助我们理解程序是如何执行的。</p>
<p><code>objdump</code> 命令可以读取二进制或可执行文件，并将汇编语言指令输出到屏幕上。汇编知识对于理解 <code>objdump</code> 命令的输出很重要。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d /bin/ls | <span class="built_in">head</span></span><br><span class="line"></span><br><span class="line">/bin/ls:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">0000000000402150 &lt;_init@@Base&gt;:</span><br><span class="line">  402150:       48 83 ec 08             sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">  402154:       48 8b 05 6d 8e 21 00    mov    0x218e6d(%rip),%rax        <span class="comment"># 61afc8 &lt;__gmon_start__&gt;</span></span><br><span class="line">  40215b:       48 85 c0                <span class="built_in">test</span>   %rax,%rax</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>功能：跟踪系统调用和信号。</p>
<p><code>strace</code> 跟前面介绍的 <code>ltrace</code> 类似，区别是，<code>strace</code> 跟踪<strong>系统调用</strong>，而不是库调用。系统调用是你与内核交互以完成工作的方式。</p>
<p>举个例子，如果你想在屏幕上打印一些东西，你将使用标准库 libc 中的 <code>printf</code> 或 <code>put</code> 函数；然而，在后台，系统最终会调用一个名为 <code>write</code> 的函数将这些内容打印到屏幕上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ strace -f /bin/ls</span><br><span class="line">execve(<span class="string">&quot;/bin/ls&quot;</span>, [<span class="string">&quot;/bin/ls&quot;</span>], [/* 17 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0x686000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f967956a000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(<span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=40661, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 40661, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f9679560000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">&lt;&lt; <span class="string">snip &gt;&gt;</span></span><br><span class="line"><span class="string">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...&#125;) = 0</span></span><br><span class="line"><span class="string">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9679569000</span></span><br><span class="line"><span class="string">write(1, &quot;R2  RH\n&quot;, 7R2  RH</span></span><br><span class="line"><span class="string">)                 = 7</span></span><br><span class="line"><span class="string">close(1)                                = 0</span></span><br><span class="line"><span class="string">munmap(0x7f9679569000, 4096)            = 0</span></span><br><span class="line"><span class="string">close(2)                                = 0</span></span><br><span class="line"><span class="string">exit_group(0)                           = ?</span></span><br><span class="line"><span class="string">+++ exited with 0 +++</span></span><br></pre></td></tr></table></figure>

<h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h2><p>功能：列出对象文件中的符号。</p>
<p>如果你使用的是未剥离的二进制文件，<code>nm</code>命令将为你提供编译期间嵌入二进制文件中的有价值信息。<code>nm</code> 可以帮助我们从二进制文件中识别变量和函数，如果我们无法访问待分析的二进制文件的源代码，使用 <code>nm</code> 命令将会非常有用。</p>
<p>为了展示 nm 的功能，我们将编写一个小程序并使用 <code>-g</code> 选项编译它，我们还将看到，使用 <code>file</code> 命令不会剥离二进制文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> hello.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ gcc -g hello.c -o hello</span><br><span class="line"></span><br><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=3de46c8efb98bce4ad525d3328121568ba3d8a5d, not stripped</span><br><span class="line"></span><br><span class="line">$ ./hello</span><br><span class="line">Hello world!$</span><br><span class="line"></span><br><span class="line">$ nm hello | <span class="built_in">tail</span></span><br><span class="line">0000000000600e20 d __JCR_END__</span><br><span class="line">0000000000600e20 d __JCR_LIST__</span><br><span class="line">00000000004005b0 T __libc_csu_fini</span><br><span class="line">0000000000400540 T __libc_csu_init</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">000000000040051d T main</span><br><span class="line">                 U <span class="built_in">printf</span>@@GLIBC_2.2.5</span><br><span class="line">0000000000400490 t register_tm_clones</span><br><span class="line">0000000000400430 T _start</span><br><span class="line">0000000000601030 D __TMC_END__</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>功能：GNU调试器。</p>
<p>并不是所有的二进制文件都可以静态分析。我们确实执行了一些解析二进制文件的命令，比如 <code>ltrace</code> 和 <code>strace</code>，但是，软件的体系结构是多种多样的，我们不可能通过一种方法解析所有文件。</p>
<p>对于不好解析的文件，唯一的方法就是在运行时，能够在某些位置暂停程序，并能够分析信息，然后进行下一步执行。</p>
<p>这就是调试器该起作用的地方。在Linux中，gdb 实际上是调试器。它可以帮助我们加载程序，在特定位置设置断点，分析内存和CPU寄存器，或者做更多的事情。它补充了上述其他工具，并允许我们进行更多的运行时分析。</p>
<p>需要注意的一点是，一旦你使用 gdb 加载程序，你将会看到 gdb 输出的信息提示，所有后续命令都会在 gdb 命令提示符下运行，直到你退出。</p>
<p>我们将使用之前编译的“hello”程序，并使用 gdb 查看其工作原理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ gdb -q ./hello</span><br><span class="line">Reading symbols from /home/flash/hello...done.</span><br><span class="line">(gdb) <span class="built_in">break</span> main</span><br><span class="line">Breakpoint 1 at 0x400521: file hello.c, line 4.</span><br><span class="line">(gdb) info <span class="built_in">break</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400521 <span class="keyword">in</span> main at hello.c:4</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/flash/./hello</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at hello.c:4</span><br><span class="line">4           <span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7_6.6.x86_64</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  main () at hello.c:4</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hello world![Inferior 1 (process 29620) exited normally]</span><br><span class="line">(gdb) q</span><br></pre></td></tr></table></figure>

<h1 id="mapfile"><a href="#mapfile" class="headerlink" title="mapfile"></a>mapfile</h1><p><strong>将文件的内容赋值给变量</strong></p>
<p>使用 mapfile，可以读取文件的内容，将其输出分配被 bash 变量（数组）。文件中的每一行，都会是数组中的一个数组项（元素）。</p>
<p>比如，我们有一个文件 file.txt，其中的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">line 3</span><br><span class="line">line 4</span><br><span class="line">line 5</span><br></pre></td></tr></table></figure>

<p>然后，我们运行以下命令，将该文件中的内容转为数组中的元素。数组为变量 file_var：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">mapfile</span> file_var &lt; file.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;file_var[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115075016976.png" class="" title="图片">

<p>在上图的结果中，我们会看到输出中多了很多空白行。可以在 mapfile 中使用 <code>-t</code> 选项来解决这个问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">mapfile</span> -t file_var &lt; file.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;file_var[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;i&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<img data-src="/2024/01/01/189/640-20240115075016939.png" class="" title="图片">

<p>需要注意的是，不能通过管道重定向，将文件的内容给到 mapfile 命令，就像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> file.txt | <span class="built_in">mapfile</span> -t file_var</span><br></pre></td></tr></table></figure>

<p>上述代码是<strong>不正确</strong>的，这是因为管道右侧的 <code>mapfile</code> 命令是在<strong>子 shell</strong> 中运行的，也就是一个新的 bash 实例，它在当前的 shell 下是不起作用的。</p>
<h1 id="source"><a href="#source" class="headerlink" title="source"></a>source</h1><p>source 命令可以在当前 shell 中执行文件中的命令，也可以用于刷新环境变量。不过老实说，它的主要用途就是用于刷新环境变量。其语法格式如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> filename [options]</span><br></pre></td></tr></table></figure>

<p>也可以用一个点 <code>.</code> 来代替 source 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. filename [options]</span><br></pre></td></tr></table></figure>

<h2 id="source-命令是如何工作的"><a href="#source-命令是如何工作的" class="headerlink" title="source 命令是如何工作的"></a>source 命令是如何工作的</h2><p>这个命令的语法很简单，但是要理解它，需要稍微了解一些 Linux 概念。如果你是 Linux 新手，可能对于变量是什么只有一个比较模糊的概念。不过没关系，我们都是从这个阶段过来的。</p>
<p>为了方便理解 <code>source</code> 命令，下面我们是对变量做一个简短的解释。</p>
<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>你可以打开一个 bash 终端来创建一个新的变量，变量可以被认为是一个占位符，可以用来指向一条信息（字母，数字或者符号等）。</p>
<p>比如，我们创建一个名为 <code>name</code> 的变量，将其赋值为 Christopher。</p>
<p>在 bash 中，命名变量的格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_name=your_variable</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意，不要在等号 <code>=</code> 和文本之间添加空格。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ name=Christopher</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">Christopher</span><br></pre></td></tr></table></figure>

<p>那么，如果我只键入变量名会怎样呢？看下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> name</span><br><span class="line">name</span><br></pre></td></tr></table></figure>

<p>如果忘记带美元符号 <code>$</code>，比如上面的例子，bash 就会直接返回你输入的文本。</p>
<p>变量的调用可以在任何调用的位置，所以我们也可以将其放在如下代码中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>. <span class="variable">$name</span> is a great name. It&#x27;s good to meet you.&quot;</span></span><br><span class="line">Hello, Christopher. Christopher is a great name. It<span class="string">&#x27;s good to meet you.</span></span><br></pre></td></tr></table></figure>

<p>变量可以帮助我们做很多事情，上述对变量的简单介绍应该可以让大家了解它是如何工作的了。</p>
<h2 id="环境变量与-shell-变量"><a href="#环境变量与-shell-变量" class="headerlink" title="环境变量与 shell 变量"></a>环境变量与 shell 变量</h2><p>理解 <code>source</code> 命令的另外一个关键问题，就是关于变量的持久性，这是用来思考 shell 变量和环境变量之间区别的一种简单方法。</p>
<p>简单地说，如果在终端 shell 中创建一个变量，那么一旦退出该 shell，它就会丢失。</p>
<p>相比之下，环境变量会持久性的保存在操作系统中，而且通常都是使用大写字母。</p>
<p>其中一个例子，就是用户名，操作系统中其变量名称为 <code>$USER</code>。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line">christopher</span><br></pre></td></tr></table></figure>

<p>上面我们是介绍了一些关于环境变量和 shell 变量的区别，那么这跟 source 命令有啥关系呢？</p>
<h2 id="source-和-bash"><a href="#source-和-bash" class="headerlink" title="source 和 bash"></a>source 和 bash</h2><p>如果你使用过 Linux，可能会遇到过这两个命令，并且认为他们的功能是一样的。毕竟 source 和 bash 都可以用来执行脚本。</p>
<p>source 命令会在当前 shell 中执行，而 bash 会创建一个新的 shell 会话。这并不明显，因为没有显示新窗口。</p>
<p>下面我们创建一个名为 echo.sh 的脚本，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure>

<p>然后在终端中给 name 赋值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ name=chris</span><br></pre></td></tr></table></figure>

<p>接下来，我们分别使用 bash 和 source 命令来执行一下这个脚本，看如下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ bash echo.sh </span><br><span class="line">christopher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> echo.sh </span><br><span class="line">christopher</span><br><span class="line">chris</span><br><span class="line">$ . echo.sh </span><br><span class="line">christopher</span><br><span class="line">chris</span><br></pre></td></tr></table></figure>

<p>正如上述结果，当使用 bash 命令执行脚本时，shell 变量 <code>$name</code> 并没有被识别出来。</p>
<h2 id="使用-source-命令刷新环境变量"><a href="#使用-source-命令刷新环境变量" class="headerlink" title="使用 source 命令刷新环境变量"></a>使用 source 命令刷新环境变量</h2><p><code>source</code> 还可以用于更新当前 shell 中的环境变量，一个常见的例子是在当前 shell 中更新 bash 配置文件。</p>
<p>用户可能想要修改他们的 bash 配置文件，比如创建一个别名。通常，保存配置后，需要打开一个新的终端窗口才能看到更改生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> .bashrc </span><br></pre></td></tr></table></figure>

<p>运行此操作将刷新当前 shell 中的设置，而不会强制您打开新的终端。</p>
<h1 id=""><a href="#" class="headerlink" title="#!"></a>#!</h1><p>我们在 shell 脚本中，经常看到以下内容作为开头：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>#!</code> 被称为 <strong>shebang</strong> 或者 <strong>hasbang</strong>。shebang 在 shell 脚本中起着重要的作用，特别是在处理不同类型的 shell 时。</p>
<p>本文将介绍：</p>
<ol>
<li>什么是 shebang；</li>
<li>它如何在shell脚本中扮演重要角色。</li>
</ol>
<h2 id="shell脚本中的shebang是什么"><a href="#shell脚本中的shebang是什么" class="headerlink" title="shell脚本中的shebang是什么"></a>shell脚本中的shebang是什么</h2><p>shebang 是指的符号 <code>#!</code> ，这种字符的组合在脚本第一行中使用时具有特殊意义，它用于指定默认情况下运行给定脚本的解释器。</p>
<p>所以，如果脚本的<strong>第一行</strong>是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>这意味着解释器应该是 <strong>bash shell</strong>。如果第一行是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br></pre></td></tr></table></figure>

<p>这表示要使用的解释器是 <strong>Z shell</strong>。</p>
<p>在这里 <code>#!</code> 的用法当然是特殊的。因为 <code>#</code> 在 shell 脚本中是用于注释，在这里它有特殊的含义。</p>
<h2 id="为什么-shebang-在-shell-脚本中很重要？"><a href="#为什么-shebang-在-shell-脚本中很重要？" class="headerlink" title="为什么 shebang 在 shell 脚本中很重要？"></a>为什么 shebang 在 shell 脚本中很重要？</h2><p>是这样的，shebang 后跟的 shell 可执行文件对于脚本来说不是强制性的。</p>
<p>如果我们写了这样一个简单的脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello，TIAP!&quot;</span></span><br></pre></td></tr></table></figure>

<p>赋予执行权限，使用 <code>.</code> 运行它，它将由当前登录的 shell 运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> sample </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello，TIAP!&quot;</span></span><br><span class="line">$ <span class="built_in">chmod</span> u+x sample </span><br><span class="line">$ ./sample </span><br><span class="line">Hello，TIAP! </span><br></pre></td></tr></table></figure>

<p>那么，为什么还要在 shell 脚本中添加 <code>#!/bin/bash</code> 这一行作为开头呢？</p>
<p>因为在 Linux 或者 Unix 系统中，有多个 shell 可用。虽然这些 shell 大多具有相同的语法，但<strong>它们还是有一些差别，在某些语法中有不同的处理方式</strong>。</p>
<p>所以，我们需要在脚本中指定正确的 shell 解释器。否则的话，某些脚本在不同的 shell 中运行，可能就会产生不同的结果。</p>
<p>下面我们来举个例子。</p>
<h2 id="使用-shebang-指定-shell-解释器的重要性"><a href="#使用-shebang-指定-shell-解释器的重要性" class="headerlink" title="使用 shebang 指定 shell 解释器的重要性"></a>使用 shebang 指定 shell 解释器的重要性</h2><p>我写了一个示例脚本，内容是将几个 Linux 发行版本的名称放到一个数组中，然后打印出数组中第2个元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>我没有添加 shebang 行来指定任何 shell 解释器。这意味着当我执行这个脚本时，它将由<strong>默认</strong>shell（在我们的例子中是bash）运行。</p>
<p>以下为输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> arrays.sh</span><br><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">bash</span><br><span class="line">$ ./arrays.sh </span><br><span class="line">Distro at index 2 is: SUSE</span><br></pre></td></tr></table></figure>

<p>在上面例子中，数组的第2个元素输出显示为 SUSE，因为在 bash 和许多其他编程和脚本语言中，<strong>数组索引是从 0 开始的</strong>。但是在 Z shell 中不是，<strong>Z shell 中数组的索引是从1开始</strong>。</p>
<p>我在系统中安装了 Z shell，然后更改脚本，在第一行添加 shebang，并指定脚本由 Z shell 运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>以下为输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> arrays.sh</span><br><span class="line"><span class="comment">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br><span class="line">$ ./arrays.sh</span><br><span class="line">Distro at index 2 is: Fedora</span><br></pre></td></tr></table></figure>

<p>看到区别了吧，相同的脚本却有不同的输出，这就是为什么要添加 shebang 来指定解释器的原因。作为系统管理员，在编写脚本的时候知道使用的是哪个 shell，但是不能确定脚本的运行环境是不是与编写环境使用相同的默认shell，所以，需要指定一个 shell。</p>
<h2 id="如果运行时指定了-shell，那么-shebang-将会被忽略"><a href="#如果运行时指定了-shell，那么-shebang-将会被忽略" class="headerlink" title="如果运行时指定了 shell，那么 shebang 将会被忽略"></a>如果运行时指定了 shell，那么 shebang 将会被忽略</h2><p>前文中为什么要强调“<strong>默认</strong>”shell 呢？因为 shebang 指定了运行脚本的解释器。即如果没有使用 shebang 指定解释器, 那么就会使用 “默认shell” 执行脚本</p>
<p>但是，在运行的时候<strong>可以显式指定 shell</strong>，这种情况下，shebang 将会被忽略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./arrays.sh</span><br><span class="line">Distro at index 2 is: Fedora</span><br><span class="line">$ bash arrays.sh</span><br><span class="line">Distro at index 2 is: SUSE</span><br></pre></td></tr></table></figure>

<h2 id="shebang-是怎样工作的？"><a href="#shebang-是怎样工作的？" class="headerlink" title="shebang 是怎样工作的？"></a>shebang 是怎样工作的？</h2><p>当你在脚本的第一行使用 shebang 时，就是在告诉 shell 使用指定的命令运行脚本。</p>
<p>基本上，<code>#/bin/zsh</code> 相当于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh script_name</span><br></pre></td></tr></table></figure>

<p>我们前文中说过，如果脚本中第一行写了 shebang，这就意味着已经指定了 shell 解释器。</p>
<p>这其实是部分正确。事实上，这就是 shebang 存在的目的。但是 shebang 这一行不一定非要有可执行的 shell，它可以是任何东西。</p>
<p>比如，我们使用 <code>#!/bin/cat</code> 来代替 <code>#!/bin/zsh</code>，<code>/bin/cat</code> 是 <code>cat</code> 命令的可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/cat</span></span><br><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>那现在这个脚本将使用 <code>cat</code> 命令运行，并显示脚本的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> arrays.sh</span><br><span class="line"><span class="comment">#!/bin/cat</span></span><br><span class="line"></span><br><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br><span class="line">$ ./arrays.sh</span><br><span class="line"><span class="comment">#!/bin/cat</span></span><br><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>只要它指定的是可执行命令，那么它就会正常运行。如果你放的是其他一些随机的东西，那么就会报错。</p>
<p>比如，我在 shebang 一行这样写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/home/tiap</span></span><br></pre></td></tr></table></figure>

<p>很显然，它指向的并不是一个可执行文件，因此会抛出一个错误的解释器错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> arrays.sh </span><br><span class="line"><span class="comment">#!/home/tiap</span></span><br><span class="line">distros=(<span class="string">&quot;Ubuntu&quot;</span> <span class="string">&quot;Fedora&quot;</span> <span class="string">&quot;SUSE&quot;</span> <span class="string">&quot;Debian&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Distro at index 2 is: <span class="variable">$&#123;distros[2]&#125;</span>&quot;</span></span><br><span class="line">$ ./arrays.sh </span><br><span class="line">bash: ./arrays.sh: /home/tiap: bad interpreter: Permission denied</span><br></pre></td></tr></table></figure>

<h2 id="最后，我们再来明确几个注意事项："><a href="#最后，我们再来明确几个注意事项：" class="headerlink" title="最后，我们再来明确几个注意事项："></a>最后，我们再来明确几个注意事项：</h2><p>1）在 <code>#</code> 和 <code>!</code> 之间没有空格，<strong>不能这样写</strong>：<code># !/bin/bash</code>；</p>
<p>2）大多数系统允许 <code>#!</code> 和 <code>/bin/bash</code> 之间有空格，但是，作为一个好的习惯，还是<strong>不要</strong>在 <code>#!</code> 和 <code>/bin/bash</code> 之间添加空格；</p>
<p>3）<code>#!</code> 必须放在第一行，否则，shebang 将会被认为是一个注释，最好在它之前也<strong>不要</strong>有空行。</p>
<h1 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h1><p>在《Shell变量类型》中介绍了<code>HOME</code>、<code>$$</code> 等常用的预定义变量，他们在系统启动后就可以被使用，那么它们在哪里存储呢？在[《Shell变量作用范围》]中介绍了通过在<code>/etc/bashrc</code>配置变量实现跨进程，跨终端，跨用户。这个文件是什么? 为什么这个配置文件中的变量可以实现跨进程、终端、用户？他们是本章将要介绍的重点：环境变量配置文件。</p>
<p>环境变量配置文件主要定义的是对<strong>系统操作环境</strong>生效的系统<strong>默认环境变量</strong>，每次登录都会被加载。比如：<code>PATH</code>、<code>HOME</code>等。通常也用来设置一些常用的别名、函数和环境变量。如果要添加或修改环境变量的值，则必须再修改完配置文件后重新注销登录读取环境变量配置文件才能生效，或使用source命令可以使配置文件立即生效。格式: <code>source 配置文件</code> 或 <code>. 配置文件</code>(注意点号) 。</p>
<p>在Linux中，常见的环境变量配置文件有：</p>
<ul>
<li><code>/etc/profile</code></li>
<li><code>/etc/profile.d/\*.sh</code></li>
<li><code>/etc/bashrc</code></li>
<li><code>~/.bash_profile</code></li>
<li><code>~/.bashrc</code></li>
</ul>
<p>其中**&#x2F;etc&#x2F;目录<strong>下的配置文件对</strong>所有用户<strong>生效，</strong>家目录(~)<strong>下的配置文件只对</strong>当前用户**生效，下面将详细说明。</p>
<h2 id="配置文件种类"><a href="#配置文件种类" class="headerlink" title="配置文件种类"></a>配置文件种类</h2><h3 id="etc-profile"><a href="#etc-profile" class="headerlink" title="&#x2F;etc&#x2F;profile"></a>&#x2F;etc&#x2F;profile</h3><p>配置系统环境，如: PATH、USER等变量，同时还包含一些在用户登录时执行的脚本，这些脚本由&#x2F;etc&#x2F;profile启动运行，当用户登录Linux系统时，bash将执行 &#x2F;etc&#x2F;profile 文件中的命令，这些命令帮助用户设置工作环境，然后再将控制权交给用户主目录下的 ~&#x2F;.profile 文件。当系统给出主提示符（<code>$PS1</code>）后，用户就可以开始自己的工作。</p>
<h3 id="etc-profile-d-sh"><a href="#etc-profile-d-sh" class="headerlink" title="&#x2F;etc&#x2F;profile.d&#x2F;*.sh"></a>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</h3><p>&#x2F;etc&#x2F;profile.d&#x2F; 目录主要用于存放一些应用程序所需的启动脚本。这些脚本文件通常由应用程序安装，并且在用户登录时由 &#x2F;etc&#x2F;profile 文件调用执行，如用户登录Linux系统或使用 <code>su</code> 命令切换到另一个用户时，设置用户环境第一个读取的文件就是 &#x2F;etc&#x2F;profile。在 &#x2F;etc&#x2F;profile 中，会使用一个for循环语句来调用 &#x2F;etc&#x2F;profile.d&#x2F;*.sh 脚本文件, 使得这些脚本文件所设置的环境变量就和 &#x2F;etc&#x2F;profile 启动时一起被设置起来了。</p>
<p>因此，&#x2F;etc&#x2F;profile.d 目录中的脚本文件通常用于设置应用程序特定的环境变量和配置，以便在用户登录时正确地初始化和运行这些应用程序</p>
<h3 id="bash-profile"><a href="#bash-profile" class="headerlink" title="~&#x2F;.bash_profile"></a>~&#x2F;.bash_profile</h3><p>在Shell中 ~&#x2F;.bash_profile 文件主要用于配置用户环境变量和启动程序。它只对单一用户有效，位于用户的家目录(<code>~</code>)下 ~&#x2F;.bash_profile ，当用户登录（login）时，~&#x2F;.bash_profile 文件会被执行，用于设置环境变量和启动程序。这个文件可以用于配置用户的 <code>PATH</code>、<code>HISTSIZE</code>、<code>HISTFILESIZE</code>等环境变量的值。</p>
<p>此外，~&#x2F;.bash_profile 文件还可以包含一些用户专用的bash shell信息。它会在用户登录时由 ~&#x2F;.bashrc 文件执行。</p>
<h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~&#x2F;.bashrc"></a>~&#x2F;.bashrc</h3><p>~&#x2F;.bashrc文件是bash shell的配置文件，用于定义用户登录后的Shell环境。它存储了用户特定的配置信息，例如自定义别名、环境变量、命令别名、Shell函数等。每个用户都可以在自己的家目录(<code>~</code>)下的 ~&#x2F;.bashrc 文件中添加自己的配置，以满足其个性化的需求.</p>
<h3 id="etc-bashrc"><a href="#etc-bashrc" class="headerlink" title="&#x2F;etc&#x2F;bashrc"></a>&#x2F;etc&#x2F;bashrc</h3><p>&#x2F;etc&#x2F;bashrc 是一个全局的 Bash 配置文件，用于定义系统中所有用户的 Bash shell 的默认行为和环境变量。它在用户登录时被执行，为用户的交互式 Bash shell 提供一些全局的设置。</p>
<p>具体来说，&#x2F;etc&#x2F;bashrc 文件可以定义全局的环境变量，这些变量将在用户登录后的 Bash shell 中生效。通过在文件中添加 export 语句，可以设置全局的环境变量，例如 PATH、LANG、PS1 等。&#x2F;etc&#x2F;bashrc 文件还可以定义全局的别名和函数，供所有用户的 Bash shell 使用。通过在文件中添加 alias 或 function 语句，可以创建全局的别名和函数，以简化命令的输入和执行。</p>
<p>此外，&#x2F;etc&#x2F;bashrc 文件还可以配置全局的 Shell 行为，例如设置默认的提示符、设置历史命令记录和历史命令的数量限制、配置自动补全等。它还可以导入其他的配置文件，例如 &#x2F;etc&#x2F;profile.d&#x2F;*.sh 或 &#x2F;etc&#x2F;bashrc.local 等。这些文件包含了更具体和个性化的设置，用于扩展和定制系统的全局 Bash 配置。</p>
<p>总的来说，&#x2F;etc&#x2F;bashrc 文件的作用是为系统中所有用户的 Bash shell 提供默认的环境变量、别名、函数和行为设置。它可以在用户登录时执行，确保所有用户共享相同的全局配置，并提供一致的 Shell 使用体验。</p>
<p>看到这里是不是似乎有点明白了为什么在《shell变量作用范围》文章中介绍到 &#x2F;etc&#x2F;bashrc 中的变量可以实现共享了。</p>
<h2 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h2><p>前面介绍了配置文件的基本信息，下面介绍配置文件加载顺序，也就是系统启动或登录时加载配置文件的顺序，优先加载哪个配置文件？如果配置文件中有相同的变量会被覆盖？这里需要注意bash登录或新启终端会重新加载配置文件。为了更好理解，在配置文件中添加一些日志。然后通过新启终端来观察日志输出得到配置文件加载的先后顺序</p>
<h3 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h3><p>注意此时登录账户为root，只有root编辑&#x2F;etc目录下配置文件的权限。先给每个环境变量配置文件添加日志方便观察；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile 文件添加日志</span></span><br><span class="line">[root@ ~]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="comment"># /etc/profile 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/profile start <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/profile end <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile.d/ 目录下添加 hello.sh文件 ，内容：echo &#x27;/etc/profile.d/hello.sh&#x27;</span></span><br><span class="line">[root@ ~]<span class="comment"># cd /etc/profile.d/ ; vim hello.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/profile.d/hello.sh <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件中添加日志</span></span><br><span class="line">[root@ ~]<span class="comment"># vim ~/.bash_profile</span></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bash_profile start <span class="variable">$USER</span>&quot;</span></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bash_profile end <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bashrc 文件中添加日志</span></span><br><span class="line">[root@ ~]<span class="comment"># vim ~/.bashrc</span></span><br><span class="line"><span class="comment"># ~/.bashrc 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bashrc start <span class="variable">$USER</span>&quot;</span></span><br><span class="line"><span class="comment"># ~/.bashrc 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bashrc end <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/bashrc 文件中添加日志</span></span><br><span class="line">[root@ ~]<span class="comment"># vim /etc/bashrc</span></span><br><span class="line"><span class="comment"># /etc/bashrc 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/bashrc start <span class="variable">$USER</span>&quot;</span></span><br><span class="line"><span class="comment"># /etc/bashrc 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/bashrc end <span class="variable">$USER</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="开启终端查看"><a href="#开启终端查看" class="headerlink" title="开启终端查看"></a>开启终端查看</h3><p>新启终端，可以看到日志打印顺序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile start root</span><br><span class="line">/etc/profile.d/hello.sh root</span><br><span class="line">/etc/profile end root</span><br><span class="line">~/.bash_profile start root</span><br><span class="line">~/.bashrc start root</span><br><span class="line">/etc/bashrc start root</span><br><span class="line">/etc/bashrc end root</span><br><span class="line">~/.bashrc end root</span><br><span class="line">~/.bash_profile end root</span><br><span class="line">[root@ ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>日志加载基本顺序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile </span><br><span class="line">/etc/profile.d/*.sh</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc</span><br><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure>

<p>添加环境变量时，注意当前的配置文件以及变量在配置文件所在位置，避免加载不到或被其他配置文件中相同变量给覆盖额情况 ，需要注意几个细节：</p>
<ul>
<li>&#x2F;etc&#x2F;profile加载过程中会去加载&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件</li>
<li>~&#x2F;.bash_profile 加载过程中会先加载 ~&#x2F;.bashrc, 在加载完 &#x2F;etc&#x2F;bashrc之后，接着完成 ~&#x2F;.bashrc的加载，最后结束 ~&#x2F;.bash_profile的加载</li>
</ul>
<h2 id="配置文件特点"><a href="#配置文件特点" class="headerlink" title="配置文件特点"></a>配置文件特点</h2><p>上述介绍5种环境变量配置文件，他们有什么区别什么场景使用？如何区分？接下来从配置文件加载的方式、是否登录状态、服务的对象(系统用户和普通用户)进行介绍；</p>
<h3 id="配置文件加载的方式"><a href="#配置文件加载的方式" class="headerlink" title="配置文件加载的方式"></a>配置文件加载的方式</h3><p>当我们对环境变量配置文件进行修改后，配置不会立即生效，可通过3种方式重新加载配置文件使其生效。</p>
<h4 id="新启终端"><a href="#新启终端" class="headerlink" title="新启终端"></a>新启终端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增环境变量</span></span><br><span class="line">[root@ ~]$ vim ~/.bashrc </span><br><span class="line"><span class="built_in">export</span> name=123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前终端访问</span></span><br><span class="line">[root@ ~]<span class="comment"># echo &quot;$name, hello&quot;</span></span><br><span class="line">, hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新启终端访问</span></span><br><span class="line">[root@ ~]<span class="comment"># echo &quot;$name, hello&quot;</span></span><br><span class="line">123456, hello</span><br></pre></td></tr></table></figure>

<h4 id="source命令重新加载"><a href="#source命令重新加载" class="headerlink" title="source命令重新加载"></a>source命令重新加载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增环境变量</span></span><br><span class="line">[root@ ~]$ vim ~/.bashrc </span><br><span class="line"><span class="built_in">export</span> NAME=123456</span><br><span class="line"><span class="comment"># 立即访问</span></span><br><span class="line">[root@ ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NAME</span>, hello&quot;</span></span><br><span class="line">, hello</span><br><span class="line"><span class="comment"># 使用source命令加载配置文件</span></span><br><span class="line">[root@ ~]$ <span class="built_in">source</span> ~/.bashrc </span><br><span class="line"><span class="comment"># 再次访问</span></span><br><span class="line">[root@ ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$NAME</span>, hello&quot;</span></span><br><span class="line">123456, hello</span><br></pre></td></tr></table></figure>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>这里演示登录普通用户观察配置文件加载情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到joy用户 保持环境</span></span><br><span class="line">[root@ ~]$ su - joy</span><br><span class="line"><span class="comment"># 新增环境变量</span></span><br><span class="line">[joy@ ~]$ vim ~/.bashrc </span><br><span class="line"><span class="built_in">export</span> app=123456</span><br><span class="line"><span class="comment"># 立即访问</span></span><br><span class="line">[joy@ ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$app</span>, hello&quot;</span></span><br><span class="line">, hello</span><br><span class="line"><span class="comment"># 重新登录joy用户，加载配置文件</span></span><br><span class="line">[joy@ ~]$ su - joy</span><br><span class="line">Password:</span><br><span class="line"><span class="comment"># 切换用户后可以访问变量</span></span><br><span class="line">[joy@ ~]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$app</span>, hello&quot;</span></span><br><span class="line">123456, hello</span><br></pre></td></tr></table></figure>

<p>好像有点懵， 登录？那不登录配置文件会被加载？接下来请继续看</p>
<h3 id="登录态"><a href="#登录态" class="headerlink" title="登录态"></a>登录态</h3><p>登录态表示 <strong>login shell</strong> 和 <strong>no login shell</strong>， 他们将加载的环境变量配置文件主要在于是否加载&#x2F;etc&#x2F;profile、~&#x2F;.bash_profile。</p>
<ul>
<li><code>su</code> 不登录 加载部分配置文件，<br> ~&#x2F;.bashrc、&#x2F;etc&#x2F;bashrc、&#x2F;etc&#x2F;profile.d&#x2F;*.sh配置文件会被加载，profile不会被加载</li>
<li><code>su</code> - 登录 加载所有配置文件，以下文件都会被加载<ul>
<li>&#x2F;etc&#x2F;profile</li>
<li>~&#x2F;.bash_profile</li>
<li>~&#x2F;.bashrc</li>
<li>&#x2F;etc&#x2F;bashrc</li>
<li>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</li>
</ul>
</li>
</ul>
<p>以下演示登录态加载配置文件区别</p>
<h4 id="3-2-1、no-login"><a href="#3-2-1、no-login" class="headerlink" title="3.2.1、no login"></a>3.2.1、no login</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root用户 no login 方式切换用户</span></span><br><span class="line">[root@ ~]<span class="comment"># su root</span></span><br><span class="line">~/.bashrc start root</span><br><span class="line">/etc/bashrc start root</span><br><span class="line">/etc/profile.d/hello.sh root</span><br><span class="line">/etc/bashrc end root</span><br><span class="line">~/.bashrc end root</span><br></pre></td></tr></table></figure>

<p>no login bash情况下会按照以下顺序加载 3种配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bashrc  &gt;  /etc/bashrc  &gt;  /etc/profile.d/*.sh</span><br></pre></td></tr></table></figure>

<p>注意：&#x2F;etc&#x2F;profile 和 bash_profile 配置文件未被加载</p>
<p><strong>3.2.2、login</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root用户 log方式切换用户</span></span><br><span class="line">[root@ ~]<span class="comment"># su - root</span></span><br><span class="line">/etc/profile start root</span><br><span class="line">/etc/profile.d/hello.sh root</span><br><span class="line">/etc/profile end root</span><br><span class="line">~/.bash_profile start root</span><br><span class="line">~/.bashrc start root</span><br><span class="line">/etc/bashrc start root</span><br><span class="line">/etc/bashrc end root</span><br><span class="line">~/.bashrc end root</span><br><span class="line">~/.bash_profile end root</span><br></pre></td></tr></table></figure>

<p>此时所有的配置文件均被加载。</p>
<p>总结：login 和 no login 最主要区别在 no login 不会加载 &#x2F;etc&#x2F;profile 和 bash_profile 配置文件，为了方便记忆，这里就简称为profile文件。</p>
<h3 id="服务的用户对象"><a href="#服务的用户对象" class="headerlink" title="服务的用户对象"></a>服务的用户对象</h3><p>针对环境变量配置服务的用户对象即普通用户和系统用户，将其分为**&#x2F;etc目录<strong>的配置和</strong>家目录(~)**的配置文件</p>
<p>为了节约篇幅，我们将《配置文件加载顺序#添加日志》例子中</p>
<ul>
<li>&#x2F;etc&#x2F;profile</li>
<li>&#x2F;etc&#x2F;bashrc</li>
<li>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</li>
</ul>
<p>三个配置文件中的<code>$USER</code>全部改为<strong>123</strong>，</p>
<p>~&#x2F;.bash_profile和~&#x2F;.bashrc中的<code>$USER</code>全部改为<strong>456</strong>，</p>
<p>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/profile 文件添加日志</span></span><br><span class="line">[root@ ~]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="comment"># /etc/profile 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/profile start 123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/etc/profile end 123&quot;</span></span><br><span class="line"></span><br><span class="line">篇幅有限，省略/etc/bashrc、/etc/profile.d/*.sh配置文件 日志记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件中添加日志</span></span><br><span class="line">[root@ ~]<span class="comment"># vim ~/.bash_profile</span></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bash_profile start 456&quot;</span></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bash_profile end 456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bashrc 文件中添加日志</span></span><br><span class="line">[root@ ~]<span class="comment"># vim ~/.bashrc</span></span><br><span class="line"><span class="comment"># ~/.bashrc 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bashrc start 456&quot;</span></span><br><span class="line"><span class="comment"># ~/.bashrc 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bashrc end 456&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过示例演示，使用系统用户root和普通用户joy</p>
<h4 id="3-3-1、系统用户"><a href="#3-3-1、系统用户" class="headerlink" title="3.3.1、系统用户"></a>3.3.1、系统用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root用户 log方式切换用户</span></span><br><span class="line">[root@ ~]<span class="comment"># su - root</span></span><br><span class="line">/etc/profile start 123</span><br><span class="line">/etc/profile.d/hello.sh 123</span><br><span class="line">/etc/profile end 123</span><br><span class="line">~/.bash_profile start 456</span><br><span class="line">~/.bashrc start 456</span><br><span class="line">/etc/bashrc start 123</span><br><span class="line">/etc/bashrc end 123</span><br><span class="line">~/.bashrc end 456</span><br><span class="line">~/.bash_profile end 456</span><br></pre></td></tr></table></figure>

<p>可以看到系统用户root下的环境变量配置文件均加载了</p>
<h4 id="3-3-2、普通用户joy"><a href="#3-3-2、普通用户joy" class="headerlink" title="3.3.2、普通用户joy"></a>3.3.2、普通用户joy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># log方式 切换非root用户 </span></span><br><span class="line">[root@ ~]<span class="comment"># su - joy </span></span><br><span class="line">/etc/profile start 123</span><br><span class="line">/etc/profile.d/hello.sh joy</span><br><span class="line">/etc/profile.d/hello.sh 123</span><br><span class="line">/etc/profile end 123</span><br><span class="line">/etc/bashrc start 123</span><br><span class="line">/etc/bashrc end 123</span><br></pre></td></tr></table></figure>

<p>通过对比发现，普通用户joy<strong>家目录(~)<strong>下的配置文件中没有输出带有</strong>456</strong>日志。为什么？难道没有加载joy用户家目录(<code>~</code>)下的 ~&#x2F;.bashrc 和 ~&#x2F;.bash_profile环境变量配置文件？</p>
<p>切换joy用户，给 ~&#x2F;.bashrc和 ~&#x2F;.bash_profile环境变量配置文件添加日志,注意，此时添加的数字为<strong>789</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件中添加日志</span></span><br><span class="line">[joy@ ~]<span class="comment"># vim ~/.bash_profile</span></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bash_profile start 789&quot;</span></span><br><span class="line"><span class="comment"># ~/.bash_profile 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bash_profile end 789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.bashrc 文件中添加日志</span></span><br><span class="line">[joy@ ~]<span class="comment"># vim ~/.bashrc</span></span><br><span class="line"><span class="comment"># ~/.bashrc 文件开头</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bashrc start 789&quot;</span></span><br><span class="line"><span class="comment"># ~/.bashrc 文件结尾</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;~/.bashrc end 789&quot;</span></span><br></pre></td></tr></table></figure>

<p>再次切换joy用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[joy@ ~]$ su - joy/etc/profile start 123/etc/profile.d/hello.sh joy/etc/profile.d/hello.sh 123/etc/profile end 123~/.bash_profile start 789~/.bashrc start 789/etc/bashrc start 123/etc/bashrc end 123~/.bashrc end 789~/.bash_profile end 789</span><br></pre></td></tr></table></figure>

<p>可以看到所有文件均加载了，我们对此下</p>
<p>系统用户家目录(<code>~</code>)环境变量配置文件输出日志都带<strong>456</strong>，&#x2F;etc目录下配置文件打印是<strong>123</strong>，</p>
<p>普通用户家目录(<code>~</code>)环境变量配置文件打印日志都带<strong>789</strong>，&#x2F;etc目录下配置文件打印是<strong>123</strong>，</p>
<p>总结：</p>
<p><strong>系统用户</strong>加载在**&#x2F;etc目录*<em>下的变量配置文件<br>&#x2F;etc&#x2F;profile、&#x2F;etc&#x2F;bashrc、&#x2F;etc&#x2F;profile.d&#x2F;</em>.sh对所有用户生效。</p>
<p><strong>普通用户</strong>加载**家目录(<code>~</code>)**用户特有的配置文件 ~&#x2F;.bash_profile、~&#x2F;.bashrc，只对当前用户生效。</p>
<p>上述对环境变量配置文件的加载方式、登录态和服务用户三个不同的角度深入的介绍配置文件的特点，从而对配置文件有了更好的把控。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>我们知道环境变量配置文件通常也用来设置一些常用的自定义别名、环境变量、命令别名、Shell函数，那么我们是否可以利用这些能力，简化常用命令以提高工作效率？</p>
<h3 id="系统默认自定义命令别名"><a href="#系统默认自定义命令别名" class="headerlink" title="系统默认自定义命令别名"></a>系统默认自定义命令别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]<span class="comment"># cat ~/.bashrc </span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从这里看到对rm、cp、mv命令重新定义为选择交互方式执行，以保证操作更安全。</p>
<h3 id="自定义命令别名"><a href="#自定义命令别名" class="headerlink" title="自定义命令别名"></a>自定义命令别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@ ~]<span class="comment"># vim ~/.bashrc</span></span><br><span class="line"><span class="comment"># 定义sortn按照数字升序排序</span></span><br><span class="line"><span class="built_in">alias</span> sortn=<span class="string">&#x27;sort -n&#x27;</span></span><br><span class="line"><span class="comment"># 定义访问数据库，此处为示例，注明mysql密码，实际工作总不建议明文配置。</span></span><br><span class="line"><span class="built_in">alias</span> mydb=<span class="string">&#x27;mysql -h 127.0.0.1 -ujoy -p123456 user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source 使配置立即生效</span></span><br><span class="line">[root@ ~]<span class="comment"># source ~/.bashrc</span></span><br><span class="line"></span><br><span class="line">[root@ ~]<span class="comment"># vi data.txt </span></span><br><span class="line">20</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">60</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义命令sortn</span></span><br><span class="line">[root@ ~]<span class="comment"># sortn data.txt &gt; result.txt </span></span><br><span class="line">[root@ ~]<span class="comment"># more result.txt </span></span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">20</span><br><span class="line">60</span><br></pre></td></tr></table></figure>

<p>以上演示了<strong>sort、mysql</strong>命令自定义示例，注：定义访问数据库，此处为示例，mysql为明文密码，实际工作总不建议明文配置。读者可结合自己工作常用命令赶紧来试试吧。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Qeuroal
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://qeuroal.top/2024/01/01/189/" title="189. Linux中的命令之大杂烩">http://qeuroal.top/2024/01/01/189/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"><i class="fa fa-tag"></i> linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/12/30/188/" rel="prev" title="188. Linux用户与用户组">
                  <i class="fa fa-angle-left"></i> 188. Linux用户与用户组
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/01/01/190/" rel="next" title="190. Linux中的网络相关">
                  190. Linux中的网络相关 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Qeuroal</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Qeuroal" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
