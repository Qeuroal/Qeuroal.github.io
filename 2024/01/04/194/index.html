<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qeuroal.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="查看进程、kill进程等">
<meta property="og:type" content="article">
<meta property="og:title" content="194. Linux中的命令之进程与程序">
<meta property="og:url" content="http://qeuroal.top/2024/01/04/194/index.html">
<meta property="og:site_name" content="Qeuroal&#39;s Blog">
<meta property="og:description" content="查看进程、kill进程等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/1435569-20220331194811658-781158805.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/1435569-20220331195118521-914767897.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/640.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/640-20240104090428524.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/image-20231119141349388.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/640-20240107173003244.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/640-20240109081313634.png">
<meta property="og:image" content="http://qeuroal.top/2024/01/04/194/640.jpeg">
<meta property="article:published_time" content="2024-01-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-01T23:18:39.559Z">
<meta property="article:author" content="Qeuroal">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qeuroal.top/2024/01/04/194/1435569-20220331194811658-781158805.png">


<link rel="canonical" href="http://qeuroal.top/2024/01/04/194/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qeuroal.top/2024/01/04/194/","path":"2024/01/04/194/","title":"194. Linux中的命令之进程与程序"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>194. Linux中的命令之进程与程序 | Qeuroal's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qeuroal's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">静幽正治</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#bash%E5%92%8Csh"><span class="nav-number">1.</span> <span class="nav-text">bash和sh</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">1.1.</span> <span class="nav-text">区别与联系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sh"><span class="nav-number">1.1.1.</span> <span class="nav-text">sh</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bash"><span class="nav-number">1.1.2.</span> <span class="nav-text">bash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.1.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%91%BD%E4%BB%A4%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98-%E5%8F%AF%E4%BB%A5%E6%89%A9%E5%A4%A7%E6%9D%83%E9%99%90%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">解决命令的权限问题, 可以扩大权限的范围</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">命令解释器工作模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">交互模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">非交互模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">安装软件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">查看进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ps"><span class="nav-number">3.1.</span> <span class="nav-text">ps</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">3.1.2.</span> <span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#au-x-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.1.3.</span> <span class="nav-text">au(x) 输出格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STAT-%E8%AF%A5%E8%A1%8C%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">STAT: 该行程的状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">3.1.4.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#top"><span class="nav-number">3.2.</span> <span class="nav-text">top</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E"><span class="nav-number">3.2.1.</span> <span class="nav-text">字段说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-top-%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="nav-number">3.2.2.</span> <span class="nav-text">常用的 top 命令选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#top%E5%91%BD%E4%BB%A4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">3.2.3.</span> <span class="nav-text">top命令交互操作指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.2.4.</span> <span class="nav-text">实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B1%EF%BC%9A%E5%A4%9A%E6%A0%B8CPU%E7%9B%91%E6%8E%A7"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">实例1：多核CPU监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B2%EF%BC%9A%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">实例2：高亮显示当前运行进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B3%EF%BC%9A%E6%98%BE%E7%A4%BA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">实例3：显示完整的程序命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B4%EF%BC%9A%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">实例4：显示指定的进程信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8top%E5%AE%9A%E4%BD%8D%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.4.5.</span> <span class="nav-text">使用top定位进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8top%E5%81%9C%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.4.6.</span> <span class="nav-text">使用top停止进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ldd"><span class="nav-number">3.3.</span> <span class="nav-text">ldd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">3.3.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.3.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lsof"><span class="nav-number">3.4.</span> <span class="nav-text">lsof</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0"><span class="nav-number">3.4.1.</span> <span class="nav-text">命令参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.4.2.</span> <span class="nav-text">使用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B1%EF%BC%9A%E6%97%A0%E4%BB%BB%E4%BD%95%E5%8F%82%E6%95%B0"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">实例1：无任何参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B2%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">实例2：查找某个文件相关的进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B3%EF%BC%9A%E5%88%97%E5%87%BA%E6%9F%90%E4%B8%AA%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">实例3：列出某个用户打开的文件信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B4%EF%BC%9A%E5%88%97%E5%87%BA%E6%9F%90%E4%B8%AA%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E6%89%80%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">实例4：列出某个程序进程所打开的文件信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B5%EF%BC%9A%E5%88%97%E5%87%BA%E6%9F%90%E4%B8%AA%E7%94%A8%E6%88%B7%E4%BB%A5%E5%8F%8A%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%80%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">实例5：列出某个用户以及某个进程所打开的文件信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B6%EF%BC%9A%E9%80%9A%E8%BF%87%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%B7%E6%98%BE%E7%A4%BA%E8%AF%A5%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">3.4.2.6.</span> <span class="nav-text">实例6：通过某个进程号显示该进程打开的文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B7%EF%BC%9A%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.4.2.7.</span> <span class="nav-text">实例7：列出所有的网络连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B8%EF%BC%9A%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89tcp-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF"><span class="nav-number">3.4.2.8.</span> <span class="nav-text">实例8：列出所有tcp 网络连接信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B9%EF%BC%9A%E5%88%97%E5%87%BA%E8%B0%81%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3"><span class="nav-number">3.4.2.9.</span> <span class="nav-text">实例9：列出谁在使用某个端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B10%EF%BC%9A%E5%88%97%E5%87%BA%E6%9F%90%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E6%89%80%E6%9C%89%E6%B4%BB%E8%B7%83%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3"><span class="nav-number">3.4.2.10.</span> <span class="nav-text">实例10：列出某个用户的所有活跃的网络端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B11%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E5%88%97%E5%87%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-number">3.4.2.11.</span> <span class="nav-text">实例11：根据文件描述列出对应的文件信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B12%EF%BC%9A%E5%88%97%E5%87%BA%E8%A2%AB%E8%BF%9B%E7%A8%8B%E5%8F%B7%E4%B8%BA1234%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%89%80%E6%89%93%E5%BC%80%E7%9A%84%E6%89%80%E6%9C%89IPV4-network-files"><span class="nav-number">3.4.2.12.</span> <span class="nav-text">实例12：列出被进程号为1234的进程所打开的所有IPV4 network files</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B13%EF%BC%9A%E5%88%97%E5%87%BA%E7%9B%AE%E5%89%8D%E8%BF%9E%E6%8E%A5%E4%B8%BB%E6%9C%BAnf5260i5-td%E4%B8%8A%E7%AB%AF%E5%8F%A3%E4%B8%BA%EF%BC%9A20-21-80%E7%9B%B8%E5%85%B3%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%B8%94%E6%AF%8F%E9%9A%943%E7%A7%92%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C"><span class="nav-number">3.4.2.13.</span> <span class="nav-text">实例13：列出目前连接主机nf5260i5-td上端口为：20, 21, 80相关的所有文件信息，且每隔3秒重复执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B14-%E8%A7%A3%E5%86%B3%E7%B1%BB%E4%BC%BCumount-target-is-busy%E6%8C%82%E8%BD%BD%E7%9B%98%E5%8D%B8%E8%BD%BD%E4%B8%8D%E6%8E%89%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.2.14.</span> <span class="nav-text">实例14: 解决类似umount target is busy挂载盘卸载不掉问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="nav-number">4.</span> <span class="nav-text">后台运行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.1.</span> <span class="nav-text">&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nohup"><span class="nav-number">4.2.</span> <span class="nav-text">nohup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fg%E5%92%8Cbg"><span class="nav-number">4.3.</span> <span class="nav-text">fg和bg</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E7%94%B1%E5%89%8D%E5%8F%B0%E8%BD%AC%E5%90%8E%E5%8F%B0"><span class="nav-number">4.3.1.</span> <span class="nav-text">命令由前台转后台</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E4%B8%80%E8%88%AC%E5%9C%B0"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">更一般地</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E7%94%B1%E5%90%8E%E5%8F%B0%E8%BD%AC%E5%89%8D%E5%8F%B0"><span class="nav-number">4.3.2.</span> <span class="nav-text">命令由后台转前台</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#disown"><span class="nav-number">4.4.</span> <span class="nav-text">disown</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="nav-number">5.</span> <span class="nav-text">设置开机自启动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shell%E5%90%AF%E5%8A%A8%E6%97%B6%E8%87%AA%E5%90%AF%E5%8A%A8"><span class="nav-number">5.1.</span> <span class="nav-text">shell启动时自启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E2%80%9D%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE%E2%80%9D"><span class="nav-number">5.2.</span> <span class="nav-text">使用”启动应用程序偏好设置”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8systemctl%E6%96%B9%E5%BC%8F-RECOMMNAD"><span class="nav-number">5.3.</span> <span class="nav-text">使用systemctl方式-RECOMMNAD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">6.</span> <span class="nav-text">查看程序启动命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">最佳解决方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AC%A1%E4%BD%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">次佳解决方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#clash-API-%E4%BD%BF%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">clash API 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%99%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">教程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Example"><span class="nav-number">7.2.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">7.3.</span> <span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cron%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">8.</span> <span class="nav-text">cron创建定时任务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">8.1.</span> <span class="nav-text">编写定时任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cron-%E8%AF%AD%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">cron 语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E8%AF%AD%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">简化语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E7%BB%93%E6%9D%9F%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">8.4.</span> <span class="nav-text">怎样结束一个定时任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%83%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84"><span class="nav-number">8.5.</span> <span class="nav-text">它是自动化的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">终止进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%B8%AD%E7%9A%84%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="nav-number">9.1.</span> <span class="nav-text">Linux中的终止信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%9A%84PID"><span class="nav-number">9.2.</span> <span class="nav-text">获取进程的PID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="nav-number">9.3.</span> <span class="nav-text">在Linux命令行中终止进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-kill-%E5%91%BD%E4%BB%A4"><span class="nav-number">9.3.1.</span> <span class="nav-text">使用 kill 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-killall-%E5%91%BD%E4%BB%A4"><span class="nav-number">9.3.2.</span> <span class="nav-text">使用 killall 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-pkill-%E5%91%BD%E4%BB%A4"><span class="nav-number">9.3.3.</span> <span class="nav-text">使用 pkill 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill-%E5%92%8C-killall-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.3.4.</span> <span class="nav-text">kill 和 killall 命令的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2%E5%92%8C%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">10.</span> <span class="nav-text">命令替换和变量替换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8C"><span class="nav-number">10.1.</span> <span class="nav-text">$()和&#96;&#96;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eval"><span class="nav-number">10.2.</span> <span class="nav-text">eval</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">10.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="nav-number">10.2.2.</span> <span class="nav-text">分析替换原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">10.2.3.</span> <span class="nav-text">常用示例</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qeuroal"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qeuroal</p>
  <div class="site-description" itemprop="description">大人者，不失其赤子之心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">182</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Qeuroal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qeuroal" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2024/01/04/194/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="194. Linux中的命令之进程与程序 | Qeuroal's Blog">
      <meta itemprop="description" content="查看进程、kill进程等">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          194. Linux中的命令之进程与程序
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-04T00:00:00+08:00">2024-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-02 07:18:39" itemprop="dateModified" datetime="2025-10-02T07:18:39+08:00">2025-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">查看进程、kill进程等</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="bash和sh"><a href="#bash和sh" class="headerlink" title="bash和sh"></a>bash和sh</h1><h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><h3 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h3><p>路径为 &#x2F;bin&#x2F;sh</p>
<p>sh就是Bourne shell</p>
<p>这个是UNIX标准的默认shell，对它评价是concise简洁 compact紧凑 fast高效，由AT&amp;T编写，属于系统管理shell</p>
<h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><p>路径为 &#x2F;bin&#x2F;bash</p>
<p>bash是 GNU Bourne-Again SHell (GNU 命令解释程序 “Bourne二世”)</p>
<p>是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=linux&spm=1001.2101.3001.7020">linux</a>标准的默认shell ，它基于Bourne shell，吸收了C shell和Korn shell的一些特性。bash是Bourne shell的超集，bash完全兼容Bourne shell,也就是说用Bourne shell的脚本不加修改可以在bash中执行，反过来却不行，bash的脚本在sh上运行容易报语法错误。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>bash是sh的完整版，bash完全兼容sh命令，反之不行</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>具体信息请使用如下命令查看</p>
<ul>
<li><p>查看bash</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看sh</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个命令有点问题, 具体请自行搜索吧</p>
</blockquote>
</li>
</ul>
<h3 id="解决命令的权限问题-可以扩大权限的范围"><a href="#解决命令的权限问题-可以扩大权限的范围" class="headerlink" title="解决命令的权限问题, 可以扩大权限的范围"></a>解决命令的权限问题, 可以扩大权限的范围</h3><p>比如要向 test.asc 文件中随便写入点内容，可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>如果将 test.asc 权限设置为只有 root 用户才有权限进行写操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">chown</span> root:root <span class="built_in">test</span></span><br><span class="line">$ ll</span><br><span class="line">total 4.0K</span><br><span class="line">-rw-rw-r-- 1 root root 12 Jan 22 03:14 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>然后，我们使用 sudo 并配合 echo 命令再次向修改权限之后的 test.asc 文件中写入信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt;&gt; <span class="built_in">test</span></span><br><span class="line">bash: <span class="built_in">test</span>: Permission denied</span><br></pre></td></tr></table></figure>

<p>这时可以看到 bash 拒绝这么做，说是权限不够。这是因为重定向符号 “<code>&gt;</code>” 和 “<code>&gt;&gt;</code>” 也是 bash 的命令。我们使用 sudo 只是让 echo 命令具有了 root 权限，但是没有让 “<code>&gt;</code>” 和 “<code>&gt;&gt;</code>” 命令也具有 root 权限，所以 bash 会认为这两个命令都没有像 test.csv文件写入信息的权限。</p>
<p>解决这一问题的途径有两种。</p>
<ul>
<li><p>方法1</p>
<p> 利用 <code>&quot;sh -c&quot;</code> 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bash -c <span class="string">&#x27;echo &quot;hello&quot; &gt;&gt; test&#x27;</span></span><br></pre></td></tr></table></figure>

<p> 或者</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sh -c <span class="string">&#x27;echo &quot;hello&quot; &gt;&gt; test&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2</p>
<p> 利用管道和 tee 命令，该命令可以从标准输入中读入信息并将其写入标准输出或文件中，具体用法如下：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> | sudo <span class="built_in">tee</span> -a <span class="built_in">test</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p> 注意，tee 命令的 “<code>-a</code>” 选项的作用等同于 “<code>&gt;&gt;</code>” 命令，如果去除该选项，那么 tee 命令的作用就等同于 “&gt;” 命令</p>
</li>
</ul>
<h2 id="命令解释器工作模式"><a href="#命令解释器工作模式" class="headerlink" title="命令解释器工作模式"></a>命令解释器工作模式</h2><p>命令解释器(这里是&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;bash) 有两种工作模式：交互模式和非交互模式。</p>
<h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><p>交互模式如下图所示，就是使用 ssh 连接到 Linux 服务器上，然后在终端上敲入命令就可以显示对应结果。这样与终端进行交互执行命令的方式就称为交互模式。</p>
<img data-src="/2024/01/04/194/1435569-20220331194811658-781158805.png" class="" title="img">

<h3 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h3><p>非交互模式如下图所示，非交互模式就是调用 bash 解释器，通过 <code>bash -c</code> 或 <code>sh -c</code> 后接命令的形式来解释执行命令。</p>
<img data-src="/2024/01/04/194/1435569-20220331195118521-914767897.png" class="" title="img">

<h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>从命令行安装应用程序最常见的方法是通过软件仓库(software respositories)(软件存储的地方)使用软件包管理器。所有 Linux 应用程序都以包的形式分发，这些包只不过是与包管理系统（package management system）相关联的文件。每个 Linux 发行版都有一个包管理系统，但它们并不完全相同。</p>
<p><strong>什么是包管理系统</strong></p>
<p>软件包管理系统是由一组工具和文件格式组成，它们一起用于安装、更新和卸载 Linux 应用程序。最常见的两个软件包管理系统来自Red Hat和Debian。Red Hat、CentOS和Fedora都使用rpm系统（<code>.rpm</code>文件），而Debian、Ubuntu、Mint和Ubuntu使用dpkg（<code>.deb</code>文件）。Gentoo Linux使用一个名为Portage的系统，Arch Linux只使用tarball（<code>.tar</code>文件）。这些系统之间的主要区别在于它们如何安装和维护应用程序。</p>
<p>你可能很想知道一个 <code>.rpm</code>, <code>.deb</code>, 或者 <code>.tar</code> 文件里面放的是什么。其实这都只是一些普通的、旧的归档文件（比如<code>zip</code>），其中包含应用程序的代码、安装说明、依赖项（它可能依赖于哪些其他应用程序）以及配置文件应该放在哪里。读取并执行所有这些指令的软件称为包管理器（package manager）。</p>
<p><strong>Debian、Ubuntu、Mint等</strong></p>
<p>Debian，Ubuntu，Mint 还有其他基于 Debian 的发行版都使用 .deb 文件和 dpkg 包管理系统。在这种系统中有两种方式安装应用程序，你可以使用 apt 应用程序从软件仓库中安装，也可以使用 dpkg 应用程序从 <code>.deb</code> 文件中安装应用程序。</p>
<p>下面我们分别来看下这两种方式。</p>
<p>使用 <code>apt</code> 安装很容易：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install app_name</span><br></pre></td></tr></table></figure>

<p>使用 <code>apt</code> 卸载应用也很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt remove app_name</span><br></pre></td></tr></table></figure>

<p>要更新已安装的应用，首先需要更新应用仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<p>更新完成后，就可以更新任何应用程序了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>

<p>如果要只更新某一个应用呢？也可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update app_name</span><br></pre></td></tr></table></figure>

<p>另外，如果你想要安装的应用在 Debian 仓库中不可用，但是可以下载一个 <code>.deb</code> 文件，那么你可以使用 <code>dpkg</code>（apt帮助管理）手动安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i app_name.deb</span><br></pre></td></tr></table></figure>
<p><strong>RHEL、CentOS、Fedora、Mageia和OpenMandriva</strong></p>
<p>Red Hat 的上游项目 Fedora 和“中游”项目 CentOS 使用 <code>dnf</code> 软件包管理器。它有自己的语法，是RPM系统的前端。虽然语法不同，但 <code>dnf</code> 在机制和目标相同的意义上与 <code>apt</code> 相似。Mageia 和 OpenMandriva 发行版曾经专门关注用于包管理的 urpmi，现在它们的发行版中也包括 <code>dnf</code>。</p>
<p><code>dnf</code> 包管理器实际上是 <code>yum</code> 命令的继承者。长期以来，<code>yum</code> 都在用户服务器中使用自己的语言，因此为了避免破坏用户系统上已经存在了十多年的自定义脚本，<code>yum</code> 和 <code>dnf</code> 现在可以互换（事实上，<code>yum</code> 现在是基于 <code>dnf</code> 的）。</p>
<p>安装一个应用的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install app_name</span><br></pre></td></tr></table></figure>
<p>卸载应用的命令也很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf remove app_name</span><br></pre></td></tr></table></figure>

<p>更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf upgrade --refresh</span><br></pre></td></tr></table></figure>

<p><code>dnf</code>（或 <code>yum</code>）命令是 RPM 打包系统的前端。如果在软件存储库中找不到应用程序，但可以直接从其供应商网站下载，则可以使用 dnf 手动安装 <code>.rpm</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dnf install ./app_name.rpm</span><br></pre></td></tr></table></figure>

<p>如你所见，通过命令行安装、卸载或者更新 Linux 应用一点都不难。事实上，一旦你习惯了它，你就会发现它比基于GUI的管理工具更快。</p>
<p>关于命令行安装的更多信息，可以访问<a target="_blank" rel="noopener" href="https://wiki.debian.org/Apt">Debian Apt wiki官网</a>，<a target="_blank" rel="noopener" href="https://access.redhat.com/articles/yum-cheat-sheet">Yum cheat sheet</a>，还有<a target="_blank" rel="noopener" href="https://docs.fedoraproject.org/en-US/quick-docs/dnf/">DNF wiki</a>。</p>
<h1 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h1><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>Linux ps （process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options] [--<span class="built_in">help</span>]</span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-A</code></td>
<td>列出所有的进程</td>
</tr>
<tr>
<td><code>-e</code></td>
<td>显示所有进程</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>全格式</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>显示加宽可以显示较多的资讯</td>
</tr>
<tr>
<td><code>-au</code></td>
<td>显示较详细的资讯</td>
</tr>
<tr>
<td><code>-aux</code></td>
<td>显示所有包含其他使用者的行程</td>
</tr>
</tbody></table>
<h3 id="au-x-输出格式"><a href="#au-x-输出格式" class="headerlink" title="au(x) 输出格式"></a>au(x) 输出格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>USER</code></td>
<td>行程拥有者</td>
</tr>
<tr>
<td><code>PID</code></td>
<td>pid</td>
</tr>
<tr>
<td><code>%CPU</code></td>
<td>占用的 CPU 使用率</td>
</tr>
<tr>
<td><code>%MEM</code></td>
<td>占用的记忆体使用率</td>
</tr>
<tr>
<td><code>VSZ</code></td>
<td>占用的虚拟记忆体大小</td>
</tr>
<tr>
<td><code>RSS</code></td>
<td>占用的记忆体大小</td>
</tr>
<tr>
<td><code>TTY</code></td>
<td>终端的次要装置号码 (minor device number of tty)</td>
</tr>
<tr>
<td><code>STAT</code></td>
<td>见[STAT: 该行程的状态](#STAT: 该行程的状态)</td>
</tr>
<tr>
<td><code>START</code></td>
<td>行程开始时间</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>执行的时间</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>所执行的指令</td>
</tr>
</tbody></table>
<h4 id="STAT-该行程的状态"><a href="#STAT-该行程的状态" class="headerlink" title="STAT: 该行程的状态"></a>STAT: 该行程的状态</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>D</code></td>
<td>无法中断的休眠状态 (通常 IO 的进程)</td>
</tr>
<tr>
<td><code>R</code></td>
<td>正在执行中</td>
</tr>
<tr>
<td><code>S</code></td>
<td>静止状态</td>
</tr>
<tr>
<td><code>T</code></td>
<td>暂停执行</td>
</tr>
<tr>
<td><code>Z</code></td>
<td>不存在但暂时无法消除</td>
</tr>
<tr>
<td><code>W</code></td>
<td>没有足够的记忆体分页可分配</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>高优先序的行程</td>
</tr>
<tr>
<td><code>N</code></td>
<td>低优先序的行程</td>
</tr>
<tr>
<td><code>L</code></td>
<td>有记忆体分页分配并锁在记忆体内 (实时系统或捱A I&#x2F;O)</td>
</tr>
</tbody></table>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>查找指定进程格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep 进程关键字</span><br></pre></td></tr></table></figure>

<p><code>grep</code>命令是查找，中间的<code>|</code>是管道命令是指<code>ps</code>命令与<code>grep</code>同时执行。</p>
<p>例如显示所有的Java进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep java</span><br><span class="line">root     15702     1  5 Jul01 ?        12:53:53 /opt/jdk1.8.0_151/bin/java -Xms512m -Xmx512m -Xmn256m -Dnacos.standalone=<span class="literal">true</span> -Dnacos.member.list= -Djava.ext.dirs=/opt/jdk1.8.0_151/jre/lib/ext:/opt/jdk1.8.0_151/lib/ext -Xloggc:/opt/nacos/logs/nacos_gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -Dloader.path=/opt/nacos/plugins/health,/opt/nacos/plugins/cmdb -Dnacos.home=/opt/nacos -jar /opt/nacos/target/nacos-server.jar --spring.config.location=file:/opt/nacos/conf/,classpath:/,classpath:/config/,file:./,file:./config/ --logging.config=/opt/nacos/conf/nacos-logback.xml --server.max-http-header-size=524288 nacos.nacos</span><br><span class="line">root     18199     1  0 Jun17 ?        04:45:18 /opt/jdk1.8.0_151/bin/java -Djava.util.logging.config.file=/opt/edudev/tomcat_8093_dataanalysis/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Dignore.endorsed.dirs= -classpath /opt/edudev/tomcat_8093_dataanalysis/bin/bootstrap.jar:/opt/edudev/tomcat_8093_dataanalysis/bin/tomcat-juli.jar -Dcatalina.base=/opt/edudev/tomcat_8093_dataanalysis -Dcatalina.home=/opt/edudev/tomcat_8093_dataanalysis -Djava.io.tmpdir=/opt/edudev/tomcat_8093_dataanalysis/temp org.apache.catalina.startup.Bootstrap start</span><br><span class="line">root     19511     1  1 Jul09 ?        00:45:24 java -jar -Dserver.port=11288 /opt/gateway/version2/activeservice/edu-service-active-1.0.0-SNAPSHOT.jar --spring.profiles.active=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>显示进程信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        01:42:12 systemd</span><br><span class="line">    2 ?        00:00:00 kthreadd</span><br><span class="line">    3 ?        00:03:30 ksoftirqd/0</span><br><span class="line">    5 ?        00:00:00 kworker/0:0H</span><br><span class="line">    7 ?        00:01:04 migration/0</span><br><span class="line">    8 ?        00:00:00 rcu_bh</span><br><span class="line">    9 ?        04:32:00 rcu_sched</span><br><span class="line">   10 ?        00:00:00 lru-add-drain</span><br><span class="line">   11 ?        00:02:33 watchdog/0</span><br><span class="line">   12 ?        00:01:50 watchdog/1</span><br><span class="line">   13 ?        00:00:51 migration/1</span><br><span class="line">   14 ?        00:02:25 ksoftirqd/1</span><br><span class="line">   16 ?        00:00:00 kworker/1:0H</span><br><span class="line">   17 ?        00:01:48 watchdog/2</span><br><span class="line">   18 ?        00:00:48 migration/2</span><br><span class="line">   19 ?        00:01:58 ksoftirqd/2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示指定用户信息</span></span><br><span class="line">$ ps -u root</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        01:42:12 systemd</span><br><span class="line">    2 ?        00:00:00 kthreadd</span><br><span class="line">    3 ?        00:03:30 ksoftirqd/0</span><br><span class="line">    5 ?        00:00:00 kworker/0:0H</span><br><span class="line">    7 ?        00:01:04 migration/0</span><br><span class="line">    8 ?        00:00:00 rcu_bh</span><br><span class="line">    9 ?        04:32:00 rcu_sched</span><br><span class="line">   10 ?        00:00:00 lru-add-drain</span><br><span class="line">   11 ?        00:02:33 watchdog/0</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>显示所有进程信息，连同命令行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -ef //显示所有命令，连带命令行</span></span><br><span class="line">UID    PID PPID C STIME TTY     TIME CMD</span><br><span class="line">root     1   0 0 10:22 ?    00:00:02 /sbin/init</span><br><span class="line">root     2   0 0 10:22 ?    00:00:00 [kthreadd]</span><br><span class="line">root     3   2 0 10:22 ?    00:00:00 [migration/0]</span><br><span class="line">root     4   2 0 10:22 ?    00:00:00 [ksoftirqd/0]</span><br><span class="line">root     5   2 0 10:22 ?    00:00:00 [watchdog/0]</span><br><span class="line">root     6   2 0 10:22 ?    /usr/lib/NetworkManager</span><br><span class="line">…</span><br><span class="line">root   31302 2095 0 17:42 ?    00:00:00 sshd: root@pts/2 </span><br><span class="line">root   31374 31302 0 17:42 pts/2  00:00:00 -bash</span><br><span class="line">root   31400   1 0 17:46 ?    00:00:00 /usr/bin/python /usr/sbin/aptd</span><br><span class="line">root   31407 31374 0 17:48 pts/2  00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>在Linux系统中，查看系统运行状态（或者故障排除），比如内存或者CPU使用率的时候，可以使用<code>top</code>命令，它提供了系统运行情况的信息。根据<code>man</code>手册，<code>top</code>程序提供了运行系统的动态实时视图，它可以显示系统摘要信息以及当前由Linux内核管理的进程或线程的列表。</p>
<p>通常，在<code>top</code>命令的信息中，我们只需要快速浏览一下，就可以确定当前系统的问题是什么。但是<code>top</code>命令的的功能远不止我们看到的这些，具体的功能会因你运行的系统版本（procps-ng, Busybox, BSD）而异，可以参照<code>man</code>手册。</p>
<p>要运行top命令，可以直接在终端中键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br></pre></td></tr></table></figure>

<p>正在运行的进程显示在顶部屏幕的表标题下方，系统统计信息显示在其上方。如下图所示：</p>
<img data-src="/2024/01/04/194/640.png" class="" title="图片">

<p>按 <strong>Z</strong> 键可以更改输入的颜色，这可以让输出更易读。按 <strong>1</strong> 键查看系统上每个CPU 核心的图形表示。反复按 <strong>1</strong> 以评估CPU核心的核心统计信息。</p>
<p>通过调用 <code>top</code> 命令，然后按 <strong>m</strong> 键，可以以图形方式显示内存使用情况。</p>
<h3 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$top</span></span><br><span class="line">    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00</span><br><span class="line">    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie</span><br><span class="line">    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st</span><br><span class="line">    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers</span><br><span class="line">    Swap:   397308k total,    67192k used,   330116k free,    71900k cached</span><br><span class="line">    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init</span><br><span class="line">    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0</span><br><span class="line">    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>09:14:56</code></td>
<td>系统当前时间</td>
</tr>
<tr>
<td><code>264 days, 20:56</code></td>
<td>系统开机到现在经过了多少时间</td>
</tr>
<tr>
<td><code>1 users</code></td>
<td>当前2用户在线</td>
</tr>
<tr>
<td><code>load average: 0.02, 0.04, 0.0</code>0</td>
<td>系统1分钟、5分钟、15分钟的CPU负载信息</td>
</tr>
</tbody></table>
</li>
<li><p>第二行</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Tasks</code></td>
<td>任务;</td>
</tr>
<tr>
<td><code>87 total</code></td>
<td>很好理解，就是当前有87个任务，也就是87个进程。</td>
</tr>
<tr>
<td><code>1 running</code></td>
<td>1个进程正在运行</td>
</tr>
<tr>
<td><code>86 sleeping</code></td>
<td>86个进程睡眠</td>
</tr>
<tr>
<td><code>0 stopped</code></td>
<td>停止的进程数</td>
</tr>
<tr>
<td><code>0 zombie</code></td>
<td>僵死的进程数</td>
</tr>
</tbody></table>
</li>
<li><p>第三行</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Cpu(s)</code></td>
<td>表示这一行显示CPU总体信息</td>
</tr>
<tr>
<td><code>0.0%us</code></td>
<td>用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。</td>
</tr>
<tr>
<td><code>0.7%sy</code></td>
<td>内核占用CPU时间百分比</td>
</tr>
<tr>
<td><code>0.0%ni</code></td>
<td>改变过优先级的进程占用CPU的百分比</td>
</tr>
<tr>
<td><code>99.3%id</code></td>
<td>空闲CPU时间百分比</td>
</tr>
<tr>
<td><code>0.0%wa</code></td>
<td>等待I&#x2F;O的CPU时间百分比</td>
</tr>
<tr>
<td><code>0.0%hi</code></td>
<td>CPU硬中断时间百分比</td>
</tr>
<tr>
<td><code>0.0%si</code></td>
<td>CPU软中断时间百分比</td>
</tr>
</tbody></table>
<blockquote>
<p> 注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；</p>
</blockquote>
</li>
<li><p>第四行</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Men</code></td>
<td>内存的意思</td>
</tr>
<tr>
<td><code>8175320kk total</code></td>
<td>物理内存总量</td>
</tr>
<tr>
<td><code>8058868k used</code></td>
<td>使用的物理内存量</td>
</tr>
<tr>
<td><code>116452k free</code></td>
<td>空闲的物理内存量</td>
</tr>
<tr>
<td><code>283084k buffers</code></td>
<td>用作内核缓存的物理内存量</td>
</tr>
</tbody></table>
</li>
<li><p>第五行</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Swap</code></td>
<td>交换空间</td>
</tr>
<tr>
<td><code>6881272k total</code></td>
<td>交换区总量</td>
</tr>
<tr>
<td><code>4010444k used</code></td>
<td>使用的交换区量</td>
</tr>
<tr>
<td><code>2870828k free</code></td>
<td>空闲的交换区量</td>
</tr>
<tr>
<td><code>4336992k cached</code></td>
<td>缓冲交换区总量</td>
</tr>
</tbody></table>
</li>
<li><p>再下面就是进程信息</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PID</code></td>
<td>进程的ID</td>
</tr>
<tr>
<td><code>USER</code></td>
<td>进程所有者</td>
</tr>
<tr>
<td><code>PR</code></td>
<td>进程的优先级别，越小越优先被执行</td>
</tr>
<tr>
<td><code>NInice</code></td>
<td>值</td>
</tr>
<tr>
<td><code>VIRT</code></td>
<td>进程占用的虚拟内存</td>
</tr>
<tr>
<td><code>RES</code></td>
<td>进程占用的物理内存</td>
</tr>
<tr>
<td><code>SHR</code></td>
<td>进程使用的共享内存</td>
</tr>
<tr>
<td><code>S</code></td>
<td>进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</td>
</tr>
<tr>
<td><code>%CPU</code></td>
<td>进程占用CPU的使用率</td>
</tr>
<tr>
<td><code>%MEM</code></td>
<td>进程使用的物理内存和总内存的百分比</td>
</tr>
<tr>
<td><code>TIME+</code></td>
<td>该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>进程启动命令名称</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="常用的-top-命令选项"><a href="#常用的-top-命令选项" class="headerlink" title="常用的 top 命令选项"></a>常用的 top 命令选项</h3><p>如果只查找由特定用户启动的进程，可以使用 <code>-u</code> 选项获取该信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top -u <span class="string">&#x27;username&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要获取系统上空闲进程的列表，请使用 <code>-i</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top -i</span><br></pre></td></tr></table></figure>

<p>信息的更新时间默认为3秒，可以将更新间隔设置为以秒为单位的任意值。比如我们将其更改为5，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top -d 5</span><br></pre></td></tr></table></figure>

<p>此外，还可以在计时器上运行top。例如，以下命令将迭代次数设置为两次，然后退出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top -n 2</span><br></pre></td></tr></table></figure>

<h3 id="top命令交互操作指令"><a href="#top命令交互操作指令" class="headerlink" title="top命令交互操作指令"></a>top命令交互操作指令</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>q</code></td>
<td>退出<code>top</code>命令</td>
</tr>
<tr>
<td><code>&lt;Space&gt;</code></td>
<td>立即刷新</td>
</tr>
<tr>
<td><code>s</code></td>
<td>设置刷新时间间隔</td>
</tr>
<tr>
<td><code>c</code></td>
<td>显示命令完全模式</td>
</tr>
<tr>
<td><code>t:</code></td>
<td>显示或隐藏进程和CPU状态信息</td>
</tr>
<tr>
<td><code>m</code></td>
<td>显示或隐藏内存状态信息</td>
</tr>
<tr>
<td><code>l</code></td>
<td>显示或隐藏<code>uptime</code>信息</td>
</tr>
<tr>
<td><code>f</code></td>
<td>增加或减少进程显示标志</td>
</tr>
<tr>
<td><code>S</code></td>
<td>累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的<code>MITE+</code></td>
</tr>
<tr>
<td><code>P</code></td>
<td>按<code>%CPU</code>使用率排行</td>
</tr>
<tr>
<td><code>T</code></td>
<td>按<code>MITE+</code>排行</td>
</tr>
<tr>
<td><code>M</code></td>
<td>按<code>%MEM</code>排行</td>
</tr>
<tr>
<td><code>u</code></td>
<td>指定显示用户进程</td>
</tr>
<tr>
<td><code>r</code></td>
<td>修改进程<code>renice</code>值</td>
</tr>
<tr>
<td><code>kkill</code></td>
<td>进程</td>
</tr>
<tr>
<td><code>i</code></td>
<td>只显示正在运行的进程</td>
</tr>
<tr>
<td><code>W</code></td>
<td>保存对top的设置到文件<code>^/.toprc</code>，下次启动将自动调用<code>toprc</code>文件的设置。</td>
</tr>
<tr>
<td><code>h</code></td>
<td>帮助命令。</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
</tbody></table>
<blockquote>
<p> 注：</p>
<ul>
<li>强调一下，使用频率最高的是<code>P</code>、<code>T</code>、<code>M</code>，因为通常使用<code>top</code>，我们就想看看是哪些进程最耗cpu资源、占用的内存最多；</li>
<li>通过”<code>shift + &gt;</code>”或”<code>shift + &lt;</code>”可以向右或左改变排序列</li>
<li>如果只需要查看内存：可用<code>free</code>命令。</li>
<li>只查看<code>uptime</code>信息（第一行），可用<code>uptime</code>命令；</li>
</ul>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="实例1：多核CPU监控"><a href="#实例1：多核CPU监控" class="headerlink" title="实例1：多核CPU监控"></a>实例1：多核CPU监控</h4><p>在top基本视图中，按键盘数字“<code>1</code>”，可监控每个逻辑CPU的状况；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[rdtfr@bl685cb4-t ^]$ top</span><br><span class="line">top - 09:10:44 up 20 days, 16:51,  4 users,  load average: 3.82, 4.40, 4.40</span><br><span class="line">Tasks: 1201 total,  10 running, 1189 sleeping,   0 stopped,   2 zombie</span><br><span class="line">Cpu0  :  1.3%us,  2.3%sy,  0.0%ni, 96.4%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu1  :  1.3%us,  2.6%sy,  0.0%ni, 96.1%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu2  :  1.0%us,  2.0%sy,  0.0%ni, 92.5%id,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st</span><br><span class="line">Cpu3  :  3.9%us,  7.8%sy,  0.0%ni, 83.2%id,  0.0%wa,  0.0%hi,  5.2%si,  0.0%st</span><br><span class="line">Cpu4  :  4.2%us, 10.4%sy,  0.0%ni, 63.8%id,  0.0%wa,  0.0%hi, 21.5%si,  0.0%st</span><br><span class="line">Cpu5  :  6.8%us, 12.7%sy,  0.0%ni, 80.5%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu6  :  2.9%us,  7.2%sy,  0.0%ni, 85.3%id,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st</span><br><span class="line">Cpu7  :  6.2%us, 13.0%sy,  0.0%ni, 75.3%id,  0.0%wa,  0.0%hi,  5.5%si,  0.0%st</span><br><span class="line">Mem:  32943888k total, 32834216k used,   109672k free,   642704k buffers</span><br><span class="line">Swap: 35651576k total,  5761928k used, 29889648k free, 16611500k cached</span><br></pre></td></tr></table></figure>

<h4 id="实例2：高亮显示当前运行进程"><a href="#实例2：高亮显示当前运行进程" class="headerlink" title="实例2：高亮显示当前运行进程"></a>实例2：高亮显示当前运行进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在top基本视图中,按键盘“b”（打开/关闭加亮效果）；</span><br></pre></td></tr></table></figure>

<h4 id="实例3：显示完整的程序命令"><a href="#实例3：显示完整的程序命令" class="headerlink" title="实例3：显示完整的程序命令"></a>实例3：显示完整的程序命令</h4><p>命令：<code>top -c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[rdtfr@bl685cb4-t ^]$ top -c</span><br><span class="line">top - 09:14:35 up 20 days, 16:55,  4 users,  load average: 5.77, 5.01, 4.64</span><br><span class="line">Tasks: 1200 total,   5 running, 1192 sleeping,   0 stopped,   3 zombie</span><br><span class="line">Cpu(s):  4.4%us,  6.0%sy,  0.0%ni, 83.8%id,  0.2%wa,  0.0%hi,  5.5%si,  0.0%st</span><br><span class="line">Mem:  32943888k total, 32842896k used,   100992k free,   591484k buffers</span><br><span class="line">Swap: 35651576k total,  5761808k used, 29889768k free, 16918824k cached</span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">2013 apache    18   0  403m  88m 5304 S 25.0  0.3   6:37.44 /usr/sbin/httpd</span><br><span class="line">18335 pubtest   22   0 65576  996  728 R  7.8  0.0   0:00.24 netstat -naltp</span><br><span class="line">16499 rdtfare   15   0 13672 2080  824 R  2.6  0.0   0:00.38 top -c</span><br><span class="line">29684 rdtfare   15   0 1164m 837m  14m S  2.3  2.6 148:47.54 ./autodata data1.txt</span><br><span class="line">12976 pubtest   18   0  238m 9000 1932 S  1.6  0.0 439:28.44 tscagent -s TOEV_P</span><br></pre></td></tr></table></figure>

<h4 id="实例4：显示指定的进程信息"><a href="#实例4：显示指定的进程信息" class="headerlink" title="实例4：显示指定的进程信息"></a>实例4：显示指定的进程信息</h4><p>命令：<code>top -p pidid</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/opt/app/tdv1/config#top -p 17265</span><br><span class="line">top - 09:17:34 up 455 days, 17:55,  2 users,  load average: 3.76, 4.56, 4.46</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  7.8%us,  1.9%sy,  0.0%ni, 89.2%id,  0.0%wa,  0.1%hi,  1.0%si,  0.0%st</span><br><span class="line">Mem:   8175452k total,  8103988k used,    71464k free,   268716k buffers</span><br><span class="line">Swap:  6881272k total,  4275424k used,  2605848k free,  6338184k cached</span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">17265 tdv1      15   0 56504  828  632 S  0.0  0.0 195:53.25 redis-server</span><br></pre></td></tr></table></figure>

<p>指定进程信息有多个时，需要结合其它工具将回车替换为,（<code>-p</code> 支持<code>pid,pid,pid</code>语法）</p>
<p>命令：<code>top -p pgrep MULTI_PROCESS | tr “\n” ”,” | sed ‘s/,$//’</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/opt/app/tdv1$top -p `pgrep java | tr &quot;\\n&quot; &quot;,&quot; | sed &#x27;s/,$//&#x27;`</span><br><span class="line">top - 14:05:31 up 53 days,  2:43,  9 users,  load average: 0.29, 0.34, 0.22</span><br><span class="line">Tasks:   3 total,   0 running,   3 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  5.9%us,  8.2%sy,  0.0%ni, 86.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:  66082088k total, 29512860k used, 36569228k free,   756352k buffers</span><br><span class="line">Swap: 32767992k total,  1019900k used, 31748092k free, 15710284k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                          27855 rdtfare   20   0 4454m 1.3g 5300 S  0.7  2.0 338:31.37 java</span><br><span class="line"> 2034 jenkins   20   0 18.3g 5.2g 5284 S  0.3  8.2  56:02.38 java       </span><br></pre></td></tr></table></figure>

<h4 id="使用top定位进程"><a href="#使用top定位进程" class="headerlink" title="使用top定位进程"></a>使用top定位进程</h4><p>使用 <code>Shift+L</code> 组合键可以按名称查找进程。这将在加粗的表格标题行上方创建一个提示。键入要查找的流程的名称，然后按 Enter 键或 Return 键，以查看在新排序的流程列表中突出显示的该进程的实例。</p>
<h4 id="使用top停止进程"><a href="#使用top停止进程" class="headerlink" title="使用top停止进程"></a>使用top停止进程</h4><p>你可以使用top命令停止或者“杀掉”一个正在运行的进程。首先，使用 <code>Shift+L</code> 或 <code>pgrep</code> 查找要停止的进程，然后按 <code>k</code> 键并输入要停止进程的 <code>ID</code>。默认值为列表顶部的任何值，因此请确保在按下回车键之前输入正确的 <code>PID</code>，否则可能会停掉你本不打算停止的进程。</p>
<img data-src="/2024/01/04/194/640-20240104090428524.png" class="" title="图片">

<p>top命令有许多迭代，包括htop, atop, btop, 还有 ttop。此外，还有一些专用的 top 命令，比如用于电源的 powertop，以及用于网络信息的 ntop 等。</p>
<h2 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h2><p>查看程序依赖库</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用来查看程序运行所需的共享库,常用来解决程序因缺少某个库文件而不能运行的一些问题。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>查看test程序运行所依赖的库:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ldd</span> <span class="built_in">test</span></span><br><span class="line">libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)</span><br><span class="line">libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)</span><br><span class="line">libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003995800000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：程序需要依赖什么库</li>
<li>第二列: 系统提供的与程序需要的库所对应的库</li>
<li>第三列：库加载的开始地址</li>
</ul>
<p>通过上面的信息，我们可以得到以下几个信息：</p>
<ol>
<li>通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配</li>
<li>通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置</li>
</ol>
<p>如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在；</p>
<blockquote>
<p><strong>注解</strong></p>
<p>原理： <code>ldd</code>不是个可执行程式，而只是个shell脚本； <code>ldd</code>显示可执行模块的dependency的工作原理，其实质是通过<code>ld-linux.so</code>（elf动态库的装载器）来实现的。<code>ld-linux.so</code>模块会先于<code>executable</code>模块程式工作，并获得控制权，因此当上述的那些环境变量被设置时，<code>ld-linux.so</code>选择了显示可执行模块的dependency。</p>
</blockquote>
<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><blockquote>
<p> 一切皆文件</p>
</blockquote>
<p><code>lsof</code>（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (<code>TCP</code>) 和用户数据报协议 (<code>UDP</code>) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</p>
<p>lsof打开的文件可以是：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络socket，unix域名socket）</li>
<li>还有其它类型的文件，等等</li>
</ul>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-a</code></td>
<td>列出打开文件存在的进程</td>
</tr>
<tr>
<td><code>-c&lt;进程名&gt;</code></td>
<td>列出指定进程所打开的文件</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>列出GID号进程详情</td>
</tr>
<tr>
<td><code>-d&lt;文件号&gt;</code></td>
<td>列出占用该文件号的进程</td>
</tr>
<tr>
<td><code>+d&lt;目录&gt;</code></td>
<td>列出目录下被打开的文件</td>
</tr>
<tr>
<td><code>+D&lt;目录&gt;</code></td>
<td>递归列出目录下被打开的文件</td>
</tr>
<tr>
<td><code>-n&lt;目录&gt;</code></td>
<td>列出使用NFS的文件</td>
</tr>
<tr>
<td><code>-i&lt;条件&gt;</code></td>
<td>列出符合条件的进程。（4、6、协议、:端口、 @ip ）</td>
</tr>
<tr>
<td><code>-p&lt;进程号&gt;</code></td>
<td>列出指定进程号所打开的文件</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>列出UID号进程详情</td>
</tr>
<tr>
<td><code>-h</code></td>
<td>显示帮助信息</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示版本信息</td>
</tr>
</tbody></table>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><h4 id="实例1：无任何参数"><a href="#实例1：无任何参数" class="headerlink" title="实例1：无任何参数"></a>实例1：无任何参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> | more</span><br><span class="line">COMMAND     PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME</span><br><span class="line">init          1      root  cwd       DIR              253,0     4096          2 /</span><br><span class="line">init          1      root  rtd       DIR              253,0     4096          2 /</span><br><span class="line">init          1      root  txt       REG              253,0   150352    1310795 /sbin/init</span><br><span class="line">init          1      root  mem       REG              253,0    65928    5505054 /lib64/libnss_files-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0  1918016    5521405 /lib64/libc-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0    93224    5521440 /lib64/libgcc_s-4.4.6-20120305.so.1</span><br><span class="line">init          1      root  mem       REG              253,0    47064    5521407 /lib64/librt-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0   145720    5521406 /lib64/libpthread-2.12.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>lsof输出各列信息的意义如下：</p>
<ul>
<li><p><code>COMMAND</code>：进程的名称</p>
</li>
<li><p><code>PID</code>：进程标识符</p>
</li>
<li><p><code>PPID</code>：父进程标识符（需要指定-R参数）</p>
</li>
<li><p><code>USER</code>：进程所有者</p>
</li>
<li><p><code>PGID</code>：进程所属组</p>
</li>
<li><p><code>FD</code>：文件描述符，应用程序通过文件描述符识别该文件。如<code>cwd</code>、<code>txt</code>等:</p>
<table>
<thead>
<tr>
<th>标识</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cwd</code></td>
<td>表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</td>
</tr>
<tr>
<td><code>txt </code></td>
<td>该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 &#x2F;sbin&#x2F;init 程序</td>
</tr>
<tr>
<td><code>lnn</code></td>
<td>library references (AIX);</td>
</tr>
<tr>
<td><code>er</code></td>
<td>FD information error (see NAME column);</td>
</tr>
<tr>
<td><code>jld</code></td>
<td>jail directory (FreeBSD);</td>
</tr>
<tr>
<td><code>ltx</code></td>
<td>shared library text (code and data);</td>
</tr>
<tr>
<td><code>mxx </code></td>
<td>hex memory-mapped type number xx.</td>
</tr>
<tr>
<td><code>m86</code></td>
<td>DOS Merge mapped file;</td>
</tr>
<tr>
<td><code>mem</code></td>
<td>memory-mapped file;</td>
</tr>
<tr>
<td><code>mmap</code></td>
<td>memory-mapped device;</td>
</tr>
<tr>
<td><code>pd</code></td>
<td>parent directory;</td>
</tr>
<tr>
<td><code>rtd</code></td>
<td>root directory;</td>
</tr>
<tr>
<td><code>tr</code></td>
<td>kernel trace file (OpenBSD);</td>
</tr>
<tr>
<td><code>v86</code></td>
<td>VP&#x2F;ix mapped file;</td>
</tr>
<tr>
<td><code>0</code></td>
<td>表示标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td>表示标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td>表示标准错误</td>
</tr>
</tbody></table>
<p> 一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等</p>
<table>
<thead>
<tr>
<th>标识</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code></td>
<td>表示该文件被打开并处于读取&#x2F;写入模式</td>
</tr>
<tr>
<td><code>r</code></td>
<td>表示该文件被打开并处于只读模式</td>
</tr>
<tr>
<td><code>w</code></td>
<td>表示该文件被打开并处于</td>
</tr>
<tr>
<td><code>空格</code></td>
<td>表示该文件的状态模式为unknow，且没有锁定</td>
</tr>
<tr>
<td><code>-</code></td>
<td>表示该文件的状态模式为unknow，且被锁定</td>
</tr>
</tbody></table>
<p> 同时在文件状态模式后面，还跟着相关的锁</p>
<table>
<thead>
<tr>
<th>标识</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>N</code></td>
<td>for a Solaris NFS lock of unknown type;</td>
</tr>
<tr>
<td><code>r</code></td>
<td>for read lock on part of the file;</td>
</tr>
<tr>
<td><code>R</code></td>
<td>for a read lock on the entire file;</td>
</tr>
<tr>
<td><code>w</code></td>
<td>for a write lock on part of the file;（文件的部分写锁）</td>
</tr>
<tr>
<td><code>W</code></td>
<td>for a write lock on the entire file;（整个文件的写锁）</td>
</tr>
<tr>
<td><code>u</code></td>
<td>for a read and write lock of any length;</td>
</tr>
<tr>
<td><code>U</code></td>
<td>for a lock of unknown type;</td>
</tr>
<tr>
<td><code>x</code></td>
<td>for an SCO OpenServer Xenix lock on part      of the file;</td>
</tr>
<tr>
<td><code>X</code></td>
<td>for an SCO OpenServer Xenix lock on the      entire file;</td>
</tr>
<tr>
<td><code>space</code></td>
<td>if there is no lock.</td>
</tr>
</tbody></table>
</li>
<li><p><code>TYPE</code>：文件类型，如<code>DIR</code>、<code>REG</code>等，常见的文件类型:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DIR</code></td>
<td>表示目录</td>
</tr>
<tr>
<td><code>CHR</code></td>
<td>表示字符类型</td>
</tr>
<tr>
<td><code>BLK</code></td>
<td>块设备类型</td>
</tr>
<tr>
<td><code>UNIX</code></td>
<td>UNIX 域套接字</td>
</tr>
<tr>
<td><code>FIFO</code></td>
<td>先进先出 (FIFO) 队列</td>
</tr>
<tr>
<td><code>IPv4</code></td>
<td>网际协议 (IP) 套接字</td>
</tr>
</tbody></table>
</li>
<li><p><code>DEVICE</code>：指定磁盘的名称</p>
</li>
<li><p><code>SIZE</code>：文件的大小</p>
</li>
<li><p><code>NODE</code>：索引节点（文件在磁盘上的标识）</p>
</li>
<li><p><code>NAME</code>：打开文件的确切名称</p>
</li>
</ul>
<h4 id="实例2：查找某个文件相关的进程"><a href="#实例2：查找某个文件相关的进程" class="headerlink" title="实例2：查找某个文件相关的进程"></a>实例2：查找某个文件相关的进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> /bin/bash</span><br><span class="line">COMMAND     PID USER  FD   TYPE DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">mysqld_sa  2169 root txt    REG  253,0   938736 4587562 /bin/bash</span><br><span class="line">ksmtuned   2334 root txt    REG  253,0   938736 4587562 /bin/bash</span><br><span class="line">bash      20121 root txt    REG  253,0   938736 4587562 /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="实例3：列出某个用户打开的文件信息"><a href="#实例3：列出某个用户打开的文件信息" class="headerlink" title="实例3：列出某个用户打开的文件信息"></a>实例3：列出某个用户打开的文件信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -u username</span><br><span class="line"></span><br><span class="line">-u 选项，u是user的缩写</span><br></pre></td></tr></table></figure>

<h4 id="实例4：列出某个程序进程所打开的文件信息"><a href="#实例4：列出某个程序进程所打开的文件信息" class="headerlink" title="实例4：列出某个程序进程所打开的文件信息"></a>实例4：列出某个程序进程所打开的文件信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -c mysql</span><br></pre></td></tr></table></figure>

<p><code>-c</code> 选项将会列出所有以mysql这个进程开头的程序的文件，其实你也可以写成 <code>lsof | grep mysql</code>, 但是第一种方法明显比第二种方法要少打几个字符；</p>
<h4 id="实例5：列出某个用户以及某个进程所打开的文件信息"><a href="#实例5：列出某个用户以及某个进程所打开的文件信息" class="headerlink" title="实例5：列出某个用户以及某个进程所打开的文件信息"></a>实例5：列出某个用户以及某个进程所打开的文件信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$lsof  -u test -c mysql</span><br></pre></td></tr></table></figure>

<h4 id="实例6：通过某个进程号显示该进程打开的文件"><a href="#实例6：通过某个进程号显示该进程打开的文件" class="headerlink" title="实例6：通过某个进程号显示该进程打开的文件"></a>实例6：通过某个进程号显示该进程打开的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -p 11968</span><br></pre></td></tr></table></figure>

<h4 id="实例7：列出所有的网络连接"><a href="#实例7：列出所有的网络连接" class="headerlink" title="实例7：列出所有的网络连接"></a>实例7：列出所有的网络连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i</span><br></pre></td></tr></table></figure>

<h4 id="实例8：列出所有tcp-网络连接信息"><a href="#实例8：列出所有tcp-网络连接信息" class="headerlink" title="实例8：列出所有tcp 网络连接信息"></a>实例8：列出所有tcp 网络连接信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i tcp</span><br><span class="line"></span><br><span class="line"><span class="variable">$lsof</span> -n -i tcp</span><br><span class="line">COMMAND     PID  USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">svnserve  11552 weber    3u  IPv4 3799399      0t0  TCP *:svn (LISTEN)</span><br><span class="line">redis-ser 25501 weber    4u  IPv4  113150      0t0  TCP 127.0.0.1:6379 (LISTEN)</span><br></pre></td></tr></table></figure>

<h4 id="实例9：列出谁在使用某个端口"><a href="#实例9：列出谁在使用某个端口" class="headerlink" title="实例9：列出谁在使用某个端口"></a>实例9：列出谁在使用某个端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i :3306</span><br></pre></td></tr></table></figure>

<h4 id="实例10：列出某个用户的所有活跃的网络端口"><a href="#实例10：列出某个用户的所有活跃的网络端口" class="headerlink" title="实例10：列出某个用户的所有活跃的网络端口"></a>实例10：列出某个用户的所有活跃的网络端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -a -u <span class="built_in">test</span> -i</span><br></pre></td></tr></table></figure>

<h4 id="实例11：根据文件描述列出对应的文件信息"><a href="#实例11：根据文件描述列出对应的文件信息" class="headerlink" title="实例11：根据文件描述列出对应的文件信息"></a>实例11：根据文件描述列出对应的文件信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -d description(like 2)</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -d 3 | grep PARSER1</span><br><span class="line"><span class="built_in">tail</span>      6499 tde    3r   REG    253,3   4514722     417798 /opt/applog/open/log/HOSTPARSER1_ERROR_141217.log.001</span><br></pre></td></tr></table></figure>

<p>说明： <code>0</code>表示标准输入，<code>1</code>表示标准输出，<code>2</code>表示标准错误，从而可知：所以大多数应用程序所打开的文件的 <code>FD</code> 都是从 <code>3</code> 开始</p>
<h4 id="实例12：列出被进程号为1234的进程所打开的所有IPV4-network-files"><a href="#实例12：列出被进程号为1234的进程所打开的所有IPV4-network-files" class="headerlink" title="实例12：列出被进程号为1234的进程所打开的所有IPV4 network files"></a>实例12：列出被进程号为1234的进程所打开的所有IPV4 network files</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i 4 -a -p 1234</span><br></pre></td></tr></table></figure>

<h4 id="实例13：列出目前连接主机nf5260i5-td上端口为：20-21-80相关的所有文件信息，且每隔3秒重复执行"><a href="#实例13：列出目前连接主机nf5260i5-td上端口为：20-21-80相关的所有文件信息，且每隔3秒重复执行" class="headerlink" title="实例13：列出目前连接主机nf5260i5-td上端口为：20, 21, 80相关的所有文件信息，且每隔3秒重复执行"></a>实例13：列出目前连接主机<code>nf5260i5-td</code>上端口为：<code>20, 21, 80</code>相关的所有文件信息，且每隔3秒重复执行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i @nf5260i5-td:20,21,80 -r 3</span><br></pre></td></tr></table></figure>

<h4 id="实例14-解决类似umount-target-is-busy挂载盘卸载不掉问题"><a href="#实例14-解决类似umount-target-is-busy挂载盘卸载不掉问题" class="headerlink" title="实例14: 解决类似umount target is busy挂载盘卸载不掉问题"></a>实例14: 解决类似umount target is busy挂载盘卸载不掉问题</h4><p>通过<code>lsof</code>命令处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsof /mnt/</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">bash    16302 root  cwd    DIR   8,17       50   64 /mnt</span><br></pre></td></tr></table></figure>

<p>找到<code>PID</code>对应的进程或者服务，然后杀死或者停止相应服务即可。</p>
<h1 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h1><p>Linux 命令是使用终端与系统交互的好方法。但是，有时可能需要一段时间才能完成手头的任务。这迫使用户等待相当长的时间或完全生成一个新的 shell。</p>
<p>幸运的是，您可以通过一些简单的方法在后台运行 Linux 命令。</p>
<h2 id=""><a href="#" class="headerlink" title="&amp;"></a>&amp;</h2><p><strong>在你的命令后添加一个 &amp;</strong></p>
<p>运行 Linux 后台命令的最简单方法是在命令后添加与号 (<code>&amp;</code>)。例如，如果从终端启动 gedit 文本编辑器，则在关闭编辑器之前无法使用 shell。但是，当您在命令中添加额外的 &amp; 时，您将能够立即使用 shell。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gedit &amp;</span><br></pre></td></tr></table></figure>

<p>对于需要长时间执行的任务，<code>&amp;</code>符号可以使当前终端窗口不被占用，这样就能继续在同一个终端上工作，甚至关闭终端窗口也不会影响任务的正常执行。不过需要注意的是，如果要求这个任务输出内容到标准输出中（例如 <code>echo</code> 或 <code>ls</code>），即便使用了 <code>&amp;</code>，也会等待这些输出任务在前台运行完毕；当使用 <code>&amp;</code>将一个进程放置到后台运行的时候，Bash 会提示这个进程的进程 ID。在 Linux 系统中运行的每一个进程都有一个唯一的进程 ID，我们可以使用进程 ID 来暂停、恢复或者终止对应的进程。</p>
<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>Linux 中 的nohup命令允许管理员运行不受挂断（Hang Up）信号影响的终端命令。您可以使用 nohup 在后台运行 Linux 命令。</p>
<p>nohup 的一个主要好处是，即使您退出 shell，您的命令也会运行。此外，它会生成执行的日志文件。在当前目录或 <code>$HOME</code> 中查找<code>nohup.out</code>。语法是: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> 命令</span><br></pre></td></tr></table></figure>

<p>如: 后台运行Nmap 端口扫描 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> sudo nmap -sS --top-ports=15 192.168.150.1/24</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q: Within zsh the command <code>&amp;!</code> is a shortcut for disown, i.e. the program won’t get killed upon exiting the invoking shell.</p>
</blockquote>
<p>程序退出不被杀死, 同时如果再次登录shell, 那么使用 <code>ps -ef | grep &quot;clash&quot;</code> 会显示clash 的父进程是 <code>1</code>, 这是因为创建的父进程被杀死, 那么由该进程创建的子进程会在父进程被杀死后, 父进程改为 <code>1</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> clash &amp;&gt; /dev/null &amp;!</span><br></pre></td></tr></table></figure>


<p>程序退出会被杀死的进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup clash &amp;&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>

<h2 id="fg和bg"><a href="#fg和bg" class="headerlink" title="fg和bg"></a>fg和bg</h2><h3 id="命令由前台转后台"><a href="#命令由前台转后台" class="headerlink" title="命令由前台转后台"></a>命令由前台转后台</h3><ol>
<li>键入 <code>ctrl+z</code> 以暂停这条命令并返回客户端</li>
<li>键入 <code>bg</code> 命令让这条shell命令在后台执行</li>
<li>键入 <code>disown -h</code> 这条命令保证当终端关闭时，Shell脚本不会被杀死</li>
</ol>
<h4 id="更一般地"><a href="#更一般地" class="headerlink" title="更一般地"></a>更一般地</h4><ol>
<li><p>ctrl+z将任务暂停，这时屏幕会打印这样一句 <code>[1]+  Stopped                 ./myserver</code></p>
</li>
<li><p>使用 <code>bg %1</code> 将这个任务转入后台运行（<code>1</code> 是刚才暂停任务的job号，步骤1中屏幕提示方括号里面的内容，如果忘了也可以用 <code>jobs</code> 命令查看）</p>
</li>
<li><p>使用 <code>disown –h %1</code> 指定shell退出时不要发送SIGHUP给任务1（注意任务号前面有个%）</p>
</li>
</ol>
<h3 id="命令由后台转前台"><a href="#命令由后台转前台" class="headerlink" title="命令由后台转前台"></a>命令由后台转前台</h3><ol>
<li>键入 <code>jobs</code> 查看后台执行的命令</li>
<li>键入 <code>fg %&lt;d&gt;</code> 将 jobs[d] 切换到前台</li>
</ol>
<h2 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h2><p><strong>使用 disown 将 Linux 命令设置为后台运行</strong></p>
<p>Linux 中 的<code>disown</code>命令可以轻松地在后台运行命令。首先，您需要使用<code>&amp;</code> 运算符在后台发送任务。然后，键入<code>disown</code>以将其与shell分离。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gedit &amp; <span class="built_in">disown</span></span><br></pre></td></tr></table></figure>

<p><code>disown</code> 的一个主要优点是，与 nohup 一样，当您关闭 shell 或注销时，系统不会终止您的任务。</p>
<p><strong>使用 Tmux 在后台运行 Linux 命令</strong></p>
<p>Tmux 是一个强大的多路复用器，它允许我们在单个窗口中运行多个终端会话。对于不熟悉它的人来说，学习 tmux 是一个很好的选择。Tmux 使在 Linux 中运行后台命令毫不费力。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -d <span class="string">&#x27;ping -c 10 8.8.8.8 &gt; www.itpro.net.cn.log&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当您运行上述tmux命令时，它将在单独的 shell 中执行ping命令并将其保留在后台。您可以使用此方法在后台执行任何 Linux 命令。</p>
<p>能够在后台运行命令使系统管理对管理员来说更有效率。您可以通过多种方式为您的任务做背景。像&amp;和<code>Ctrl + Z</code>这样的 Bash 功能很方便，但系统会在 shell 关闭时终止后台作业。另一方面，即使您注销或终止 shell ，诸如<code>nohup</code>和<code>disown</code> 之类的工具也会使您的命令保持运行。</p>
<p>如果您将程序长时间留在后台，如果编码不当，它们可能会变成僵尸进程。这些过程会显着降低系统速度。因此，请确保每隔一段时间识别并杀死僵尸进程。</p>
<h1 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h1><h2 id="shell启动时自启动"><a href="#shell启动时自启动" class="headerlink" title="shell启动时自启动"></a>shell启动时自启动</h2><blockquote>
<p>不建议使用: 因为每次启动shell都会启动, 而像clash这样的程序只需要执行一次即可, 并且如果多个用户执行, 会导致后执行clash的shell执行失败.</p>
</blockquote>
<ol>
<li><p>打开 <code>~/.bashrc</code> 或 <code>./.zshrc</code></p>
</li>
<li><p>在文件末尾添加又在每次用户登录时执行的命令, 如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> clash &amp;&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>source ~/.bashrc</code> 或 <code>source ~/.zshrc</code>以使更改生效</p>
</li>
</ol>
<h2 id="使用”启动应用程序偏好设置”"><a href="#使用”启动应用程序偏好设置”" class="headerlink" title="使用”启动应用程序偏好设置”"></a>使用”启动应用程序偏好设置”</h2><blockquote>
<p> (Startup Applications Preferences)</p>
</blockquote>
<ol>
<li>Startup Applications Preferences 的配置信息通常存储在 <code>~/.config/autostart</code> 目录中的 <code>.desktop</code> 文件中. 每个启动的应用程序都有一个相应的 <code>.desktop</code> 文件，该文件包含有关应用程序启动方式的信息。</li>
</ol>
<p>添加文件 <code>vim &lt;startup_program&gt;.desktop</code>, 添加如下配置</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Exec=&lt;your command&gt;</span><br><span class="line">Hidden=false</span><br><span class="line">NoDisplay=false</span><br><span class="line">X-GNOME-Autostart-enabled=true</span><br><span class="line">Name[en_US]=&lt;My Program&gt;</span><br><span class="line">Name=&lt;My Program&gt;</span><br><span class="line">Comment[en_US]=&lt;My startup program&gt;</span><br><span class="line">Comment=&lt;My startup program&gt;</span><br></pre></td></tr></table></figure>

<p>   如:</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Exec=nohup clash &amp;&gt; /dev/null</span><br><span class="line">Hidden=false</span><br><span class="line">NoDisplay=false</span><br><span class="line">X-GNOME-Autostart-enabled=true</span><br><span class="line">Name[en_US]=clash</span><br><span class="line">Name=clash</span><br><span class="line">Comment[en_US]=clash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Exec</code> 行指定了要在启动时运行的程序的路径</p>
</blockquote>
<h2 id="使用systemctl方式-RECOMMNAD"><a href="#使用systemctl方式-RECOMMNAD" class="headerlink" title="使用systemctl方式-RECOMMNAD"></a>使用systemctl方式-RECOMMNAD</h2><p>采用systemctl的方式</p>
<p>强烈建议看看<a target="_blank" rel="noopener" href="https://ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">这个文档</a>，里面介绍了一些参数的具体含义.</p>
<ol>
<li><p>准备工作</p>
<ol>
<li><p>写好脚本(假设脚本名为 <strong>exec_clash.sh</strong>)或将程序放入本地可以运行, 这里以clash为例, 其中, clash位于 <code>/usr/local/bin/clash</code></p>
<blockquote>
<p>注: exec_clash.sh 中的 exec_clash 是可根据具体脚本的功能改为相应的名字</p>
</blockquote>
</li>
<li><p>若是脚本, 则赋予脚本运行权限: <code>chmod +x exec_clash.sh</code></p>
</li>
</ol>
</li>
<li><p>配置 </p>
<ol>
<li><p>编写一个 <code>&lt;clash&gt;.service</code>, 内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=clash</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=qeuroal</span><br><span class="line">ExecStart=/usr/local/bin/clash</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=30</span><br><span class="line">StartLimitInterval=0</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target graphical.target</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ul>
<li><p><code>User</code>: 表示以哪个用户启动，不写默认是root. 而用户名也决定了程序启动去哪里读取相应的配置</p>
</li>
<li><p><code>ExecStart</code>: 就是要执行的语句。</p>
<p> 由于为脚本赋予了<code>x</code>(可执行)权限, 因此, <code>ExecStart</code>后面的内容可以直接写成脚本的绝对路径</p>
</li>
<li><p><code>Restart=always</code>: 只要不是通过<code>systemctl stop</code>来停止服务，任何情况下都必须要重启服务，默认值为no。还可以配置有条件重启，具体参考上述文档。</p>
</li>
<li><p><code>RestartSec=5</code>: 重启间隔，比如某次异常后，等待5(s)再进行启动，默认值0.1(s)</p>
</li>
<li><p><code>StartLimitInterval</code>: 无限次重启，默认是10秒内如果重启超过5次则不再重启，设置为0表示不限次数重启</p>
</li>
</ul>
</li>
<li><p>拷贝 <code>clash.service</code> 到 <code>/lib/systemd/system</code>, 需要注意权限问题</p>
</li>
<li><p>修改配置文件后需要重加载配置： <code>sudo systemctl daemon-reload</code></p>
</li>
<li><p>设置开机自启: <code>sudo systemctl enable clash.service</code></p>
<p>之后就可以直接重启了</p>
</li>
<li><p>相关操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td><code>sudo systemctl start clash.service</code></td>
</tr>
<tr>
<td>停止</td>
<td><code>sudo systemctl stop clash.service</code></td>
</tr>
<tr>
<td>查看状态</td>
<td><code>sudo systemctl status clash.service</code></td>
</tr>
</tbody></table>
</li>
<li><p>测试自动重启功能</p>
<img data-src="/2024/01/04/194/image-20231119141349388.png" class="" title="image-20231119141349388"></li>
</ol>
</li>
</ol>
<h1 id="查看程序启动命令"><a href="#查看程序启动命令" class="headerlink" title="查看程序启动命令"></a>查看程序启动命令</h1><h2 id="最佳解决方法"><a href="#最佳解决方法" class="headerlink" title="最佳解决方法"></a>最佳解决方法</h2><p>大多数默认应用程序将具有位于<code>/usr/share/applications</code>中的<code>.desktop</code>文件。</p>
<p>要了解在启动其中一个应用程序时将运行的相应终端命令，请打开文件浏览器Nautilus，然后右键单击应用程序的图标以在上下文菜单中选择“属性”。这将为您提供所需的所有详细信息(此处显示将运行<code>gnome-control-center -overview</code>的系统设置)</p>
<h2 id="次佳解决方法"><a href="#次佳解决方法" class="headerlink" title="次佳解决方法"></a>次佳解决方法</h2><p>如果通过存储库或dpkg安装了应用程序，则可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep <span class="string">&quot;&lt;application name&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这将搜索所有已安装的应用程序，并搜索其描述;搜索描述是这里的重要部分，因为描述通常包含应用程序的名称，即使运行它的”command”不包含应用程序名称。</p>
<p>例：<br>在GNOME中，有一个名为Disk Usage Analyzer的应用程序。但是，从终端运行它的命令不是disk-usage-analyzer。要查找其命令，您可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep &quot;disk usage&quot;</span><br></pre></td></tr></table></figure>

<p>输出应包含此条目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alaa@aa-lu:~$ dpkg -l | grep &quot;disk usage&quot;</span><br><span class="line">ii  baobab            3.6.4-0ubuntu1          i386         GNOME disk usage analyzer</span><br></pre></td></tr></table></figure>

<p>看第二栏。实际运行磁盘使用率分析器的命令是<code>baobab</code>。</p>
<blockquote>
<p>参考目录</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://ubuntuqa.com/article/90.html">如何在登录时自动启动应用程序？</a></li>
<li><a target="_blank" rel="noopener" href="https://ubuntuqa.com/article/1326.html">如何找出应用程序的终端命令？</a></li>
</ul>
<h1 id="clash-API-使用"><a href="#clash-API-使用" class="headerlink" title="clash API 使用"></a>clash API 使用</h1><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>首先，阅读Clash的API的文档<a target="_blank" rel="noopener" href="https://clash.gitbook.io/doc/restful-api/proxies">RESTful - Proxies</a></p>
<p><code>GET</code> 获取所有代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proxies</span><br></pre></td></tr></table></figure>

<p><code>PUT</code> 切换 Selector 中选中的代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proxies/&lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>（这边的<code>name</code>可以为节点名称，也可以为Selector。只要在<code>proxies/</code>后直接加上字符串就可以，不需要引号或者<code>:</code>）</p>
<p>当前接口只支持切换 Selector 中的代理</p>
<table>
<thead>
<tr>
<th align="left">Path Parameters</th>
<th align="left">Body Parameters</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left"><code>name</code></td>
</tr>
<tr>
<td align="left"><code>string</code></td>
<td align="left"><code>string</code></td>
</tr>
<tr>
<td align="left">代理Selector名称（大小写敏感）</td>
<td align="left">要切换的代理名字</td>
</tr>
</tbody></table>
<p>接着，<code>curl</code>使用指南 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南</a></p>
<p>最后，使用<code>curl</code>切换节点, 使用<code>/proxies</code>获取所有可用代理，然后<code>curl</code>发送PUT请求解决战斗。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;节点名&quot;&#125;&#x27;</span> http://localhost:port/proxies/&lt;name&gt;</span><br></pre></td></tr></table></figure>

<p><code>-H</code> 添加 HTTP 请求的标头<code>Content-Type: application/json</code>，根据链接2，不设置标头为<code>application/json</code>可能会有问题。</p>
<p><code>-d</code> 参数用于发送 POST 请求的数据体。</p>
<p>最后的网址为clash的<code>external-controller</code>的网址端口，最后Selector为要选择的<code>proxy-groups</code>的名称。</p>
<p>实际指令类似下面这条：</p>
<ul>
<li><p>获取命令</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET -H <span class="string">&quot;Content-Type: application/json&quot;</span> http://127.0.0.1:9090/proxies -o get.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改节点</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;香港-08&quot;&#125;&#x27;</span> http://127.0.0.1:9090/proxies/国外流量 -o put.json</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所有命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;香港-08&quot;&#125;&#x27;</span> http://127.0.0.1:9090/proxies/国外流量 -o put.json</span><br><span class="line">curl -X PUT -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;:&quot;香港-08&quot;&#125;&#x27;</span> http://127.0.0.1:9090/proxies/国外流量</span><br><span class="line"></span><br><span class="line">curl -X GET -H <span class="string">&quot;Content-Type: application/json&quot;</span> http://127.0.0.1:9090/proxies -o get.json</span><br><span class="line">curl -X GET -H <span class="string">&quot;Content-Type: application/json&quot;</span> http://127.0.0.1:9090/proxies</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a target="_blank" rel="noopener" href="https://sakronos.github.io/Note/2021/03/06/%E4%BD%BF%E7%94%A8Clash-APIj%E5%88%87%E6%8D%A2%E8%8A%82%E7%82%B9/">sakronos</a></li>
</ul>
<h1 id="cron创建定时任务"><a href="#cron创建定时任务" class="headerlink" title="cron创建定时任务"></a>cron创建定时任务</h1><p>cron是创建定时任务的方法，定时任务称为cronjob，它是在crontab文件中创建的。这是Linux系统用户创建定时任务最简单，也是最古老的方法。</p>
<img data-src="/2024/01/04/194/640-20240107173003244.png" class="" title="图片">

<h2 id="编写定时任务"><a href="#编写定时任务" class="headerlink" title="编写定时任务"></a>编写定时任务</h2><p>要创建定时任务，可以使用 <code>-e</code> 选项编辑crontab：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure>

<p>这将使用默认的文本编辑器打开crontab。要设置默认的文本编辑器，可以使用编辑器环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ EDITOR=nano crontab -e</span><br></pre></td></tr></table></figure>

<h2 id="cron-语法"><a href="#cron-语法" class="headerlink" title="cron 语法"></a>cron 语法</h2><p>要创建一个定时任务，可以编写一个cron表达式，后跟定时任务需要执行的命令。cron表达式在命令运行时进行调度：</p>
<ul>
<li>分钟（0 - 59）</li>
<li>小时（0 - 23）</li>
<li>日（1 - 31）</li>
<li>月（1 - 12）</li>
<li>星期（0 - 6，0是星期天）</li>
</ul>
<p>字段中的星号（<code>*</code>）转换为“每个”。例如，此表达式在每个月的每一天每小时的第0分钟运行备份脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * /opt/backup.sh</span><br></pre></td></tr></table></figure>

<p>下面这个例子在每个星期天上午的3：30执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 3 * * 0 /opt/backup.sh</span><br></pre></td></tr></table></figure>

<h2 id="简化语法"><a href="#简化语法" class="headerlink" title="简化语法"></a>简化语法</h2><p>最新版本的cron已经实现了简单的语法，而不是cron表达式：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@hourly</code></td>
<td>在每天的每个小时的第0分钟运行；</td>
</tr>
<tr>
<td><code>@weekly</code></td>
<td>在每周的星期天的第0个小时第0分钟运行；</td>
</tr>
<tr>
<td><code>@monthly</code></td>
<td>在每个月的第一天的第0小时第0分钟运行；</td>
</tr>
</tbody></table>
<p>例如，下面语句在每天的午夜零点执行备份任务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/backup.sh @daily</span><br></pre></td></tr></table></figure>

<h2 id="怎样结束一个定时任务"><a href="#怎样结束一个定时任务" class="headerlink" title="怎样结束一个定时任务"></a>怎样结束一个定时任务</h2><p>一旦你开始了一个定时任务，它就被设计成永远按计划运行。要在启动定时任务后停止它，必须编辑crontab，删除触发作业的行，然后保存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ EDITOR=nano crontab -e</span><br></pre></td></tr></table></figure>

<p>要停止正在运行的作业，请使用标准Linux进程命令停止正在运行的进程。</p>
<h2 id="它是自动化的"><a href="#它是自动化的" class="headerlink" title="它是自动化的"></a>它是自动化的</h2><p>一旦你编写完crontab后，保存并退出编辑器，你的定时任务就已经安排好了，cron将会完成剩余所有的工作。</p>
<h1 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h1><p>当你在使用 Linux 系统的时候，突然有一个进程导致计算机的运行速度变慢，而这个进程又是一个不怎么重要的进程，所以你想要停止这个进程。</p>
<p>如果命令或者进程正在前台运行，则可以使用 <code>Ctrl+C</code> 终端快捷方式。但是，如果进程不可见（在后台运行），则可以使用专用命令终止它。</p>
<p>术语“终止进程”是指在执行过程中停止进程。如果知道<strong>进程ID（PID）</strong>，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;signal&gt; &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的语法中，<code>signal</code> 指的是要发送用于终止的 kill 信号，<code>PID</code> 指的是进程的ID。</p>
<p>还有一个 <code>killall</code> 命令，在本文中也会涉及。</p>
<p>在开始终止进程之前，你需要了解一些事情。例如，有哪些终止信号可用，如何找到PID等。</p>
<p>我们先来了解一下信号 (<code>signals</code>) 。</p>
<h2 id="Linux中的终止信号"><a href="#Linux中的终止信号" class="headerlink" title="Linux中的终止信号"></a>Linux中的终止信号</h2><p>当一个进程被操作系统或用户终止时，换句话说也就是当进程不是自己完成而结束时，它将被发送一个终端信号。</p>
<p>以下是可用的终止信号：</p>
<table>
<thead>
<tr>
<th>**信号 **</th>
<th>**数字值 **</th>
<th>**描述 **</th>
</tr>
</thead>
<tbody><tr>
<td><code>SIGHUP</code></td>
<td>1</td>
<td>信号挂起：当控制它的终端关闭时，发送给进程。</td>
</tr>
<tr>
<td><code>SIGINT</code></td>
<td>2</td>
<td>信号中断：当用户终止进程时发送给进程的信号。（例如<code>Ctrl+X</code>）</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>9</td>
<td>信号终止：立即退出进程的信号，不允许它保存当前状态。</td>
</tr>
<tr>
<td><code>SIGTERM</code></td>
<td>15</td>
<td>信号终止：发送到信号以请求终止进程。进程可以忽略此信号。但这是终止进程的首选方式，因为它可以在进程接收到SIGTERM时释放资源。</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>19 (for x86, ARM and most others)<br>17 (for Alpha)<br>23 (for MIPS)<br>24 (for PARISC)</td>
<td>信号停止：用于停止进程的信号，但稍后将恢复。</td>
</tr>
</tbody></table>
<p>信号 9 和 15最常用，这里有<a target="_blank" rel="noopener" href="https://linuxhandbook.com/sigterm-vs-sigkill/">一篇文章</a>可了解 <code>SIGKILL</code> 和 <code>SIGTERM</code> 的区别。</p>
<h2 id="获取进程的PID"><a href="#获取进程的PID" class="headerlink" title="获取进程的PID"></a>获取进程的PID</h2><p>你还需要知道要终止的流程的详细信息。使用 <code>kill</code> 命令时，必须提供进程的ID（PID）。你可以从进程名称中获取PID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof exact_process_name</span><br></pre></td></tr></table></figure>

<h2 id="在Linux命令行中终止进程"><a href="#在Linux命令行中终止进程" class="headerlink" title="在Linux命令行中终止进程"></a>在Linux命令行中终止进程</h2><p>我们先来了解 <code>kill</code> 命令，因为它比 <code>killall</code> 更常用。</p>
<h3 id="使用-kill-命令"><a href="#使用-kill-命令" class="headerlink" title="使用 kill 命令"></a>使用 kill 命令</h3><p><code>kill</code> 命令要求你知道要终止的进程的ID以及终止信号（可选）。终止命令的语法很简单，上文也提到过：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [signal] &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>终止信号是可选的，如果没有提供信号，<code>kill</code> 默认发送<code>SIGTERM</code>（15）。</p>
<p>我启动了<code>sleep</code>命令的后台进程（它给了我一个PID），我们尝试使用 <code>kill</code> 命令终止它。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">sleep</span> 120 &amp;</span><br><span class="line">[1] 125686</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">kill</span> 125686</span><br><span class="line">[1]  + terminated  <span class="built_in">sleep</span> 120</span><br></pre></td></tr></table></figure>

<p>如果要使用终止信号，可以使用数值或信号本身：</p>
<ul>
<li><p>数值</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sleep</span> 120 &amp;</span><br><span class="line">[1] 125759</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">kill</span> -9 125759</span><br><span class="line">[1]  + killed     <span class="built_in">sleep</span> 120</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sleep</span> 120 &amp;</span><br><span class="line">[1] 125746</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">kill</span> -SIGKILL 125746</span><br><span class="line">[1]  + killed     <span class="built_in">sleep</span> 120</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注：如果<code>kill</code>命令未指定信号，则默认情况下使用<code>SIGTERM</code>（15）。</p>
<h3 id="使用-killall-命令"><a href="#使用-killall-命令" class="headerlink" title="使用 killall 命令"></a>使用 killall 命令</h3><p>如果您不知道一个进程的PID是什么，或者要终止的进程有多个子进程，并且您希望同时终止子进程和父进程，那么可以使用<code>killall</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall [signal] &lt;process-name&gt;</span><br></pre></td></tr></table></figure>

<p>与<code>kill</code>命令类似，指定终止信号是可选的。当未指定终止信号时，<code>killall</code> 将发送<code>SIGTERM</code>（15）以正常关闭所述进程。</p>
<p>为了演示 <code>killall</code> 的使用，我们将终止两个正在运行的<code>sleep</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sleep</span> 120 &amp;</span><br><span class="line">[1] 18609</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sleep</span> 2000 &amp;</span><br><span class="line">[2] 18612</span><br><span class="line"></span><br><span class="line">$ killall <span class="built_in">sleep</span></span><br><span class="line">[1]-  Terminated              <span class="built_in">sleep</span> 120</span><br><span class="line">[2]+  Terminated              <span class="built_in">sleep</span> 2000</span><br></pre></td></tr></table></figure>

<p>此外，你可以使用 <code>-e</code> 标志来查找与进程名称匹配的PID。</p>
<h3 id="使用-pkill-命令"><a href="#使用-pkill-命令" class="headerlink" title="使用 pkill 命令"></a>使用 pkill 命令</h3><p>另一个 kill 命令是 <code>pkill</code> 命令。它是 <code>pgrep</code> 和 <code>kill</code> 命令的“组合”。</p>
<p><code>killall</code> 可以终止所有与进程名称匹配的进程。</p>
<p><code>pkill</code> 使用模式匹配来匹配进程并终止它们。如下语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pkill [options] pattern</span><br></pre></td></tr></table></figure>

<p><code>pkill</code> 命令提供以下几个选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-u</code></td>
<td>特定用户所拥有的进程</td>
</tr>
<tr>
<td><code>-x</code></td>
<td>完全匹配模式的进程</td>
</tr>
<tr>
<td><code>-signal</code></td>
<td>指定终止信号（默认为SIGTERM）</td>
</tr>
</tbody></table>
<p>假设我的计算机上有一个当前不应该运行任何进程的来宾用户，我想终止它们。该怎么做呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep <span class="built_in">sleep</span></span><br><span class="line">guest     126061  0.0  0.0   6664   428 pts/3    S    10:14   0:00 <span class="built_in">sleep</span> 50</span><br><span class="line"></span><br><span class="line">$ sudo pkill -u guest</span><br></pre></td></tr></table></figure>

<p>请注意，我使用 <code>sudo</code> 是因为我处理的进程不属于我当前的用户。</p>
<h3 id="kill-和-killall-命令的区别"><a href="#kill-和-killall-命令的区别" class="headerlink" title="kill 和 killall 命令的区别"></a>kill 和 killall 命令的区别</h3><p><code>kill</code> 命令应对的是进程ID（<code>PID</code>），它会根据你提供的 <code>PID</code> 来终止进程。而 <code>killall</code> 针对的是进程名称，它会终止给定进程名称的所有进程。例如，有三个 <code>mysql</code> 实例正在运行，<code>killall</code> 会终止所有的这三个进程：使用 <code>killall mysql</code> 命令；而如果是用 <code>kill</code> 的话，你需要提供这三个实例的PID来终止它们：<code>kill PID1 PID2 PID3</code>。</p>
<p>简单地说，<code>kill</code> 命令与 <code>PID</code>（通常是单个 <code>PID</code>）一起使用，<code>killall</code> 命令与进程名称一起使用，并使用进程名称杀死所有进程。</p>
<p>来举个例子。</p>
<p>假如我们启动了三个名为 <code>evince</code> 的程序实例，让其在后台运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">evince &amp;</span><br><span class="line">evince &amp;</span><br><span class="line">evince &amp;</span><br></pre></td></tr></table></figure>

<p>那么现在，我们有了三个名为 <code>evince</code> 的进程，但是每个进程的进程ID是不同的。</p>
<p>要使用 <code>kill</code> 命令强制停止进程，需要提供所需进程的<code>PID</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> PID1</span><br></pre></td></tr></table></figure>

<p>但是，如果使用 killall 的话，提供进程名称，它将杀掉所有使用该进程名称命名的实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall evince</span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<img data-src="/2024/01/04/194/640-20240109081313634.png" class="" title="图片">

<p>现在我们应该能直观的注意到，<code>kill</code> 命令需要进程ID，<code>killall</code>命令需要进程名称。</p>
<img data-src="/2024/01/04/194/640.jpeg" class="" title="图片">

<p><strong>使用哪个命令呢，kill 还是 killall ？</strong></p>
<p>由于 <code>kill</code> 命令可用于单个进程，因此更安全。在使用 <code>killall</code> 命令之前，你需要确保没有其他类似名称的进程（并且你不想停掉的）正在运行着。</p>
<h1 id="命令替换和变量替换"><a href="#命令替换和变量替换" class="headerlink" title="命令替换和变量替换"></a>命令替换和变量替换</h1><h2 id="和"><a href="#和" class="headerlink" title="$()和``"></a>$()和``</h2><p>在操作上，这两者都是达到相应的效果，但是建议使用<code>$()</code>，理由如下：</p>
<ol>
<li><code>｀｀</code>很容易与”搞混乱，尤其对初学者来说。</li>
<li>在多层次的复合替换中，<code>｀｀</code>必须要额外的转义字符处理（反斜线），而<code>$( )</code>比较直观。</li>
<li>最后，<code>$( )</code>的弊端是，并不是所有的类unix系统都支持这种方式，但反引号是肯定支持的。</li>
</ol>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>eval 属 Shell 内建命令，通过连接参数构造命令。</p>
<p>eval可以读取一连串的参数，然后按照参数特性来执行。参数数目不限，使用空格分隔每个参数，构造的命令应由 Shell 读取和执行。</p>
<p><strong>eval会对后面的命令进行两遍扫描</strong></p>
<ol>
<li>如果第一遍扫描后，命令是个普通命令，则执行此命令；</li>
<li>如果命令中含有变量的间接引用，则保证间接引用的语义。</li>
</ol>
<p>也就是说，eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。<strong>因此，eval命令适用于那些一次扫描无法实现其功能的变量。</strong></p>
<p>eval 执行以下两个步骤：</p>
<ol>
<li>step1. 执行变量替换，类似与C语言的宏替代；</li>
<li>step2. 执行替换后的命令串。</li>
</ol>
<h3 id="分析替换原则"><a href="#分析替换原则" class="headerlink" title="分析替换原则"></a>分析替换原则</h3><p><strong>step1. 定义变量</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ a=10</span><br><span class="line">$ b=a</span><br><span class="line">$ c=b</span><br></pre></td></tr></table></figure>

<p><strong>step2. 运行以下命令查看结果</strong></p>
<ul>
<li><p>情景1</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="string">&quot;x=<span class="variable">$c</span>&quot;</span>; <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p> 解释 <code>eval &quot;x=$c&quot;</code>: </p>
<p> step1. 将 <code>$c</code> 替换成 <code>b</code></p>
<p> step2. 执行 <code>x=b</code></p>
</li>
<li><p>情景2</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="string">&quot;x=\$<span class="variable">$c</span>&quot;</span>; <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p> 解释<code>eval &quot;x=\$$c&quot;</code>:</p>
<p> step1. 第一次扫描, 要执行的命令变为 <code>x=$b</code></p>
<p> step2. 执行 <code>x=$b</code></p>
</li>
<li><p>情景3</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> <span class="string">&quot;x=\$\$<span class="variable">$c</span>&quot;</span>; <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">3432188b</span><br></pre></td></tr></table></figure>

<p> 解释 <code>eval &quot;x=\$\$$c&quot;</code>:</p>
<p> step1. 第一次扫描, 要执行的命令变为 <code>x=$$b</code></p>
<p> step2. 执行 <code>x=$$b</code> (其中: <code>$$</code>为脚本运行的当前进程ID号, 这里为<code>3432188</code>)</p>
</li>
</ul>
<h3 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h3><ol>
<li><p>回显变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ NAME=foo</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$NAME</span></span><br><span class="line">foo</span><br><span class="line">$ <span class="built_in">eval</span> <span class="built_in">echo</span> <span class="variable">$NAME</span></span><br><span class="line">foo</span><br></pre></td></tr></table></figure>
</li>
<li><p>先替换变量再执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test.txt</span><br><span class="line">Hello World!</span><br><span class="line">$ <span class="built_in">command</span>=<span class="string">&quot;cat test.txt&quot;</span>; <span class="built_in">echo</span> <span class="variable">$command</span></span><br><span class="line"><span class="built_in">cat</span> test.txt</span><br><span class="line">$ <span class="built_in">eval</span> <span class="variable">$command</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取传给脚本或函数的最后一个参数。</p>
<p>我们知道 Shell 中使用特殊字符<code>$#</code>可以获取传递给脚本或函数的参数个数，使用<code>$n</code>获取参数(n 为数字)，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，所以<code>$$#</code>表示最后一个参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test.sh</span><br><span class="line"><span class="comment">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> \$<span class="variable">$#</span></span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">echo</span> \$<span class="variable">$#</span></span><br><span class="line"></span><br><span class="line">$ ./test.sh firstarg lastarg</span><br><span class="line"><span class="variable">$2</span></span><br><span class="line">lastarg</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用动态创建的变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line">label=<span class="string">&quot;Looping complete. Total:&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> &#123;1..10&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">eval</span> x<span class="variable">$n</span>=<span class="variable">$n</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Loop&quot;</span> $x<span class="variable">$n</span></span><br><span class="line">  ((total+=$x<span class="variable">$n</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$x1</span> <span class="variable">$x2</span> <span class="variable">$x3</span> <span class="variable">$x4</span> <span class="variable">$x5</span> <span class="variable">$x6</span> <span class="variable">$x7</span> <span class="variable">$x8</span> <span class="variable">$x9</span> <span class="variable">$x10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$label</span> <span class="variable">$total</span></span><br></pre></td></tr></table></figure>

<p>它创建了一个名为 <code>total</code> 的变量，其中包含我们创建的变量值的总和。然后它创建一个名为 <code>label</code> 的字符串变量。这是一个简单的文本字符串。</p>
<p>我们将循环 10 次并创建 10 个名为 <code>x1</code> 到 <code>x10</code> 的变量。循环主体中的 <code>eval</code> 语句提供“x”并采用循环计数器 <code>$n</code> 的值来创建变量名称。同时，它将新变量设置为循环计数器 <code>$n</code> 的值。</p>
<p>它将新变量打印到终端窗口，然后使用新变量的值递增 <code>total</code> 变量。</p>
<p>在循环之外，10 个新变量再次打印，全部打印在一行上。请注意，我们也可以通过它们的真实名称来引用变量，而无需使用它们名称的计算或派生版本。</p>
<p>最后，我们打印 <code>total</code> 变量的值。</p>
</li>
</ol>
<blockquote>
<p>参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man1/eval.1p.html">eval手册</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2135146">https://cloud.tencent.com/developer/article/2135146</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37964071/article/details/80930704">https://blog.csdn.net/baidu_37964071/article/details/80930704</a></li>
</ul>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Qeuroal
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://qeuroal.top/2024/01/04/194/" title="194. Linux中的命令之进程与程序">http://qeuroal.top/2024/01/04/194/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"><i class="fa fa-tag"></i> linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/01/04/215/" rel="prev" title="215. sytemctl">
                  <i class="fa fa-angle-left"></i> 215. sytemctl
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/01/20/195/" rel="next" title="195. 读懂diff">
                  195. 读懂diff <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Qeuroal</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Qeuroal" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
