<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qeuroal.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="简介Collection   Java 标准库自带的 java.util 包提供了集合类：Collection，它是除 Map 外所有其他集合类的根接口。Java 的 java.util 包主要提供了以下三种类型的集合：  List：一种有序列表的集合，例如，按索引排列的 Student 的 List； Set：一种保证没有重复元素的集合，例如，所有无重复名称的 Student 的 Set； Ma">
<meta property="og:type" content="article">
<meta property="og:title" content="125. Java 集合">
<meta property="og:url" content="http://qeuroal.top/2021/01/16/125/index.html">
<meta property="og:site_name" content="Qeuroal&#39;s Blog">
<meta property="og:description" content="简介Collection   Java 标准库自带的 java.util 包提供了集合类：Collection，它是除 Map 外所有其他集合类的根接口。Java 的 java.util 包主要提供了以下三种类型的集合：  List：一种有序列表的集合，例如，按索引排列的 Student 的 List； Set：一种保证没有重复元素的集合，例如，所有无重复名称的 Student 的 Set； Ma">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-16T06:37:07.000Z">
<meta property="article:modified_time" content="2025-12-08T06:36:58.308Z">
<meta property="article:author" content="Qeuroal">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://qeuroal.top/2021/01/16/125/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qeuroal.top/2021/01/16/125/","path":"2021/01/16/125/","title":"125. Java 集合"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>125. Java 集合 | Qeuroal's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qeuroal's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">静幽正治</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">1.1.</span> <span class="nav-text">Collection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#List"><span class="nav-number">2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#List-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">List 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">List 的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-List"><span class="nav-number">2.3.</span> <span class="nav-text">创建 List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86List"><span class="nav-number">2.4.</span> <span class="nav-text">遍历List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E5%92%8CArray%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.5.</span> <span class="nav-text">List和Array转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">2.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E5%86%99equal%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">编写equal方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99equals"><span class="nav-number">3.1.</span> <span class="nav-text">编写equals</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">3.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Map"><span class="nav-number">4.</span> <span class="nav-text">使用Map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86Map"><span class="nav-number">4.1.</span> <span class="nav-text">遍历Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="nav-number">4.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E5%86%99equals%E5%92%8ChashCode"><span class="nav-number">5.</span> <span class="nav-text">编写equals和hashCode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="nav-number">5.1.</span> <span class="nav-text">延伸阅读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="nav-number">5.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8EnumMap"><span class="nav-number">6.</span> <span class="nav-text">使用EnumMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="nav-number">6.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8TreeMap"><span class="nav-number">7.</span> <span class="nav-text">使用TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="nav-number">7.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Properties"><span class="nav-number">8.</span> <span class="nav-text">使用Properties</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">8.1.</span> <span class="nav-text">读取配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">8.2.</span> <span class="nav-text">写入配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-number">8.3.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="nav-number">8.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Set"><span class="nav-number">9.</span> <span class="nav-text">使用Set</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="nav-number">9.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Queue"><span class="nav-number">10.</span> <span class="nav-text">使用Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-9"><span class="nav-number">10.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8PriorityQueue"><span class="nav-number">11.</span> <span class="nav-text">使用PriorityQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-10"><span class="nav-number">11.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Deque"><span class="nav-number">12.</span> <span class="nav-text">使用Deque</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-11"><span class="nav-number">12.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Stack"><span class="nav-number">13.</span> <span class="nav-text">使用Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">13.1.</span> <span class="nav-text">Stack的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">13.2.</span> <span class="nav-text">计算中缀表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-12"><span class="nav-number">13.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Iterator"><span class="nav-number">14.</span> <span class="nav-text">使用Iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-13"><span class="nav-number">14.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Collections"><span class="nav-number">15.</span> <span class="nav-text">使用Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%9B%86%E5%90%88"><span class="nav-number">15.1.</span> <span class="nav-text">创建空集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%95%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88"><span class="nav-number">15.2.</span> <span class="nav-text">创建单元素集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">15.3.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%97%E7%89%8C"><span class="nav-number">15.4.</span> <span class="nav-text">洗牌</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="nav-number">15.5.</span> <span class="nav-text">不可变集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="nav-number">15.6.</span> <span class="nav-text">线程安全集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-14"><span class="nav-number">15.7.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qeuroal"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qeuroal</p>
  <div class="site-description" itemprop="description">大人者，不失其赤子之心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Qeuroal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qeuroal" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2021/01/16/125/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="125. Java 集合 | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          125. Java 集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-16 14:37:07" itemprop="dateCreated datePublished" datetime="2021-01-16T14:37:07+08:00">2021-01-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>   Java 标准库自带的 java.util 包提供了集合类：Collection，它是除 Map 外所有其他集合类的根接口。Java 的 java.util 包主要提供了以下三种类型的集合：</p>
<ul>
<li>List：一种有序列表的集合，例如，按索引排列的 Student 的 List；</li>
<li>Set：一种保证没有重复元素的集合，例如，所有无重复名称的 Student 的 Set；</li>
<li>Map：一种通过键值（key-value）查找的映射表集合，例如，根据 Student 的 name 查找对应 Student 的 Map。</li>
</ul>
<p>   Java 集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是 List，具体的实现类有 ArrayList，LinkedList 等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 只能放入 String 类型</span></span><br></pre></td></tr></table></figure><br>   最后，Java 访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<p>   由于 Java 的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li>Hashtable：一种线程安全的 Map 实现；</li>
<li>Vector：一种线程安全的 List 实现；</li>
<li>Stack：基于 Vector 实现的 LIFO 的栈。</li>
</ul>
<p>   还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li>Enumeration<E>：已被 Iterator<E > 取代。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Java 的集合类定义在 java.util 包中，支持泛型，主要提供了 3 种集合类，包括 List，Set 和 Map。Java 集合使用统一的 Iterator 遍历，尽量不要使用遗留接口。</li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>   List 是最基础的一种集合：它是一种有序列表。<br>   List 的行为和数组几乎完全相同：List 内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，List 的索引和数组一样，从 <code>0</code> 开始。<br>   数组和 List 类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。</p>
<p>   在实际应用中，需要增删元素的有序列表，我们使用最多的是 ArrayList。实际上，ArrayList 在内部使用了数组来存储所有元素。例如，一个 ArrayList 拥有 5 个元素，实际数组大小为 6（即有一个空位）<br>   当添加一个元素并指定索引到 ArrayList 时，ArrayList 自动移动需要移动的元素;<br>   然后，往内部指定索引的数组位置添加一个元素，然后把 size 加 1;<br>   继续添加元素，但是数组已满，没有空闲位置的时候，ArrayList 先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组;<br>   现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时 size 加 1;<br>   可见，ArrayList 把添加和删除的操作封装起来，让我们操作 List 类似于操作数组，却不用关心内部元素如何移动。</p>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List<E> 接口</h2><ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>int remove(int index)</code></li>
<li>删除某个元素：<code>int remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>   但是，实现 List 接口并非只能通过数组（即 ArrayList 的实现方式）来实现，另一种 LinkedList 通过 “链表” 也实现了 List 接口。在 LinkedList 中，它的内部每个元素都指向下一个元素：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐</span><br><span class="line">HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │</span><br><span class="line">        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘</span><br></pre></td></tr></table></figure><br>   我们来比较一下 ArrayList 和 LinkedList：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">ArrayList</th>
<th align="center">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="center">获取指定元素</td>
<td align="center">速度很快</td>
<td align="center">需要从头开始查找元素</td>
</tr>
<tr>
<td align="center">添加元素到末尾</td>
<td align="center">速度很快</td>
<td align="center">速度很快</td>
</tr>
<tr>
<td align="center">在指定位置添加 &#x2F; 删除</td>
<td align="center">需要移动元素</td>
<td align="center">不需要移动元素</td>
</tr>
<tr>
<td align="center">内存占用</td>
<td align="center">少</td>
<td align="center">较大</td>
</tr>
<tr>
<td align="center">通常情况下，我们总是优先使用 ArrayList。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="List-的特点"><a href="#List-的特点" class="headerlink" title="List 的特点"></a>List 的特点</h2><p>   使用 List 时，我们要关注 List 接口的规范。List 接口允许我们添加重复的元素，即 List 内部的元素可以重复：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">       list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=2</span></span><br><span class="line">       list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 允许重复添加元素，size=3</span></span><br><span class="line">       System.out.println(list.size());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   List 还允许添加 null：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      list.add(<span class="string">&quot;apple&quot;</span>); <span class="comment">// size=1</span></span><br><span class="line">      list.add(<span class="literal">null</span>); <span class="comment">// size=2</span></span><br><span class="line">      list.add(<span class="string">&quot;pear&quot;</span>); <span class="comment">// size=3</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>); <span class="comment">// null</span></span><br><span class="line">      System.out.println(second);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建-List"><a href="#创建-List" class="headerlink" title="创建 List"></a>创建 List</h2><p>   除了使用 ArrayList 和 LinkedList，我们还可以通过 List 接口提供的 of() 方法，根据给定元素快速创建 List：<br>   除了使用 ArrayList 和 LinkedList，我们还可以通过 List 接口提供的 of() 方法，根据给定元素快速创建 List：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><br>   但是 List.of() 方法不接受 null 值，如果传入 null，会抛出 NullPointerException 异常。</p>
<h2 id="遍历List"><a href="#遍历List" class="headerlink" title="遍历List"></a>遍历List</h2><p>   和数组类型，我们要遍历一个 List，完全可以用 for 循环根据索引配合 get(int) 方法遍历：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   但这种方式并不推荐，一是代码复杂，二是因为get(int)方法只有ArrayList的实现是高效的，换成LinkedList后，索引越大，访问速度越慢。<br>   所以我们要始终坚持使用迭代器Iterator来访问List。Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。<br>   Iterator对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用Iterator遍历List代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   有童鞋可能觉得使用 Iterator 访问 List 的代码比使用索引更复杂。但是，要记住，通过 Iterator 遍历 List 永远是最高效的方式。并且，由于 Iterator 遍历是如此常用，所以，Java 的 for each 循环本身就可以帮我们使用 Iterator 遍历。把上面的代码再改写如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   上述代码就是我们编写遍历 List 的常见代码。</p>
<p>   实际上，只要实现了 Iterable 接口的集合类都可以直接用 for each 循环来遍历，Java 编译器本身并不知道如何遍历集合对象，但它会自动把 for each 循环变成 Iterator 的调用，原因就在于 <code>Iterable</code> 接口定义了一个 <code>Iterator&lt;E&gt; iterator()</code> 方法，强迫集合类必须返回一个 <code>Iterator</code> 实例。</p>
<blockquote>
<p>Note: Java的 <code>for - each</code> 遍历不是只读的。</p>
</blockquote>
<h2 id="List和Array转换"><a href="#List和Array转换" class="headerlink" title="List和Array转换"></a>List和Array转换</h2><p>   把List变为Array有三种方法，第一种是调用toArray()方法直接返回一个Object[]数组：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      Object[] array = list.toArray();</span><br><span class="line">      <span class="keyword">for</span> (Object s : array) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   这种方法会丢失类型信息，所以实际应用很少。</p>
<p>   第二种方式是给 toArray(T[]) 传入一个类型相同的 Array，List 内部自动把元素复制到传入的 Array 中：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">      Integer[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">for</span> (Integer n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   注意到这个 <code>toArray(T[])</code> 方法的泛型参数 <code>&lt;T&gt;</code> 并不是 List 接口定义的泛型参数 <code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入 Number 类型的数组，返回的仍然是 Number 类型：<br>   注意到这个 toArray(T[]) 方法的泛型参数 <code>&lt;T&gt;</code> 并不是 List 接口定义的泛型参数 <code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入 Number 类型的数组，返回的仍然是 Number 类型：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">      Number[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Number</span>[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">for</span> (Number n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于 <code>List</code> 的元素是 <code>Integer</code>，所以无法放入 String 数组，这个方法会抛出 <code>ArrayStoreException</code>。<br>   如果我们传入的数组大小和 <code>List</code> 实际的元素个数不一致怎么办？根据 List 接口的文档，我们可以知道：<br>   如果传入的数组不够大，那么 <code>List</code> 内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比 <code>List</code> 元素还要多，那么填充完元素后，剩下的数组元素一律填充 null。<br>   实际上，最常用的是传入一个 “恰好” 大小的数组：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br></pre></td></tr></table></figure><br>   最后一种更简洁的写法是通过 List 接口定义的 T[] <code>toArray(IntFunction&lt;T[]&gt; generator)</code> 方法：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><br>   这种函数式写法我们会在后续讲到。<br>   反过来，把Array变为List就简单多了，通过List.of(T…)方法最简单：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure><br>   对于 JDK 11 之前的版本，可以使用 <code>Arrays.asList(T...)</code> 方法把数组转换成 List。<br>   要注意的是，返回的 List 不一定就是 <code>ArrayList</code> 或者 <code>LinkedList</code>，因为 List 只是一个接口，如果我们调用 <code>List.of()</code>，它返回的是一个只读 <code>List</code>：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">       list.add(<span class="number">999</span>); <span class="comment">// UnsupportedOperationException</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   对只读 List 调用 <code>add()</code>、<code>remove()</code> 方法会抛出 <code>UnsupportedOperationException</code>。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>List是按索引顺序访问的长度可变的有序表，优先使用ArrayList而不是LinkedList；</li>
<li>可以直接使用for each遍历List；</li>
<li>List可以和Array相互转换。</li>
</ul>
<h1 id="编写equal方法"><a href="#编写equal方法" class="headerlink" title="编写equal方法"></a>编写equal方法</h1><p>   List 还提供了 <code>boolean contains(Object o)</code> 方法来判断 List 是否包含某个指定元素。此外，<code>int indexOf(Object o)</code> 方法可以返回某个元素的索引，如果元素不存在，就返回 <code>-1</code>。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">      System.out.println(list.contains(<span class="string">&quot;C&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">      System.out.println(list.contains(<span class="string">&quot;X&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">      System.out.println(list.indexOf(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">      System.out.println(list.indexOf(<span class="string">&quot;X&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   这里我们注意一个问题，我们往List中添加的<code>&quot;C&quot;</code>和调用<code>contains(&quot;C&quot;)</code>传入的<code>&quot;C&quot;</code>是不是同一个实例？</p>
<p>   如果这两个<code>&quot;C&quot;</code>不是同一个实例，这段代码是否还能得到正确的结果？我们可以改写一下代码测试一下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">      System.out.println(list.contains(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;C&quot;</span>))); <span class="comment">// true or false?</span></span><br><span class="line">      System.out.println(list.indexOf(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;C&quot;</span>))); <span class="comment">// 2 or -1?</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   因为我们传入的是<code>new String(&quot;C&quot;)</code>，所以一定是不同的实例。结果仍然符合预期，这是为什么呢？</p>
<p>   因为List内部并不是通过<code>==</code>判断两个元素是否相等，而是使用<code>equals()</code>方法判断两个元素是否相等，例如<code>contains()</code>方法可以实现如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span> &#123;</span><br><span class="line">   Object[] elementData;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i])) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   因此，要正确使用List的<code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写<code>equals()</code>方法，否则，放进去的实例，查找不到。我们之所以能正常放入String、Integer这些对象，是因为Java标准库定义的这些类已经正确实现了<code>equals()</code>方法。</p>
<p>   我们以Person对象为例，测试一下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Person&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">      );</span><br><span class="line">      System.out.println(list.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   不出意外，虽然放入了<code>new Person(&quot;Bob&quot;)</code>，但是用另一个<code>new Person(&quot;Bob&quot;)</code>查询不到，原因就是<code>Person</code>类没有覆写<code>equals()</code>方法。</p>
<h2 id="编写equals"><a href="#编写equals" class="headerlink" title="编写equals"></a>编写equals</h2><p>   JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">   <span class="comment">//this - s1</span></span><br><span class="line">   <span class="comment">//obj - s2</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。</p>
<p>   如何正确编写equals()方法？equals()方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非 null 的 x 来说，<code>x.equals(x)</code> 必须返回 true；</li>
<li>对称性（Symmetric）：对于非 null 的 x 和 y 来说，如果 <code>x.equals(y)</code> 为 true，则 <code>y.equals(x)</code> 也必须为 true；</li>
<li>传递性（Transitive）：对于非 null 的 x、y 和 z 来说，如果 <code>x.equals(y)</code> 为 true，<code>y.equals(z)</code> 也为 true，那么 <code>x.equals(z)</code> 也必须为 true；</li>
<li>一致性（Consistent）：对于非 null 的 x 和 y 来说，只要 x 和 y 状态不变，则 <code>x.equals(y)</code> 总是一致地返回 true 或者 false；</li>
<li>对 null 的比较：即 <code>x.equals(null)</code> 永远返回 false。</li>
</ul>
<p>   上述规则看上去似乎非常复杂，但其实代码实现equals()方法是很简单的，我们以Person类为例：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   首先，我们要定义“相等”的逻辑含义。对于Person类，如果name相等，并且age相等，我们就认为两个Person实例相等。</p>
<p>   因此，编写<code>equals()</code>方法如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   对于引用字段比较，我们使用equals()，对于基本类型字段的比较，我们使用<code>==</code>。<br>   如果this.name为null，那么equals()方法会报错，因此，需要继续改写如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">nameEquals</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.name == <span class="literal">null</span> &amp;&amp; p.name == <span class="literal">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.name != <span class="literal">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="built_in">this</span>.name.equals(p.name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> nameEquals &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   因此，我们总结一下<code>equals()</code>方法的正确编写方法：</p>
<ol>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回false；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<p>   使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。<br>   如果不调用List的<code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现<code>equals()</code>方法。</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在List中查找元素时，List的实现类通过元素的equals()方法比较两个元素是否相等，因此，放入的元素必须正确覆写equals()方法，Java标准库提供的String、Integer等已经覆写了equals()方法；</li>
<li>编写equals()方法可借助Objects.equals()判断。</li>
<li>如果不在List中查找元素，就不必覆写equals()方法。</li>
</ul>
<h1 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h1><p>   我们知道，List是一种顺序列表，如果有一个存储学生Student实例的List，要在List中根据name查找某个指定的Student的分数，应该怎么办？</p>
<p>   最简单的方法是遍历List并判断name是否相等，然后返回指定元素：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = ...</span><br><span class="line"><span class="type">Student</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Student s : list) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">&quot;Xiao Ming&quot;</span>.equals(s.name)) &#123;</span><br><span class="line">      target = s;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(target.score);</span><br></pre></td></tr></table></figure><br>   这种需求其实非常常见，即通过一个键去查询对应的值。使用List来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而Map这种键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）。</p>
<p>   用Map来实现根据name查询某个Student的代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">99</span>);</span><br><span class="line">      Map&lt;String, Student&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;Xiao Ming&quot;</span>, s); <span class="comment">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class="line">      <span class="type">Student</span> <span class="variable">target</span> <span class="operator">=</span> map.get(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br><span class="line">      System.out.println(target == s); <span class="comment">// true，同一个实例</span></span><br><span class="line">      System.out.println(target.score); <span class="comment">// 99</span></span><br><span class="line">      <span class="type">Student</span> <span class="variable">another</span> <span class="operator">=</span> map.get(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 通过另一个key查找</span></span><br><span class="line">      System.out.println(another); <span class="comment">// 未找到返回null</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.score = score;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   通过上述代码可知：<code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把key和value做了映射并放入Map。当我们调用<code>V get(K key)</code>时，就可以通过key获取到对应的value。如果key不存在，则返回<code>null</code>。和List类似，Map也是一个接口，最常用的实现类是<code>HashMap</code>。<br>   如果只是想查询某个key是否存在，可以调用<code>boolean containsKey(K key)</code>方法。<br>   如果我们在存储Map映射关系的时候，对同一个key调用两次<code>put()</code>方法，分别放入不同的value，会有什么问题呢？例如：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">      map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">      System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 123</span></span><br><span class="line">      map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">789</span>); <span class="comment">// 再次放入apple作为key，但value变为789</span></span><br><span class="line">      System.out.println(map.get(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// 789</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   重复放入<code>key-value</code>并不会有任何问题，但是<strong>一个key只能关联一个value</strong>。在上面的代码中，一开始我们把key对象”apple”映射到Integer对象123，然后再次调用<code>put()</code>方法把”apple”映射到789，这时，原来关联的value对象123就被“冲掉”了。实际上，put()方法的签名是<code>V put(K key, V value)</code>，如果放入的key已经存在，put()方法会返回被删除的旧的value，否则，返回null。</p>
<blockquote>
<p> 始终牢记：Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。</p>
</blockquote>
<p>   此外，在一个Map中，虽然key不能重复，但value是可以重复的：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">123</span>); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<h2 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h2><p>   对Map来说，要遍历key可以使用<code>for each</code>循环遍历Map实例的<code>keySet()</code>方法返回的Set集合，它包含不重复的key的集合：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">      map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">      map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   同时遍历key和value可以使用<code>for each</code>循环遍历Map对象的<code>entrySet()</code>集合，它包含每一个key-value映射：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">      map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">      map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   Map和List不同的是，Map存储的是key-value的映射关系，并且，它不保证顺序。在遍历的时候，遍历的顺序既不一定是put()时放入的key的顺序，也不一定是key的排序顺序。使用Map时，任何依赖顺序的逻辑都是不可靠的。以HashMap为例，假设我们放入”A”，”B”，”C”这3个key，遍历的时候，每个key会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的！</p>
<blockquote>
<p>遍历Map时，不可假设输出的key是有序的！</p>
</blockquote>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Map是一种映射表，可以通过key快速查找value。</li>
<li>可以通过for each遍历keySet()，也可以通过for each遍历entrySet()，直接获取key-value。</li>
<li>最常用的一种Map实现是HashMap。</li>
</ul>
<h1 id="编写equals和hashCode"><a href="#编写equals和hashCode" class="headerlink" title="编写equals和hashCode"></a>编写equals和hashCode</h1><p>   Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。<br>   以HashMap为例，观察下面的代码：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Person&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Jun&quot;</span>));</span><br><span class="line"></span><br><span class="line">map.get(<span class="string">&quot;a&quot;</span>); <span class="comment">// Person(&quot;Xiao Ming&quot;)</span></span><br><span class="line">map.get(<span class="string">&quot;x&quot;</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><br>   HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  ┌───┐</span><br><span class="line">0 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">1 │ ●─┼───&gt; Person(&quot;Xiao Ming&quot;)</span><br><span class="line">  ├───┤</span><br><span class="line">2 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">3 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">4 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">5 │ ●─┼───&gt; Person(&quot;Xiao Hong&quot;)</span><br><span class="line">  ├───┤</span><br><span class="line">6 │ ●─┼───&gt; Person(&quot;Xiao Jun&quot;)</span><br><span class="line">  ├───┤</span><br><span class="line">7 │   │</span><br><span class="line">  └───┘</span><br></pre></td></tr></table></figure><br>   如果key的值为”a”，计算得到的索引总是1，因此返回value为Person(“Xiao Ming”)，如果key的值为”b”，计算得到的索引总是5，因此返回value为Person(“Xiao Hong”)，这样，就不必遍历整个数组，即可直接读取key对应的value。<br>   当我们使用key存取value的时候，就会引出一个问题：<br>   我们放入Map的key是字符串”a”，但是，当我们获取Map的value时，传入的变量不一定就是放入的那个key对象。<br>   换句话讲，两个key应该是内容相同，但不一定是同一个对象。测试代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">      Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      map.put(key1, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">      map.get(key2); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">      System.out.println(key1 == key2); <span class="comment">// false</span></span><br><span class="line">      System.out.println(key1.equals(key2)); <span class="comment">// true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   因为在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。<br>   我们经常使用String作为key，因为String已经正确覆写了equals()方法。但如果我们放入的key是一个自己写的类，就必须保证正确覆写了equals()方法。<br>   我们再思考一下HashMap为什么能通过key直接计算出value存储的索引。相同的key对象（使用equals()判断时返回true）必须要计算出相同的索引，否则，相同的key每次取出的value就不一定对。<br>   通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。<br>   因此，正确使用Map必须保证：</p>
<ol>
<li>作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true；</li>
<li>作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：<ul>
<li>如果两个对象相等，则两个对象的hashCode()必须相等；</li>
<li>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</li>
</ul>
</li>
</ol>
<p>   即对应两个实例a和b：</p>
<ul>
<li>如果a和b相等，那么a.equals(b)一定为true，则a.hashCode()必须等于b.hashCode()；</li>
<li>如果a和b不相等，那么a.equals(b)一定为false，则a.hashCode()和b.hashCode()尽量不要相等。</li>
</ul>
<p>   上述第一条规范是正确性，必须保证实现，否则HashMap不能正常工作。<br>   而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。<br>   正确编写equals()的方法我们已经在<code>编写equals方法</code>一节中讲过了。</p>
<p>   在正确实现equals()的基础上，我们还需要正确实现hashCode()，即上述3个字段分别相同的实例，hashCode()返回的int必须相同：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   String firstName;</span><br><span class="line">   String lastName;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      h = <span class="number">31</span> * h + firstName.hashCode();</span><br><span class="line">      h = <span class="number">31</span> * h + lastName.hashCode();</span><br><span class="line">      h = <span class="number">31</span> * h + age;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   注意到String类已经正确实现了hashCode()方法，我们在计算Person的hashCode()时，反复使用31*h，这样做的目的是为了尽量把不同的Person实例的hashCode()均匀分布到整个int范围。<br>   和实现equals()方法遇到的问题类似，如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.hash()来计算：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Objects.hash(firstName, lastName, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   所以，编写equals()和hashCode()遵循的原则是：<br>   equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。<br>   另外注意，对于放入HashMap的value对象，没有任何要求。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>   既然HashMap内部使用了数组，通过计算key的hashCode()直接定位value所在的索引，那么第一个问题来了：hashCode()返回的int范围高达±21亿，先不考虑负数，HashMap内部使用的数组得有多大？<br>   实际上HashMap初始化时默认的数组大小只有16，任何key，无论它的hashCode()有多大，都可以简单地通过：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.hashCode() &amp; <span class="number">0xf</span>; <span class="comment">// 0xf = 15</span></span><br></pre></td></tr></table></figure><br>   把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p>
<p>   第二个问题：如果添加超过16个key-value到HashMap，数组不够用了怎么办？<br>   添加超过一定数量的key-value时，HashMap会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。例如，对长度为32的数组计算hashCode()对应的索引，计算方式要改为：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.hashCode() &amp; <span class="number">0x1f</span>; <span class="comment">// 0x1f = 31</span></span><br></pre></td></tr></table></figure><br>   由于扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大。如果我们确定要使用一个容量为10000个key-value的HashMap，更好的方式是创建HashMap时就指定容量：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><br>   虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（$2^{14}$）。</p>
<p>   最后一个问题：如果不同的两个key，例如”a”和”b”，它们的hashCode()恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求hashCode()尽量不相等），那么，当我们放入：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>));</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>));</span><br></pre></td></tr></table></figure><br>   时，由于计算出的数组索引相同，后面放入的”Xiao Hong”会不会把”Xiao Ming”覆盖了？<br>   当然不会！使用Map的时候，只要key不相同，它们映射的value就互不干扰。但是，在HashMap内部，确实可能存在不同的key，映射到相同的hashCode()，即相同的数组索引上，肿么办？<br>   我们就假设”a”和”b”这两个key最终计算出的索引都是5，那么，在HashMap的数组中，实际存储的不是一个Person实例，而是一个List，它包含两个Entry，一个是”a”的映射，一个是”b”的映射：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  ┌───┐</span><br><span class="line">0 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">1 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">2 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">3 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">4 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;</span><br><span class="line">  ├───┤</span><br><span class="line">6 │   │</span><br><span class="line">  ├───┤</span><br><span class="line">7 │   │</span><br><span class="line">  └───┘</span><br></pre></td></tr></table></figure><br>   在查找的时候，例如：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> map.get(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><br>   HashMap内部通过”a”找到的实际上是<code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个List，并找到一个Entry，它的key字段是”a”，才能返回对应的Person实例。<br>   我们把不同的key具有相同的hashCode()的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低，这就是为什么要尽量满足条件二：<br>   <strong>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</strong><br>   hashCode()方法编写得越好，HashMap工作的效率就越高。</p>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><ul>
<li>要正确使用HashMap，作为key的类必须正确覆写equals()和hashCode()方法；</li>
<li>一个类如果覆写了equals()，就必须覆写hashCode()，并且覆写规则是：<ul>
<li>如果equals()返回true，则hashCode()返回值必须相等；</li>
<li>如果equals()返回false，则hashCode()返回值尽量不要相等。</li>
</ul>
</li>
<li>实现hashCode()方法可以通过Objects.hashCode()辅助方法实现。</li>
</ul>
<h1 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h1><p>   因为HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。<br>   如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。<br>   我们以DayOfWeek这个枚举类型为例，为它做一个“翻译”功能：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(DayOfWeek.class);</span><br><span class="line">      map.put(DayOfWeek.MONDAY, <span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">      map.put(DayOfWeek.TUESDAY, <span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">      map.put(DayOfWeek.WEDNESDAY, <span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">      map.put(DayOfWeek.THURSDAY, <span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">      map.put(DayOfWeek.FRIDAY, <span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">      map.put(DayOfWeek.SATURDAY, <span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">      map.put(DayOfWeek.SUNDAY, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">      System.out.println(map);</span><br><span class="line">      System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   使用EnumMap的时候，我们总是用Map接口来引用它，因此，实际上把HashMap和EnumMap互换，在客户端看来没有任何区别。</p>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><ul>
<li>如果Map的key是enum类型，推荐使用EnumMap，既保证速度，也不浪费空间。</li>
<li>使用EnumMap的时候，根据面向抽象编程的原则，应持有Map接口。</li>
</ul>
<h1 id="使用TreeMap"><a href="#使用TreeMap" class="headerlink" title="使用TreeMap"></a>使用TreeMap</h1><p>   我们已经知道，HashMap是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历HashMap的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。<br>   还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。注意到SortedMap是接口，它的实现类是TreeMap。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┐</span><br><span class="line">      │Map│</span><br><span class="line">      └───┘</span><br><span class="line">        ▲</span><br><span class="line">   ┌────┴─────┐</span><br><span class="line">   │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">         ┌─────────┐</span><br><span class="line">         │ TreeMap │</span><br><span class="line">         └─────────┘</span><br></pre></td></tr></table></figure><br>   SortedMap保证遍历时以Key的顺序来进行排序。例如，放入的Key是”apple”、”pear”、”orange”，遍历的顺序一定是”apple”、”orange”、”pear”，因为String默认按字母排序：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>);</span><br><span class="line">      map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">2</span>);</span><br><span class="line">      map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// apple, orange, pear</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   使用TreeMap时，放入的Key必须实现<code>Comparable</code>接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。<br>   如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person p1, Person p2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>), <span class="number">1</span>);</span><br><span class="line">      map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>), <span class="number">2</span>);</span><br><span class="line">      map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>), <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">      System.out.println(map.get(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// 2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   Person(String name) &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#123;Person: &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   注意到Comparator接口要求实现一个比较方法，它负责比较传入的两个元素a和b，如果<code>a&lt;b</code>，则返回负数，通常是-1，如果a&#x3D;&#x3D;b，则返回0，如果<code>a&gt;b</code>，则返回正数，通常是1。TreeMap内部根据比较结果对Key进行排序。<br>   从上述代码执行结果可知，打印的Key确实是按照Comparator定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个new Person(“Bob”)作为Key，它会返回对应的Integer值2。<br>   另外，注意到Person类并未覆写equals()和hashCode()，**因为TreeMap不使用equals()和hashCode()**。<br>   我们来看一个稍微复杂的例子：这次我们定义了Student类，并用分数score进行排序，高分在前：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student p1, Student p2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">77</span>), <span class="number">1</span>);</span><br><span class="line">      map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>), <span class="number">2</span>);</span><br><span class="line">      map.put(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">99</span>), <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">for</span> (Student key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(map.get(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">66</span>))); <span class="comment">// null?</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">   Student(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.score = score;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> String.format(<span class="string">&quot;&#123;%s: score=%d&#125;&quot;</span>, name, score);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   在for循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的Key：<code>new Student(&quot;Bob&quot;, 66)</code>进行查找时，结果为null！<br>   这是怎么肥四？难道TreeMap有问题？遇到TreeMap工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。<br>   在这个例子中，TreeMap出现问题，原因其实出在这个Comparator上：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student p1, Student p2)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   在<code>p1.score</code>和<code>p2.score</code>不相等的时候，它的返回值是正确的，但是，在<code>p1.score</code>和<code>p2.score</code>相等的时候，它并没有返回0！这就是为什么TreeMap工作不正常的原因：TreeMap在比较两个Key是否相等时，依赖Key的compareTo()方法或者Comparator.compare()方法。在两个Key相等时，必须返回0。因此，修改代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student p1, Student p2)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (p1.score == p2.score) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p1.score &gt; p2.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   或者直接借助Integer.compare(int, int)也可以返回正确的比较结果。</p>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><ul>
<li>SortedMap在遍历时严格按照Key的顺序遍历，最常用的实现类是TreeMap；</li>
<li>作为SortedMap的Key必须实现Comparable接口，或者传入Comparator；</li>
<li>要严格按照compare()规范实现比较逻辑，否则，TreeMap将不能正常工作。</li>
</ul>
<h1 id="使用Properties"><a href="#使用Properties" class="headerlink" title="使用Properties"></a>使用Properties</h1><p>   在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 上次最后打开的文件:</span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line"># 自动保存文件的时间间隔:</span><br><span class="line">auto_save_interval=60</span><br></pre></td></tr></table></figure><br>   配置文件的特点是，它的Key-Value一般都是String-String类型的，因此我们完全可以用<code>Map&lt;String, String&gt;</code>来表示它。<br>   因为配置文件非常常用，所以Java集合库提供了一个Properties来表示一组“配置”。由于历史遗留原因，Properties内部本质上是一个Hashtable，但我们只需要用到Properties自身关于读写配置的接口。</p>
<h2 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h2><p>   用Properties读取配置文件非常简单。Java默认配置文件以<code>.properties</code>为扩展名，每行以key&#x3D;value表示，以#课开头的是注释。以下是一个典型的配置文件：<br>   <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setting.properties</span></span><br><span class="line"></span><br><span class="line"><span class="attr">last_open_file</span>=<span class="string">/data/hello.txt</span></span><br><span class="line"><span class="attr">auto_save_interval</span>=<span class="string">60</span></span><br></pre></td></tr></table></figure><br>   可以从文件系统读取这个<code>.properties</code>文件：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> <span class="string">&quot;setting.properties&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">java</span>.io.FileInputStream(f));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">interval</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br></pre></td></tr></table></figure><br>   可见，用Properties读取配置文件，一共有三步：</p>
<ol>
<li>创建Properties实例；</li>
<li>调用load()读取文件；</li>
<li>调用getProperty()获取配置。</li>
</ol>
<p>   调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。<br>   也可以从classpath读取<code>.properties</code>文件，因为load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure><br>   试试从内存读取一个字节流：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="string">&quot;# test&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;course=Java&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;last_open_date=2019-08-07T12:35:01&quot;</span>;</span><br><span class="line">      <span class="type">ByteArrayInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(settings.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">      props.load(input);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;course: &quot;</span> + props.getProperty(<span class="string">&quot;course&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;last_open_date: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_date&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;last_open_file: &quot;</span> + props.getProperty(<span class="string">&quot;last_open_file&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;auto_save: &quot;</span> + props.getProperty(<span class="string">&quot;auto_save&quot;</span>, <span class="string">&quot;60&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   如果有多个.properties文件，可以反复调用load()读取，后读取的key-value会覆盖已读取的key-value：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure><br>   上面的代码演示了Properties的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。<br>   Properties设计的目的是存储String类型的key－value，但Properties实际上是从Hashtable派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了getProperty()和setProperty()方法外，还有从Hashtable继承下来的get()和put()方法，这些方法的参数签名是Object，我们在使用Properties的时候，不要去调用这些从Hashtable继承下来的方法。</p>
<h2 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h2><p>   如果通过setProperty()修改了Properties实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用store()方法：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>   早期版本的Java规定.properties文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用<code>name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的<code>.properties</code>文件可以使用UTF-8编码了。<br>   不过，需要注意的是，由于load(InputStream)默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法load(Reader)读取：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><br>   就可以正常读取中文。InputStream和Reader的区别是一个是字节流，一个是字符流。字符流在内存中已经以char类型表示了，不涉及编码问题。</p>
<h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Java集合库提供的Properties用于读写配置文件.properties。.properties文件可以使用UTF-8编码。</li>
<li>可以从文件系统、classpath或其他任何地方读取.properties文件。</li>
<li>读写Properties时，注意仅使用getProperty()和setProperty()方法，不要调用继承而来的get()和put()等方法。</li>
</ul>
<h1 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h1><p>   我们知道，Map用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写equals()方法，还要正确覆写hashCode()方法。<br>   如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。<br>   Set用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<p>   我们来看几个简单的例子：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      System.out.println(set.add(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">      System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">      System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// false，添加失败，因为元素已存在</span></span><br><span class="line">      System.out.println(set.contains(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true，元素存在</span></span><br><span class="line">      System.out.println(set.contains(<span class="string">&quot;XYZ&quot;</span>)); <span class="comment">// false，元素不存在</span></span><br><span class="line">      System.out.println(set.remove(<span class="string">&quot;hello&quot;</span>)); <span class="comment">// false，删除失败，因为元素不存在</span></span><br><span class="line">      System.out.println(set.size()); <span class="comment">// 2，一共两个元素</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素。<br>   因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。<br>   最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装，它的核心代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">   <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">   <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   Set接口并不保证有序，而SortedSet接口则保证元素是有序的：</p>
<ul>
<li>HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；</li>
<li>TreeSet是有序的，因为它实现了SortedSet接口。</li>
</ul>
<p>   用一张图表示：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┐</span><br><span class="line">      │Set│</span><br><span class="line">      └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashSet│ │SortedSet│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeSet │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure><br>   我们来看HashSet的输出：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   注意输出的顺序既不是添加的顺序，也不是String排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。<br>   把HashSet换成TreeSet，在遍历TreeSet时，输出就是有序的，这个顺序是元素的排序顺序：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">      set.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      set.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      set.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      set.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   使用TreeSet和使用TreeMap的要求一样，添加的元素必须正确实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet时必须传入一个Comparator对象。</p>
<h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Set用于存储不重复的元素集合：<ul>
<li>放入HashSet的元素与作为HashMap的key要求相同；</li>
<li>放入TreeSet的元素与作为TreeMap的Key要求相同；</li>
</ul>
</li>
<li>利用Set可以去除重复元素；</li>
<li>遍历SortedSet按照元素的排序顺序遍历，也可以自定义排序算法。</li>
</ul>
<h1 id="使用Queue"><a href="#使用Queue" class="headerlink" title="使用Queue"></a>使用Queue</h1><p>   队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</p>
<ul>
<li>把元素添加到队列末尾；</li>
<li>从队列头部取出元素。</li>
</ul>
<blockquote>
<p>例如:超市的收银台就是一个队列</p>
</blockquote>
<p>   在Java的标准库中，队列接口Queue定义了以下几个方法：</p>
<ul>
<li>int size()：获取队列长度；</li>
<li>boolean add(E)&#x2F;boolean offer(E)：添加元素到队尾；</li>
<li>E remove()&#x2F;E poll()：获取队首元素并从队列中删除；</li>
<li>E element()&#x2F;E peek()：获取队首元素但并不从队列中删除。</li>
</ul>
<p>   对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">throw Exception</th>
<th align="center">返回false或null</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加元素到队尾</td>
<td align="center">add(E e)</td>
<td align="center">boolean offer(E e)</td>
</tr>
<tr>
<td align="center">取队首元素并删除</td>
<td align="center">E remove()</td>
<td align="center">E poll()</td>
</tr>
<tr>
<td align="center">取队首元素但不删除</td>
<td align="center">E element()</td>
<td align="center">E peek()</td>
</tr>
<tr>
<td align="center">举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用add()方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   q.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">如果我们调用offer()方法来添加元素，当添加失败时，它不会抛异常，而是返回false：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">if</span> (q.offer(<span class="string">&quot;Apple&quot;</span>)) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">当我们需要从Queue中取出队首元素时，如果当前Queue是一个空队列，调用remove()方法，它会抛出异常：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.remove();</span><br><span class="line">   System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalStateException e) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">如果我们调用poll()方法来取出队首元素，当获取失败时，它不会抛异常，而是返回null：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q = ...</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.poll();</span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;获取成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">因此，两套方法可以根据需要来选择使用。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">接下来我们以poll()和peek()为例来说说“获取并删除”与“获取但不删除”的区别。对于Queue来说，每次调用poll()，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">      q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      <span class="comment">// 从队列取出元素:</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// null,因为队列是空的</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">如果用peek()，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">      q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      <span class="comment">// 队首永远都是apple，因为peek()不会删除它:</span></span><br><span class="line">      System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">      System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">      System.out.println(q.peek()); <span class="comment">// apple</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">从上面的代码中，我们还可以发现，LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个List:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 这是一个Queue:</span></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h2><ul>
<li>队列Queue实现了一个先进先出（FIFO）的数据结构：<ul>
<li>通过add()&#x2F;offer()方法将元素添加到队尾；</li>
<li>通过remove()&#x2F;poll()从队首获取元素并删除；</li>
<li>通过element()&#x2F;peek()从队首获取元素但不删除。</li>
</ul>
</li>
<li>要避免把null添加到队列。</li>
</ul>
<h1 id="使用PriorityQueue"><a href="#使用PriorityQueue" class="headerlink" title="使用PriorityQueue"></a>使用PriorityQueue</h1><p>   我们知道，Queue是一个先进先出（FIFO）的队列。<br>   在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？<br>   可以每个人先取一个号，例如：A1、A2、A3……然后，按照号码顺序依次办理，实际上这就是一个Queue。<br>   如果这时来了一个VIP客户，他的号码是V1，虽然当前排队的是A10、A11、A12……但是柜台下一个呼叫的客户号码却是V1。<br>   这个时候，我们发现，要实现“VIP插队”的业务，用Queue就不行了，因为Queue会严格按FIFO的原则取出队首元素。我们需要的是优先队列：PriorityQueue。<br>   PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。<br>   要使用PriorityQueue，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看PriorityQueue的行为：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">      q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   我们放入的顺序是”apple”、”pear”、”banana”，但是取出的顺序却是”apple”、”banana”、”pear”，这是因为从字符串的排序看，”apple”排在最前面，”pear”排在最后面。<br>   因此，放入PriorityQueue的元素，必须实现Comparable接口，PriorityQueue会根据元素的排序顺序决定出队的优先级。<br>   如果我们要放入的元素并没有实现Comparable接口怎么办？PriorityQueue允许我们提供一个Comparator对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个PriorityQueue：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Queue&lt;User&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">UserComparator</span>());</span><br><span class="line">      <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">      q.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;A1&quot;</span>));</span><br><span class="line">      q.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;A2&quot;</span>));</span><br><span class="line">      q.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Boss&quot;</span>, <span class="string">&quot;V1&quot;</span>));</span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">      System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;User&gt; &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(User u1, User u2)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   实现PriorityQueue的关键在于提供的UserComparator对象，它负责比较两个元素的大小（较小的在前）。UserComparator总是把V开头的号码优先返回，只有在开头相同的时候，才比较号码大小。<br>   上面的UserComparator的比较逻辑其实还是有问题的，它会把A10排在A2的前面，请尝试修复该错误。</p>
<h2 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h2><ul>
<li>PriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。</li>
<li>PriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）。</li>
</ul>
<h1 id="使用Deque"><a href="#使用Deque" class="headerlink" title="使用Deque"></a>使用Deque</h1><p>   我们知道，Queue是队列，只能一头进，另一头出。<br>   如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。<br>   Java集合提供了接口Deque来实现一个双端队列，它的功能是：</p>
<ul>
<li>既可以添加到队尾，也可以添加到队首；</li>
<li>既可以从队首获取，又可以从队尾获取。<br> 我们来比较一下Queue和Deque出队和入队的方法：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Queue</th>
<th align="center">Deque</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加元素到队尾</td>
<td align="center">add(E e) &#x2F; offer(E e)</td>
<td align="center">addLast(E e) &#x2F; offerLast(E e)</td>
</tr>
<tr>
<td align="center">取队首元素并删除</td>
<td align="center">E remove() &#x2F; E poll()</td>
<td align="center">E removeFirst() &#x2F; E pollFirst()</td>
</tr>
<tr>
<td align="center">取队首元素但不删除</td>
<td align="center">E element() &#x2F; E peek()</td>
<td align="center">E getFirst() &#x2F; E peekFirst()</td>
</tr>
<tr>
<td align="center">添加元素到队首</td>
<td align="center">无</td>
<td align="center">addFirst(E e) &#x2F; offerFirst(E e)</td>
</tr>
<tr>
<td align="center">取队尾元素并删除</td>
<td align="center">无</td>
<td align="center">E removeLast() &#x2F; E pollLast()</td>
</tr>
<tr>
<td align="center">取队尾元素但不删除</td>
<td align="center">无</td>
<td align="center">E getLast() &#x2F; E peekLast()</td>
</tr>
</tbody></table>
<p>   对于添加元素到队尾的操作，Queue提供了add()&#x2F;offer()方法，而Deque提供了addLast()&#x2F;offerLast()方法。添加元素到对首、取队尾元素的操作在Queue中不存在，在Deque中由addFirst()&#x2F;removeLast()等方法提供。<br>   注意到Deque接口实际上扩展自Queue：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   因此，Queue提供的add()&#x2F;offer()方法在Deque中也可以使用，但是，使用Deque，最好不要调用offer()，而是调用offerLast()：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      deque.offerLast(<span class="string">&quot;A&quot;</span>); <span class="comment">// A</span></span><br><span class="line">      deque.offerLast(<span class="string">&quot;B&quot;</span>); <span class="comment">// A &lt;- B</span></span><br><span class="line">      deque.offerFirst(<span class="string">&quot;C&quot;</span>); <span class="comment">// C &lt;- A &lt;- B</span></span><br><span class="line">      System.out.println(deque.pollFirst()); <span class="comment">// C, 剩下A &lt;- B</span></span><br><span class="line">      System.out.println(deque.pollLast()); <span class="comment">// B, 剩下A</span></span><br><span class="line">      System.out.println(deque.pollFirst()); <span class="comment">// A</span></span><br><span class="line">      System.out.println(deque.pollFirst()); <span class="comment">// null</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   如果直接写deque.offer()，我们就需要思考，offer()实际上是offerLast()，我们明确地写上offerLast()，不需要思考就能一眼看出这是添加到队尾。<br>   因此，使用Deque，推荐总是明确调用offerLast()&#x2F;offerFirst()或者pollFirst()&#x2F;pollLast()方法。<br>   Deque是一个接口，它的实现类有ArrayDeque和LinkedList。<br>   我们发现LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的写法:</span></span><br><span class="line">LinkedList&lt;String&gt; d1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">d1.offerLast(<span class="string">&quot;z&quot;</span>);</span><br><span class="line"><span class="comment">// 推荐的写法：</span></span><br><span class="line">Deque&lt;String&gt; d2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">d2.offerLast(<span class="string">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure><br>   可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h2 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h2><p>   Deque实现了一个双端队列（Double Ended Queue），它可以：</p>
<ul>
<li>将元素添加到队尾或队首：addLast()&#x2F;offerLast()&#x2F;addFirst()&#x2F;offerFirst()；</li>
<li>从队首／队尾获取元素并删除：removeFirst()&#x2F;pollFirst()&#x2F;removeLast()&#x2F;pollLast()；</li>
<li>从队首／队尾获取元素但不删除：getFirst()&#x2F;peekFirst()&#x2F;getLast()&#x2F;peekLast()；</li>
<li>总是调用xxxFirst()&#x2F;xxxLast()以便与Queue的方法区分开；</li>
<li>避免把null添加到队列。</li>
</ul>
<h1 id="使用Stack"><a href="#使用Stack" class="headerlink" title="使用Stack"></a>使用Stack</h1><p>   栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。<br>   什么是LIFO呢？我们先回顾一下Queue的特点FIFO：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           ────────────────────────</span><br><span class="line">  (\(\      (\(\    (\(\    (\(\      (\(\</span><br><span class="line"> (=&#x27;.&#x27;) ─&gt; (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;) ─&gt; (=&#x27;.&#x27;)</span><br><span class="line">O(_&quot;)&quot;)   O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)   O(_&quot;)&quot;)</span><br><span class="line">           ────────────────────────</span><br></pre></td></tr></table></figure><br>   所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进Stack的元素一定最早出Stack。如何做到这一点呢？只需要把队列的一端封死：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           ───────────────────────────────┐</span><br><span class="line">  (\(\       (\(\    (\(\    (\(\    (\(\ │</span><br><span class="line"> (=&#x27;.&#x27;) &lt;─&gt; (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;)│</span><br><span class="line">O(_&quot;)&quot;)    O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)│</span><br><span class="line">           ───────────────────────────────┘</span><br></pre></td></tr></table></figure><br>   因此，Stack是这样一种数据结构：只能不断地往Stack中压入（push）元素，最后进去的必须最早弹出（pop）来：<br>   Stack只有入栈和出栈的操作：</p>
<ul>
<li>把元素压栈：push(E)；</li>
<li>把栈顶的元素“弹出”：pop(E)；</li>
<li>取栈顶元素但不弹出：peek(E)。</li>
</ul>
<p>   在Java中，我们用Deque可以实现Stack的功能：</p>
<ul>
<li>把元素压栈：push(E)&#x2F;addFirst(E)；</li>
<li>把栈顶的元素“弹出”：pop(E)&#x2F;removeFirst()；</li>
<li>取栈顶元素但不弹出：peek(E)&#x2F;peekFirst()。</li>
</ul>
<p>   为什么Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了。<br>   当我们把Deque作为Stack使用时，注意只调用push()&#x2F;pop()&#x2F;peek()方法，不要调用addFirst()&#x2F;removeFirst()&#x2F;peekFirst()方法，这样代码更加清晰。</p>
<h2 id="Stack的作用"><a href="#Stack的作用" class="headerlink" title="Stack的作用"></a>Stack的作用</h2><p>   Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> foo(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">foo</span><span class="params">(x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;F-&quot;</span> + bar(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。<br>   因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发StackOverflowError：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      increase(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">increase</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> increase(x) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   我们再来看一个Stack的用途：对整数进行进制的转换就可以利用栈。<br>   例如，我们要把一个int整数12500转换为十六进制表示的字符串。</p>
<h2 id="计算中缀表达式"><a href="#计算中缀表达式" class="headerlink" title="计算中缀表达式"></a>计算中缀表达式</h2><h2 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h2><ul>
<li>栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：<ul>
<li>把元素压栈：push(E)；</li>
<li>把栈顶的元素“弹出”：pop(E)；</li>
<li>取栈顶元素但不弹出：peek(E)。</li>
</ul>
</li>
<li>在Java中，我们用Deque可以实现Stack的功能，注意只调用push()&#x2F;pop()&#x2F;peek()方法，避免调用Deque的其他方法。</li>
<li>最后，不要使用遗留类Stack。</li>
</ul>
<h1 id="使用Iterator"><a href="#使用Iterator" class="headerlink" title="使用Iterator"></a>使用Iterator</h1><p>   Java的集合类都可以使用<code>for each</code>循环，List、Set和Queue会迭代每个元素，Map会迭代每个key。以List为例：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">   System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   实际上，Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">   System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   我们把这种通过Iterator对象遍历集合的模式称为迭代器。<br>   使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。<br>   例如，我们虽然知道ArrayList在内部是以数组形式存储元素，并且，它还提供了get(int)方法。虽然我们可以用for循环遍历：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把ArrayList换成LinkedList，get(int)方法耗时会随着index的增加而增加。如果把ArrayList换成Set，上述代码就无法编译，因为Set内部没有索引。<br>   用Iterator遍历就没有上述问题，因为Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。<br>   如果我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件：</p>
<ul>
<li>集合类实现Iterable接口，该接口要求返回一个Iterator对象；</li>
<li>用Iterator对象迭代集合内部数据。</li>
</ul>
<p>   这里的关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。<br>   一个简单的Iterator示例如下，它总是以倒序遍历集合：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> <span class="title class_">ReverseList</span>&lt;&gt;();</span><br><span class="line">      rlist.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">      rlist.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">      rlist.add(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">      list.add(t);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReverseIterator</span>(list.size());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ReverseIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">      <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">      ReverseIterator(<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="built_in">this</span>.list.get(index);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   虽然ReverseList和ReverseIterator的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按for each循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。<br>   在编写Iterator的时候，我们通常可以用一个内部类来实现Iterator接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类ReverseIterator可以用ReverseList.this获得当前外部类的this引用，然后，通过这个this引用就可以访问ReverseList的所有字段和方法。</p>
<h2 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Iterator是一种抽象的数据访问模型。使用Iterator模式进行迭代的好处有：<ul>
<li>对任何集合都采用同一种访问模型；</li>
<li>调用者对集合内部结构一无所知；</li>
<li>集合类返回的Iterator对象知道如何迭代。</li>
</ul>
</li>
<li>Java提供了标准的迭代器模型，即集合类实现java.util.Iterable接口，返回java.util.Iterator实例。</li>
</ul>
<h1 id="使用Collections"><a href="#使用Collections" class="headerlink" title="使用Collections"></a>使用Collections</h1><p>   Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
<blockquote>
<p> 注意Collections结尾多了一个s，不是Collection！<br>   我们一般看方法名和参数就可以确认Collections提供的该方法的功能。例如，对于以下静态方法：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><br>   addAll()方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。</p>
</blockquote>
<h2 id="创建空集合"><a href="#创建空集合" class="headerlink" title="创建空集合"></a>创建空集合</h2><p>   Collections提供了一系列方法来创建空集合：</p>
<ul>
<li>创建空List：<code>List&lt;T&gt; emptyList()</code></li>
<li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li>
<li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li>
</ul>
<p>   要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。<br>   此外，也可以用各个集合接口提供的of(T…)方法创建空集合。例如，以下创建空List的两个方法是等价的：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of();</span><br><span class="line">List&lt;String&gt; list2 = Collections.emptyList();</span><br></pre></td></tr></table></figure></p>
<h2 id="创建单元素集合"><a href="#创建单元素集合" class="headerlink" title="创建单元素集合"></a>创建单元素集合</h2><p>   Collections提供了一系列方法来创建一个单元素集合：</p>
<ul>
<li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li>
<li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li>
<li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li>
</ul>
<p>   要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。<br>   此外，也可以用各个集合接口提供的of(T…)方法创建单元素集合。例如，以下创建单元素List的两个方法是等价的：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = Collections.singletonList(<span class="string">&quot;apple&quot;</span>);</span><br></pre></td></tr></table></figure><br>   实际上，使用<code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(); <span class="comment">// empty list</span></span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 1 element</span></span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>); <span class="comment">// 2 elements</span></span><br><span class="line">List&lt;String&gt; list4 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 3 elements</span></span><br></pre></td></tr></table></figure></p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>   Collections可以对List进行排序。因为排序会直接修改List元素的位置，因此必须传入可变List：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      list.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      list.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">      <span class="comment">// 排序前:</span></span><br><span class="line">      System.out.println(list);</span><br><span class="line">      Collections.sort(list);</span><br><span class="line">      <span class="comment">// 排序后:</span></span><br><span class="line">      System.out.println(list);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h2><p>   Collections提供了洗牌算法，即传入一个有序的List，可以随机打乱List内部元素的顺序，效果相当于让计算机洗牌：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 洗牌前:</span></span><br><span class="line">      System.out.println(list);</span><br><span class="line">      Collections.shuffle(list);</span><br><span class="line">      <span class="comment">// 洗牌后:</span></span><br><span class="line">      System.out.println(list);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><p>   Collections还提供了一组方法把可变集合封装成不可变集合：</p>
<ul>
<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>
<p>   这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; mutable = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      <span class="comment">// 变为不可变集合:</span></span><br><span class="line">      List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">      immutable.add(<span class="string">&quot;orange&quot;</span>); <span class="comment">// UnsupportedOperationException!</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   然而，继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; mutable = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      <span class="comment">// 变为不可变集合:</span></span><br><span class="line">      List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">      mutable.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">      System.out.println(immutable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   因此，如果我们希望把一个可变List封装成不可变List，那么，返回不可变List后，最好立刻扔掉可变List的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”List变化了：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; mutable = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">      mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">      <span class="comment">// 变为不可变集合:</span></span><br><span class="line">      List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">      <span class="comment">// 立刻扔掉mutable的引用:</span></span><br><span class="line">      mutable = <span class="literal">null</span>;</span><br><span class="line">      System.out.println(immutable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h2><p>   Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<ul>
<li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
<li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
<li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
</ul>
<p>   多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>
<h2 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h2><p>   Collections类提供了一组工具方法来方便使用集合类：</p>
<ul>
<li>创建空集合；</li>
<li>创建单元素集合；</li>
<li>创建不可变集合；</li>
<li>排序／洗牌等操作。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Qeuroal
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://qeuroal.top/2021/01/16/125/" title="125. Java 集合">http://qeuroal.top/2021/01/16/125/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/01/15/124/" rel="prev" title="124. 泛型">
                  <i class="fa fa-angle-left"></i> 124. 泛型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/31/126/" rel="next" title="126. maven补充">
                  126. maven补充 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Qeuroal</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Qeuroal" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
