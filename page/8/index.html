<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qeuroal.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="大人者，不失其赤子之心">
<meta property="og:type" content="website">
<meta property="og:title" content="Qeuroal&#39;s Blog">
<meta property="og:url" content="http://qeuroal.top/page/8/index.html">
<meta property="og:site_name" content="Qeuroal&#39;s Blog">
<meta property="og:description" content="大人者，不失其赤子之心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Qeuroal">
<meta property="article:tag" content="C&#x2F;C++, Python, Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://qeuroal.top/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Qeuroal's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Qeuroal's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">静幽正治</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qeuroal"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qeuroal</p>
  <div class="site-description" itemprop="description">大人者，不失其赤子之心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">187</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Qeuroal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qeuroal" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/08/15/159/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/15/159/" class="post-title-link" itemprop="url">159. Makefile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2023-08-15T00:00:00+08:00">2023-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Makefile学习记录</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/15/159/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/30/158/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/30/158/" class="post-title-link" itemprop="url">158. SSH</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-30 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-30T00:00:00+08:00">2023-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Secure Shell (SSH) 是一个网络协议，它主要被用来加密客户端和服务端之间的连接。 在客户端和服务端的每一次交互都被加密。</p>
<p>这个教程解释了如何在 Ubuntu 机器上启用 SSH。</p>
<p>启用  SSH 将会允许你远程连接到你的系统，并且执行管理员任务。你将能够通过 <code>scp</code>和<code>sftp</code>安全传输文件。</p>
<h1 id="在-Ubuntu-上启用-SSH"><a href="#在-Ubuntu-上启用-SSH" class="headerlink" title="在 Ubuntu 上启用 SSH"></a>在 Ubuntu 上启用 SSH</h1><p>默认情况下，当 Ubuntu 最初被安装的时候，通过 SSH 进行远程访问是不被允许的。在 Ubuntu 上启用 SSH 非常的简单直接。</p>
<p>以 root 或者其他 sudo 用户身份执行下面的步骤，在你的 Ubuntu 系统上安装并且启用 SSH。</p>
<p>01.使用<code>Ctrl+Alt+T</code>打开终端，并且安装<code>openssh-server</code>软件包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<p>当被提示时，输入你的密码并且按 Enter，继续安装。</p>
<img data-src="/2023/06/30/158/1200-20230630145454221" class="" title="img">

<p>02.一旦安装完成，SSH 服务将会被自动启动。你可以验证 SSH 是否正在运行，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status ssh</span><br></pre></td></tr></table></figure>

<p>输出将会告诉你服务正在运行，并且启用开机启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">● ssh.service - OpenBSD Secure Shell server</span><br><span class="line">    Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)</span><br><span class="line">    Active: active (running) since Mon 2020-06-01 12:34:00 CEST; 9h ago</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>按<code>q</code>返回命令行。</p>
<p>03.Ubuntu 自带一个配置防火墙配置工具，称为 UFW。如果防火墙在你的系统上被启用，请确保打开了 SSH 端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow ssh</span><br></pre></td></tr></table></figure>

<p>就这些。现在你可以从任何远程机器上通过 SSH 连接到你的 Ubuntu 系统。Linux 和 macOS 系统默认都安装了 SSH 客户端。想要从一个 Window 机器上连接，使用一个 SSH 客户端，例如:<a target="_blank" rel="noopener" href="https://www.putty.org/">PUTTY</a>。</p>
<h1 id="连接到-SSH-服务器"><a href="#连接到-SSH-服务器" class="headerlink" title="连接到 SSH 服务器"></a>连接到 SSH 服务器</h1><p>想要在局域网内连接到你的 Ubuntu 机器，以下面的格式输入 ssh 命令，加上用户名和 IP 地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@ip_address</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">确保你将`username`修改成你自己的用户名，`ip_address`修改成你安装了 SSH 的 Ubuntu 机器的 IP 地址。</span><br></pre></td></tr></table></figure>

<p>如果你不知道你的 IP 地址，你可以使用<code>ip</code>命令轻易地找到它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/30/158/1200" class="" title="img">

<p>你可以从输出中看到，系统 IP 地址是<code>10.0.2.15</code>。</p>
<p>一旦你找到 IP 地址，通过运行下面的ssh 命令登录远程机器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh linuxize@10.0.2.15</span><br></pre></td></tr></table></figure>

<p>当你第一次连接时，你将看到下面的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;10.0.2.15 (10.0.2.15)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>

<p>输入<code>yes</code>并且你将会被提示输入你的密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">&#x27;10.0.2.15&#x27;</span> (ECDSA) to the list of known hosts.</span><br><span class="line">linuxize@10.0.2.15<span class="string">&#x27;s password:</span></span><br></pre></td></tr></table></figure>

<p>一旦你输入密码，你将会看到默认的 Ubuntu 消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Ubuntu 20.04 LTS (GNU/Linux 5.4.0-26-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在你可以登录到你的 Ubuntu 机器上。</p>
<h1 id="连接到-NAT-后面的-SSH"><a href="#连接到-NAT-后面的-SSH" class="headerlink" title="连接到 NAT 后面的 SSH"></a>连接到 NAT 后面的 SSH</h1><p>想要通过互联网连接到你的 Ubuntu 机器，你需要知道你的公网 IP 地址，并且配置你的路由器接收端口22的数据，并且发送它到正在运行 SSH 的 Ubuntu 机器。</p>
<p>想要获取你尝试通过 SSH 连接的机器的公网 IP，在这个机器上访问 URL 地址：<code>https://api.ipify.org</code>。</p>
<p>当设置端口转发时，每一个路由器都有不同的方式来设置端口转发。你应该参考你的路由器文档，关于如何设置端口转发的信息。简单来讲，你应该输入之前设置的 SSH 端口号 22，以及之前<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cvm?from=20065&from_column=20065">服务器</a>的私有 IP 地址。</p>
<p>一旦你找到 IP 地址，配置你的路由器，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@public_ip_address</span><br></pre></td></tr></table></figure>

<p>如果你将你的机器暴露在互联网中，你最好采取一些安全措施。最基础的一个措施就是配置你的路由器接受一个非标准端口的 SSH 流量，并且转发到你运行 SSH 服务的机器的端口22。</p>
<p>你也可以<a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-setup-passwordless-ssh-login/">设置 SSH 密钥公钥验证方式</a>，之后你就可以不使用密码就可以连接到你的 Ubuntu 机器上了。</p>
<h1 id="在-Ubuntu-上禁用-SSH"><a href="#在-Ubuntu-上禁用-SSH" class="headerlink" title="在 Ubuntu 上禁用 SSH"></a>在 Ubuntu 上禁用 SSH</h1><p>想要在你的 Ubuntu 系统上禁用 SSH 服务器，简单停止 SSH 即可，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> --now ssh</span><br></pre></td></tr></table></figure>

<p>稍后，你可以重新启用，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now ssh</span><br></pre></td></tr></table></figure>

<h1 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h1><h2 id="SSH-无密登录"><a href="#SSH-无密登录" class="headerlink" title="SSH 无密登录"></a>SSH 无密登录</h2><h3 id="step1-客户端生成公私钥"><a href="#step1-客户端生成公私钥" class="headerlink" title="step1 客户端生成公私钥"></a>step1 客户端生成公私钥</h3><p>本地客户端生成公私钥：（一路回车默认即可）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>生成之后会在用户的根目录生成一个 “<code>.ssh</code>“的文件夹，进入”<code>.ssh</code>“会生成如下几个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>下创建两个密钥：</p>
<ol>
<li><code>authorized_keys</code>: 存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥</li>
<li><code>id_rsa</code> : 生成的私钥文件</li>
<li><code>id_rsa.pub</code> ： 生成的公钥文件</li>
<li><code>know_hosts</code> : 已知的主机公钥清单</li>
</ol>
<blockquote>
<p><strong>ps</strong></p>
</blockquote>
<p>ssh公钥生效需满足至少下面两个条件：</p>
<ul>
<li><code>.ssh</code> 目录的权限必须是700</li>
<li><code>.ssh/authorized_keys</code> 文件权限必须是600</li>
</ul>
<h3 id="step2-上传公钥到服务器"><a href="#step2-上传公钥到服务器" class="headerlink" title="step2 上传公钥到服务器"></a>step2 上传公钥到服务器</h3><p>这里测试用的服务器地址为：<code>192.168.32.32</code></p>
<p>用户为：<code>root</code></p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;remote_ip&gt;</span><br></pre></td></tr></table></figure>

<p>上面这条命令是写到服务器上的ssh目录下去了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure>

<p>可以看到客户端写入到服务器的 <code>id_rsa.pub</code> （公钥）内容。</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>使用命令<code>ssh-copy-id &lt;remote_ip&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@192.168.32.32</span><br></pre></td></tr></table></figure>

<h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p>通过<code>scp</code>将内容写到对方的<code>authorized_keys</code>文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -p ~/.ssh/id_rsa.pub root@&lt;remote_ip&gt;:/root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h3 id="step3-测试免密登录"><a href="#step3-测试免密登录" class="headerlink" title="step3 测试免密登录"></a>step3 测试免密登录</h3><p>客户端通过ssh连接远程服务器，就可以免密登录了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.32.32</span><br></pre></td></tr></table></figure>

<h2 id="设置指定用户"><a href="#设置指定用户" class="headerlink" title="设置指定用户"></a>设置指定用户</h2><h3 id="step1-配置SSH服务器"><a href="#step1-配置SSH服务器" class="headerlink" title="step1 配置SSH服务器"></a>step1 配置SSH服务器</h3><p>编辑SSH服务器配置文件（通常位于<code>/etc/ssh/sshd_config</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>确保以下行未注释（没有<code>#</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication yes</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>

<p>这允许使用SSH密钥和密码进行身份验证。</p>
<h3 id="step2-设置Match块"><a href="#step2-设置Match块" class="headerlink" title="step2 设置Match块"></a>step2 设置<code>Match</code>块</h3><p>在配置文件的末尾添加<code>Match</code>块，限制只允许用户<code>user1, user2, user3</code>使用密钥登录。您可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match User user1,user2,user3</span><br><span class="line">    PasswordAuthentication no</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Match User user1</span><br><span class="line">    PasswordAuthentication no</span><br><span class="line"></span><br><span class="line">Match User user2</span><br><span class="line">    PasswordAuthentication no</span><br><span class="line"></span><br><span class="line">Match User user3</span><br><span class="line">    PasswordAuthentication no</span><br></pre></td></tr></table></figure>

<p>这将禁用<code>user1,user2,user3</code>用户的密码登录。其他用户将按照默认设置进行身份验证，允许密码登录。</p>
<blockquote>
<p>多个用户也可以单独</p>
</blockquote>
<h3 id="step3-重启SSH服务"><a href="#step3-重启SSH服务" class="headerlink" title="step3 重启SSH服务"></a>step3 重启SSH服务</h3><p>保存配置文件并重启SSH服务，以使更改生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart ssh</span><br></pre></td></tr></table></figure>

<p>现在，<code>user1,user2,user3</code>用户只能使用其SSH密钥进行身份验证，而其他用户仍然可以使用密码进行身份验证。</p>
<p>请确保在执行此操作之前，您已经测试过SSH密钥对的工作方式，并且确保您至少有一种方法可以访问服务器，以防止自身被锁定。</p>
<h2 id="SSH设置环境变量"><a href="#SSH设置环境变量" class="headerlink" title="SSH设置环境变量"></a>SSH设置环境变量</h2><h3 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h3><p>在 <code>~/.ssh/config</code> 中设置如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">   SetEnv TERM=xterm-256color</span><br></pre></td></tr></table></figure>

<p>它的作用是为所有主机（Host * 表示匹配所有主机）设置一个环境变量 TERM, 其值为 <code>xterm-256color</code>, 具体含义如下：</p>
<ul>
<li><code>Host *</code>: 这是一个通配符规则，表示该配置适用于所有远程主机。 如果你只想针对特定主机应用配置，可以将 <code>*</code> 替换为主机名或 IP 地址。</li>
<li><code>SetEnv TERM=xterm-256color</code> : SetEnv 是 SSH 配置指令, 用于在连接到远程主机时传递环境变量. <code>TERM=xterm-256color</code> 设置了终端类型为 <code>xterm-256color</code>, 这是一种支持 256 色的终端模拟器类型。这对于需要彩色输出的程序（如 vim、tmux 等）非常重要。</li>
</ul>
<p><code>TERM=xterm-256color</code> 的是为了解决远程连接用户时, 键入字符错乱的问题</p>
<img data-src="/2023/06/30/158/image-20250309151616839.jpg" class="" title="image-20250309151616839">

<h3 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h3><p>ssh 连接时, 使用命令行 <code>-o</code> 选项设置环境变量: <code>ssh -o SetEnv=&quot;TERM=xterm-256color&quot; user@hostname</code></p>
<h1 id="SSH-上传下载"><a href="#SSH-上传下载" class="headerlink" title="SSH 上传下载"></a>SSH 上传下载</h1><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><h3 id="上传本地文件到服务器"><a href="#上传本地文件到服务器" class="headerlink" title="上传本地文件到服务器"></a>上传本地文件到服务器</h3><p>格式：<code>scp 要上传的文件路径 用户名@服务器地址:服务器保存路径</code></p>
<p>例如：把本机 <code>/home/test.txt</code> 文件上传到 <code>192.168.0.101</code> 这台服务器上的 <code>/data/</code> 目录中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /home/test.txt root@192.168.0.101:/data/</span><br></pre></td></tr></table></figure>

<h3 id="上传目录到服务器"><a href="#上传目录到服务器" class="headerlink" title="上传目录到服务器"></a>上传目录到服务器</h3><p>格式：<code>scp -r 要上传的目录 用户名@服务器地址:服务器的保存目录</code></p>
<p>例如：把 <code>/home</code> 目录上传到服务器的 <code>/data/</code> 目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home root@192.168.0.101:/data/</span><br></pre></td></tr></table></figure>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="从服务器上下载文件"><a href="#从服务器上下载文件" class="headerlink" title="从服务器上下载文件"></a>从服务器上下载文件</h3><p>格式：<code>scp 用户名@服务器地址:要下载的文件路径 保存文件的文件夹路径</code></p>
<p>例如：把 <code>192.168.0.101</code> 上的 <code>/data/test.txt</code> 的文件下载到 <code>/home</code>（本地目录）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.0.101:/data/test.txt /home</span><br></pre></td></tr></table></figure>

<h3 id="从服务器下载整个目录"><a href="#从服务器下载整个目录" class="headerlink" title="从服务器下载整个目录"></a>从服务器下载整个目录</h3><p>格式：<code>scp -r 用户名@服务器地址:要下载的服务器目录 保存下载的目录</code></p>
<p>例如：把 <code>192.168.0.101</code> 上的 <code>/data</code> 目录下载到 <code>/home</code>（本地目录）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r root@192.168.0.101:/data  /home/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：目标服务器要开启写入权限。</p>
</blockquote>
<h1 id="访问服务器的-127-0-0-1-port"><a href="#访问服务器的-127-0-0-1-port" class="headerlink" title="访问服务器的 127.0.0.1:port"></a>访问服务器的 127.0.0.1:port</h1><h2 id="服务器-port-允许外部-IP-访问时"><a href="#服务器-port-允许外部-IP-访问时" class="headerlink" title="服务器 port 允许外部 IP 访问时"></a>服务器 port 允许外部 IP 访问时</h2><p>假设目标服务器的 ip 地址为: <code>192.168.32.32</code>, port 为 <code>8080</code></p>
<p>则在本地的浏览器地址栏输入: <code>&lt;ip&gt;:&lt;port&gt;</code>, 这里输入: <code>192.168.32.32:8080</code></p>
<h2 id="服务器-port-不允许外部-IP-访问时"><a href="#服务器-port-不允许外部-IP-访问时" class="headerlink" title="服务器 port 不允许外部 IP 访问时"></a>服务器 port 不允许外部 IP 访问时</h2><ol>
<li><p>将服务器 port 端口转发到本地 port</p>
<p>如将服务器 9090 端口转发到本地 19090.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 19090:127.0.0.1:9090 &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>地址栏输入: <code>localhost:19090</code> 或 <code>127.0.0.1:19090</code></p>
</li>
</ol>
<h1 id="设置特定用户的sshd-config"><a href="#设置特定用户的sshd-config" class="headerlink" title="设置特定用户的sshd_config"></a>设置特定用户的sshd_config</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match User &lt;用户名&gt;</span><br><span class="line">	PasswordAuthentication yes</span><br></pre></td></tr></table></figure>

<h1 id="透过跳板机访问服务器"><a href="#透过跳板机访问服务器" class="headerlink" title="透过跳板机访问服务器"></a>透过跳板机访问服务器</h1><h2 id="方法1-简单却暴力"><a href="#方法1-简单却暴力" class="headerlink" title="方法1 (简单却暴力)"></a>方法1 (简单却暴力)</h2><p>很多环境都有一台统一登录跳板机,我们需要先登录跳板机,然后再登录自己的目标机器.登录流程如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@跳板机ip </span><br><span class="line">ssh root@自己的目标机器ip</span><br></pre></td></tr></table></figure>

<h2 id="方法2-使用端口转发"><a href="#方法2-使用端口转发" class="headerlink" title="方法2 (使用端口转发)"></a>方法2 (使用端口转发)</h2><ol>
<li><p>首先通过 ssh 连接跳板机, 并设置端口转发, 如将本地端口 2222 通过跳板机 (132.60.171.142) 转发到服务器 (192.168.2.28) 的 22 端口, <code>~/.ssh/config</code> 配置如下:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host linkrm</span><br><span class="line">   HostName 132.60.171.142</span><br><span class="line">   User qeuroal</span><br><span class="line">   Port 15220</span><br><span class="line">   LocalForward 2222 192.168.2.28:22</span><br></pre></td></tr></table></figure>

<p>在本地运行命令: <code>ssh linkrm</code></p>
</li>
<li><p>通过 ssh 连接本地端口 2222, 访问服务器 (192.168.2.28), <code>~/.ssh/config</code> 配置如下:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host rm</span><br><span class="line">   HostName localhost</span><br><span class="line">   User qeuroal</span><br><span class="line">   Port 2222</span><br><span class="line">   LocalForward 16006 127.0.0.1:6006</span><br></pre></td></tr></table></figure>

<p>在本地另开一个终端, 并运行命令 <code>ssh rm</code></p>
</li>
</ol>
<h2 id="方法3-使用-ProxyCommand"><a href="#方法3-使用-ProxyCommand" class="headerlink" title="方法3 (使用 ProxyCommand)"></a>方法3 (使用 ProxyCommand)</h2><p>有一台机器A，欲与机器C建立SSH连接，但由于隔离限制（比如”存在防火墙”）该SSH连接不能直接建立。ssh命令的”ProxyCommand”选项被设计用来解决以上问题。</p>
<p>通过“ProxyCommand”选项，机器A能够灵活使用任意代理机制与机器C上的SSH Server端口建立连接，接着机器A上的SSH Client再与该连接进行数据交互，从而机器A上的SSH Client与机器C上的SSH Server之间建立了与一般“直接SSH连接”不太一样的“间接SSH连接”。不过由于“间接SSH连接”的透明性，逻辑上可认为机器A上的SSH Client与机器C上的SSH Server建立了“直接SSH连接”。<br>“直接SSH连接”示意图如图1，“间接SSH连接”示意图如图2。</p>
<img data-src="/2023/06/30/158/20170519-0-1.jpg" class="" title="直接SSH连接">

<img data-src="/2023/06/30/158/20170519-0-2.jpg" class="" title="间接SSH连接">

<p>常使用代理机制有两种，接下来进行介绍。</p>
<h3 id="常使用代理机制"><a href="#常使用代理机制" class="headerlink" title="常使用代理机制"></a>常使用代理机制</h3><h4 id="代理机制1"><a href="#代理机制1" class="headerlink" title="代理机制1"></a>代理机制1</h4><p>ProxyCommand 选项值形式为 <code>ssh -W C:CPort -l USER -i PRIVATE_KEY -p BPort B</code>. 原理是 ssh 命令自提供的代理机制，在机器A上另外单独建立与B的SSH连接（使用<code>-l USER -i PRIVATE_KEY -p BPort B</code>这些参数），该SSH连接的B端侧与机器C上的SSH Server端口（即<code>C:CPort</code>）建立连接，该SSH连接的A端侧与机器A上的SSH Client（即w最终欲建立’间接SSH连接’在机器A上的SSH Client”）建立连接。</p>
<p>假定A上ssh_config配置文件内容如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Host B</span><br><span class="line">    HostName 132.60.171.142</span><br><span class="line">    User qeuroal</span><br><span class="line">    Port 15220</span><br><span class="line">    IdentityFile ~/.ssh/id_dsa</span><br><span class="line"></span><br><span class="line">Host C</span><br><span class="line">    HostName 192.168.2.28</span><br><span class="line">    User qeuroal</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    ProxyCommand ssh -W %h:%p B</span><br></pre></td></tr></table></figure>

<p>在A上执行 <code>ssh C</code> 命令，发现A与C成功建立SSH连接。根据以上所述，此时在A上应该有两个SSH进程，一个对应于”A与B的SSH连接”，另外一个对应于”A与C的SSH连接”。在A上执行 <code>ps -ef | grep &#39;ssh&#39;</code> 命令，得到如下结果，得证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7851  7689 15:55 S pts/10   ssh C</span><br><span class="line">7852  7851 15:55 S pts/10   ssh -W C:1046 B</span><br></pre></td></tr></table></figure>

<h4 id="代理机制2"><a href="#代理机制2" class="headerlink" title="代理机制2"></a>代理机制2</h4><p>“ProxyCommand”选项值形式为”nc -X 5 -x B:BPort C CPort”，原理：利用”nc”命令，在机器A上使用”nc”命令与代理服务器（即”-x B:BPort”，通过”-X 5”参数来指定与代理服务器的通信协议为”SOCKS4&#x2F;SOCKS5&#x2F;HTTPS”）建立代理连接，该代理连接的B端侧与机器C上的SSH Server端口（即”C CPort”）建立连接，该代理连接的A端侧与机器A上的SSH Client（即”最终欲建立‘间接SSH连接’在机器A上的SSH Client”）建立连接。<br>假定A上ssh_config配置文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host C</span><br><span class="line">    HostName %h</span><br><span class="line">    User dsl </span><br><span class="line">    Port 1046</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    ProxyCommand nc -X 5 -x B:8989 %h %p </span><br></pre></td></tr></table></figure>

<p>在A上执行<code>ssh C</code>命令，发现A与C成功建立SSH连接。根据以上所述，此时在A上应该有一个NC进程和一个SSH进程，前者对应于”A与B的代理连接”，后者对应于”A与C的SSH连接”。在A上执行<code>ps -ef | grep -e &#39;ssh&#39; -e &#39;nc&#39;</code>命令，得到如下结果，得证。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep -e <span class="string">&#x27;ssh&#x27;</span> -e <span class="string">&#x27;nc&#x27;</span></span><br><span class="line">8816  8089 16:08 S pts/10   ssh C</span><br><span class="line">8817  8816 16:08 S pts/10   nc -X 5 -x B:8989 C 1046</span><br></pre></td></tr></table></figure>

<h2 id="ssh命令”端口转发”和”ProxyCommand”选项之间的关系"><a href="#ssh命令”端口转发”和”ProxyCommand”选项之间的关系" class="headerlink" title="ssh命令”端口转发”和”ProxyCommand”选项之间的关系"></a>ssh命令”端口转发”和”ProxyCommand”选项之间的关系</h2><p>端口转发包括：本地转发，远端转发和动态转发。其中”本地转发”和”远端转发”属于”静态转发”（因为转发目标端口是固定的）。<br>ProxyCommand选项能够使用基于”动态转发”的代理机制（在外面封装<code>nc</code>命令层），而不能使用基于”静态转发”的代理机制。</p>
<p>参考文献：</p>
<ul>
<li>man ssh_config</li>
<li>man ssh</li>
<li><a target="_blank" rel="noopener" href="https://serverfault.com/questions/337120/ssh-via-3rd-machine">https://serverfault.com/questions/337120/ssh-via-3rd-machine</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lainme.com/doku.php/blog/2011/01/%E9%80%8F%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5ssh">https://www.lainme.com/doku.php/blog/2011/01/%E9%80%8F%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5ssh</a></li>
<li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/22635613/what-is-the-difference-between-ssh-proxycommand-w-nc-exec-nc">what-is-the-difference-between-ssh-proxycommand-w-nc-exec-nc
</a></li>
</ul>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="ssh-连接-remote-host-identification-has-changed"><a href="#ssh-连接-remote-host-identification-has-changed" class="headerlink" title="ssh 连接 remote host identification has changed"></a>ssh 连接 remote host identification has changed</h2><img data-src="/2023/06/30/158/20170726161546339.png" class="" title="img">

<p>找到<code>.ssh</code>目录，下面有一个<code>known_hosts</code>文件，删除 <code>~/.ssh/known_hosts</code> 文件，或者如果你可以判断出<code>known_hosts</code>中原ssh服务器的公钥，删去那部分，</p>
<h2 id="Double-and-random-letters-when-typing-on-a-SSH-MacOS-Ubuntu-connection"><a href="#Double-and-random-letters-when-typing-on-a-SSH-MacOS-Ubuntu-connection" class="headerlink" title="Double and random letters when typing on a SSH MacOS -&gt; Ubuntu connection"></a>Double and random letters when typing on a SSH MacOS -&gt; Ubuntu connection</h2><p>见<a href="#SSH%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">这里</a>, 设置远程机器的 <code>TERM</code> 变量为 <code>xterm-256color</code>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/23/157/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/23/157/" class="post-title-link" itemprop="url">157. win10 相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-23 17:00:00" itemprop="dateCreated datePublished" datetime="2023-06-23T17:00:00+08:00">2023-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os/" itemprop="url" rel="index"><span itemprop="name">os</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Win10-使用注册表一键添加小鹤双拼方案"><a href="#Win10-使用注册表一键添加小鹤双拼方案" class="headerlink" title="Win10 使用注册表一键添加小鹤双拼方案"></a>Win10 使用注册表一键添加小鹤双拼方案</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p><code>新建.txt</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS]</span><br><span class="line">&quot;UserDefinedDoublePinyinScheme0&quot;=&quot;小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt&quot;</span><br></pre></td></tr></table></figure>



<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><ol>
<li><p><code>win+r</code> 输入 <code>regedit</code>, 打开注册表</p>
</li>
<li><p>找到 <code>计算机\HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS</code> 项</p>
</li>
<li><p>新建字符串值</p>
<p>名为 <code>UserDefinedDoublePinyinScheme0</code></p>
<p>值为 <code>小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt</code></p>
</li>
</ol>
<h1 id="按键映射"><a href="#按键映射" class="headerlink" title="按键映射"></a>按键映射</h1><h2 id="互换按键reg文件"><a href="#互换按键reg文件" class="headerlink" title="互换按键reg文件"></a>互换按键reg文件</h2><h3 id="交换-esc-和-caps-lock-按键"><a href="#交换-esc-和-caps-lock-按键" class="headerlink" title="交换 esc 和 caps lock 按键"></a>交换 esc 和 caps lock 按键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]</span><br><span class="line">&quot;Scancode Map&quot;=hex:00,00,00,00,00,00,00,00,03,00,00,00,3a,00,01,00,01,00,3a,00,00,00,00,00</span><br></pre></td></tr></table></figure>

<h3 id="交换-ctrl-和-caps-lock-按键"><a href="#交换-ctrl-和-caps-lock-按键" class="headerlink" title="交换 ctrl 和 caps lock 按键"></a>交换 ctrl 和 caps lock 按键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]</span><br><span class="line">&quot;Scancode Map&quot;=hex:00,00,00,00,00,00,00,00,03,00,00,00,3a,00,1d,00,1d,00,3a,00,00,00,00,00</span><br></pre></td></tr></table></figure>


<h3 id="取消互换按键"><a href="#取消互换按键" class="headerlink" title="取消互换按键"></a>取消互换按键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"> </span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]</span><br><span class="line">&quot;Scancode Map&quot;=-</span><br></pre></td></tr></table></figure>



<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout\</code> 下新建一个二进制值项： “Scancode Map”</p>
<p>Scancode Map格式说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 (固定格式)</span><br><span class="line">XX 00 00 00 (XX为修改的总键数+1的16进制数)</span><br><span class="line">XX XX XX XX (修改后的按键扫描码 (在前) + 原按键的扫描码 (在后))</span><br><span class="line">XX XX XX XX (另一个要替换的按键，同上)</span><br><span class="line">......</span><br><span class="line">00 00 00 00 (固定格式)</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 00 00 00 00 00 00 00 00 	</span><br><span class="line">0008 04 00 00 00 1D 00 5B E0 </span><br><span class="line">0010 1D E0 5C E0 5B E0 1D 00</span><br><span class="line">0018 00 00 00 00 </span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>00 00 00 00 00 00 00 00</code>:  固定，照写就好</p>
</li>
<li><p><code>04 00 00 00</code>:  04代表要修改三个按键的映射，两个是02，一个是01</p>
</li>
<li><p><code>1D 00 5B E0</code></p>
<ul>
<li><code>1D 00</code> : 是修改后的按键扫描码；</li>
<li><code>5B E0</code> : 是原按键的扫描码；</li>
</ul>
<p> 左Ctrl键的扫描码是1D 00，左win键的扫描码5B E0；<br> 这四个字节代表的意思是将 左win键 替换成 左Ctrl键。</p>
</li>
<li><p><code>1D E0 5C E0</code>: 这四个字节代表的意思是将 右win键 替换成 右Ctrl键。</p>
</li>
<li><p><code>5B E0 1D 00</code>: 这四个字节代表的意思是将 左Ctrl键 替换成 左win键。</p>
</li>
<li><p><code>00 00 00 00</code>: 固定，照写就好</p>
</li>
</ol>
<h2 id="键位16进制对应表"><a href="#键位16进制对应表" class="headerlink" title="键位16进制对应表"></a>键位16进制对应表</h2><img data-src="/2023/06/23/157/5e8d9654f57bc9f79a1c68d8df2a3c09e4684651.png" class="" title="img">


<h1 id="office-365"><a href="#office-365" class="headerlink" title="office 365"></a>office 365</h1><h2 id="Office-365-Professional-Plus"><a href="#Office-365-Professional-Plus" class="headerlink" title="Office 365 Professional Plus"></a>Office 365 Professional Plus</h2><ul>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-CN/O365ProPlusRetail.img">简体中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-TW/O365ProPlusRetail.img">繁体中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/en-US/O365ProPlusRetail.img">English</a></li>
</ul>
<h2 id="Office-365-Home-Premium"><a href="#Office-365-Home-Premium" class="headerlink" title="Office 365 Home Premium"></a>Office 365 Home Premium</h2><ul>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-CN/O365HomePremRetail.img">简体中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-TW/O365HomePremRetail.img">繁体中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/en-US/O365HomePremRetail.img">English</a></li>
</ul>
<h2 id="Office-365-Business"><a href="#Office-365-Business" class="headerlink" title="Office 365 Business"></a>Office 365 Business</h2><ul>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-CN/O365BusinessRetail.img">简体中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-TW/O365BusinessRetail.img">繁体中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/en-US/O365BusinessRetail.img">English</a></li>
</ul>
<h1 id="office-2021"><a href="#office-2021" class="headerlink" title="office 2021"></a>office 2021</h1><h2 id="Office-ProPlus-2021"><a href="#Office-ProPlus-2021" class="headerlink" title="Office ProPlus 2021"></a>Office ProPlus 2021</h2><p><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2021Retail.img">下载地址</a></p>
<h2 id="Visio-Pro-2021"><a href="#Visio-Pro-2021" class="headerlink" title="Visio Pro 2021"></a>Visio Pro 2021</h2><p><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-cn/VisioPro2021Retail.img">下载地址</a></p>
<h2 id="Project-Pro-2021"><a href="#Project-Pro-2021" class="headerlink" title="Project Pro 2021"></a>Project Pro 2021</h2><p><a target="_blank" rel="noopener" href="https://officecdn.microsoft.com/db/492350F6-3A01-4F97-B9C0-C7C6DDF67D60/media/zh-cn/ProjectPro2021Retail.img">下载地址</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/23/156/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/23/156/" class="post-title-link" itemprop="url">156. vagrant + virturalbox 环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-23 15:00:00" itemprop="dateCreated datePublished" datetime="2023-06-23T15:00:00+08:00">2023-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="vagrant-安装"><a href="#vagrant-安装" class="headerlink" title="vagrant 安装"></a>vagrant 安装</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul>
<li><p>vagrant <a target="_blank" rel="noopener" href="https://developer.hashicorp.com/vagrant/downloads">官网地址</a></p>
</li>
<li><p>vagrantbox</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.hashicorp.com/vagrant/docs/boxes">官方文档</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://app.vagrantup.com/boxes/search?provider=virtualbox">下载地址</a></p>
 <img data-src="/2023/06/23/156/image-20230623074435666.png" class="" title="image-20230623074435666"></li>
</ul>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>添加 box 到vagrant</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add &lt;box_name&gt; &lt;box_path&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;box_name&gt;</code>: 为 box 取的名字，供后续创建虚拟机</li>
<li><code>&lt;box_path&gt;</code>: vagrantbox 所在地址</li>
</ul>
</li>
<li><p>查看是否添加成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box list</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建虚拟机</p>
<p>创建一个目录, 然后在该目录下执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init &lt;box_name&gt;</span><br></pre></td></tr></table></figure>

<p>会生成一个 <code>Vagrantfile</code> 文件</p>
</li>
<li><p>修改 <code>Vagrantfile</code> 文件配置</p>
</li>
<li><p>启动虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>

<ul>
<li>默认用户: <code>vagrant</code></li>
<li>用户密码: <code>vagrant</code></li>
</ul>
</li>
<li><p>关闭虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant halt</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>PS: </p>
<ul>
<li>每次启动虚拟机需要使用命令行（cmd）进入 <code>Vagrantfile</code> 文件所在的目录，然后再使用 <code>vagrant up</code> 命令启动虚拟机。</li>
<li>关机同理，使用命令行（cmd）进入 <code>Vagrantfile</code> 文件所在的目录，然后再使用 <code>vagrant halt</code> 命令关闭虚拟机。</li>
</ul>
</blockquote>
<h1 id="virtualbox-安装"><a href="#virtualbox-安装" class="headerlink" title="virtualbox 安装"></a>virtualbox 安装</h1><h2 id="下载地址-1"><a href="#下载地址-1" class="headerlink" title="下载地址"></a>下载地址</h2><ul>
<li><p>官网<a target="_blank" rel="noopener" href="https://www.virtualbox.org/wiki/Downloads">下载地址</a></p>
</li>
<li><p>c++依赖<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-CN/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022">下载地址</a></p>
 <img data-src="/2023/06/23/156/image-20230623072754976.png" class="" title="image-20230623072754976">

<p> 按需下载即可</p>
</li>
</ul>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p>双击打开, 默认安装就可以</p>
<h2 id="Ubuntu镜像地址"><a href="#Ubuntu镜像地址" class="headerlink" title="Ubuntu镜像地址"></a>Ubuntu镜像地址</h2><p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">清华镜像站</a></p>
<p>fate 官方测试使用的版本为 18.04</p>
<h1 id="vagrant-系统外部可访问"><a href="#vagrant-系统外部可访问" class="headerlink" title="vagrant 系统外部可访问"></a>vagrant 系统外部可访问</h1><blockquote>
<p>win10系统下的设置</p>
</blockquote>
<h2 id="step1-设置防火墙入站规则"><a href="#step1-设置防火墙入站规则" class="headerlink" title="step1. 设置防火墙入站规则"></a>step1. 设置防火墙入站规则</h2><ol>
<li><p>进入windows 防火墙</p>
</li>
<li><p>控制面板 -&gt; 系统和安全  -&gt; Windows Defender 防火墙 -&gt; 高级设置 -&gt; 入站规则 -&gt; 文件和打印机共享(回显请求 - ICMPv4-In)</p>
</li>
<li><p>右键属性 -&gt; 作用域 -&gt; 远程IP地址 -&gt; 下列 IP 地址 -&gt; 添加</p>
</li>
<li><p>我使用的是 <code>此IP地址或子网</code></p>
<p>目的: 仅允许部分用户使用</p>
<p>如添加: <code>10.132.0.0/16</code></p>
</li>
</ol>
<p><strong>测试是否成功配置</strong></p>
<p>即查看是否可以 ping 通</p>
<h2 id="step2-设置-vagrantfile-为桥接网络"><a href="#step2-设置-vagrantfile-为桥接网络" class="headerlink" title="step2. 设置 vagrantfile 为桥接网络"></a>step2. 设置 vagrantfile 为桥接网络</h2><ol>
<li><p>查看名称或接口索引</p>
<ul>
<li><p>方法1</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv4 show interfaces</span><br></pre></td></tr></table></figure>

<p> 我的这里是 <code>WLAN</code></p>
</li>
<li><p>方法2 (未测试)</p>
<ol>
<li>打开”控制面板”。您可以在开始菜单中搜索”控制面板”，然后选择相应的结果打开它。</li>
<li>在控制面板窗口中，将视图设置为”小图标”或”大图标”，以便更轻松找到所需的项目。</li>
<li>找到并点击”网络和共享中心”。</li>
<li>在左侧导航栏中，点击”更改适配器设置”，以打开网络连接设置。</li>
<li>在网络连接设置中，您将看到可用的网络适配器列表。查找您希望用作桥接网络的适配器，例如您的有线网卡或无线网卡。</li>
<li>右键单击所选适配器，并选择”属性”。</li>
<li>在适配器属性对话框中，找到并选中”Internet 协议版本 4 (TCP&#x2F;IPv4)”，然后点击”属性”按钮。</li>
<li>在”Internet 协议版本 4 (TCP&#x2F;IPv4) 属性”对话框中，您可以看到适配器的IP地址配置。请注意当前配置的详细信息，以便在后续步骤中进行参考。</li>
<li>在同一对话框中，点击”高级”按钮。</li>
<li>在”高级 TCP&#x2F;IP 设置”对话框中，切换到”IP 设置”选项卡。</li>
<li>在”IP 设置”选项卡中，您将看到网卡的名称和接口索引。记下名称或接口索引，这将用于Vagrantfile中的网络配置。</li>
</ol>
</li>
</ul>
</li>
<li><p>设置 <code>config.vm.network &quot;public_network&quot;, bright: &quot;WLAN&quot;</code></p>
<p><code>bright</code>: 就是上面的“查看名称或接口索引 ”</p>
</li>
<li><p>启动&#x2F;重启虚拟机: <code>vagrant up</code>&#x2F;<code>vagrant reload</code></p>
</li>
<li><p>查看ip地址: <code>ifconfig</code>, 我这里的是 <code>10.132.22.5</code></p>
</li>
<li><p>设置Vigrant: <code>config.vm.network &quot;public_network&quot;, bright: &quot;WLAN&quot;, ip: &quot;10.132.22.5&quot;</code></p>
<blockquote>
<p>也可以加入子网掩码, 如 <code>config.vm.network &quot;public_network&quot;, bridge: &quot;WLAN&quot;, netmask: &quot;255.255.0.0&quot;, ip: &quot;10.132.22.5&quot;</code></p>
</blockquote>
</li>
</ol>
<h2 id="step3-更改-vagrant-密码"><a href="#step3-更改-vagrant-密码" class="headerlink" title="step3. 更改 vagrant 密码"></a>step3. 更改 vagrant 密码</h2><p><code>passwd</code></p>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">passwd vagrant</span><br></pre></td></tr></table></figure>

<p>PS: 更多信息查看 Ubuntu 处理方法</p>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ul>
<li>华硕主板打不开virtualbox虚拟机的ubuntu安装系统 (虚拟机VirtualBox异常退出解决办法)</li>
<li>vagrant ssh 连接 remote host identification has changed</li>
<li>解决vagrant ssh登录时permission deny的问题</li>
</ul>
<h2 id="华硕主板打不开virtualbox虚拟机的ubuntu安装系统-虚拟机VirtualBox异常退出解决办法"><a href="#华硕主板打不开virtualbox虚拟机的ubuntu安装系统-虚拟机VirtualBox异常退出解决办法" class="headerlink" title="华硕主板打不开virtualbox虚拟机的ubuntu安装系统 (虚拟机VirtualBox异常退出解决办法)"></a>华硕主板打不开virtualbox虚拟机的ubuntu安装系统 (虚拟机VirtualBox异常退出解决办法)</h2><h2 id="vagrant-启动失败-There-was-an-error-while-executing-VBoxManage-a-CLI-used-by-Vagrant-for-controlli……"><a href="#vagrant-启动失败-There-was-an-error-while-executing-VBoxManage-a-CLI-used-by-Vagrant-for-controlli……" class="headerlink" title="vagrant 启动失败 There was an error while executing VBoxManage, a CLI used by Vagrant for controlli……"></a>vagrant 启动失败 There was an error while executing VBoxManage, a CLI used by Vagrant for controlli……</h2><p>进入 BIOS 下, 开启 <code>Intel (VMX) 虚拟化技术</code></p>
<img data-src="/2023/06/23/156/image-20230623074137777.png" class="" title="image-20230623074137777">





<h2 id="vagrant-ssh-连接-remote-host-identification-has-changed"><a href="#vagrant-ssh-连接-remote-host-identification-has-changed" class="headerlink" title="vagrant ssh 连接 remote host identification has changed"></a>vagrant ssh 连接 remote host identification has changed</h2><img data-src="/2023/06/23/156/20170726161546339.png" class="" title="img">

<p>找到<code>.ssh</code>目录，下面有一个<code>known_hosts</code>文件，删除 <code>~/.ssh/known_hosts</code> 文件，或者如果你可以判断出<code>known_hosts</code>中原ssh服务器的公钥，删去那部分，</p>
<h2 id="解决vagrant-ssh登录时permission-deny的问题"><a href="#解决vagrant-ssh登录时permission-deny的问题" class="headerlink" title="解决vagrant ssh登录时permission deny的问题"></a>解决vagrant ssh登录时permission deny的问题</h2><ol>
<li><p>进入虚拟机</p>
<ul>
<li><p>方法1: <code>vagrant ssh</code></p>
<p> 在 <code>Vagrantfile</code> 文件夹下打开 <code>cmd</code>, 运行命令 <code>vagrant ssh</code></p>
</li>
<li><p>方法2: virtualbox</p>
<p> 打开 <code>Vagrantfile</code> 中的 virtualbox 显示</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provider &quot;virtualbox&quot; do |vb|      </span><br><span class="line">    vb.gui = true      # 启动机器时显示 VirtualBox GUI    </span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<p> 然后运行 <code>vagrant up</code> (虚拟机处于关机状态) 或 <code>vagrant reload</code> (虚拟机处于开机状态)</p>
</li>
</ul>
</li>
<li><p>更改 <code>/etc/ssh/sshd_config</code> 文件下的 <code>PasswordAuthentication no</code> 改为 <code>PasswordAuthentication yes</code></p>
</li>
<li><p>重启虚拟机 <code>vagrant reload</code></p>
</li>
</ol>
<h2 id="不在一个小局域网，而在同一个大局域网"><a href="#不在一个小局域网，而在同一个大局域网" class="headerlink" title="不在一个小局域网，而在同一个大局域网"></a>不在一个小局域网，而在同一个大局域网</h2><p>那就把局域网扩大一些, 可以通过设置子网掩码来设置</p>
<ul>
<li><p>临时设置子网掩码</p>
<ol>
<li><p>查看网络: <code>ifconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255</span><br><span class="line">        inet6 fe80::3b:7bff:feb7:3b2d  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:3b:7b:b7:3b:2d  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 523  bytes 61926 (61.9 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 387  bytes 70310 (70.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">enp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.10.32.32  netmask 255.255.255.0  broadcast 10.10.32.255</span><br><span class="line">        inet6 240c:c983:5:2b48::813  prefixlen 128  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 240c:c983:5:2b48:a00:27ff:feab:56e5  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::a00:27ff:feab:56e5  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 08:00:27:ab:56:e5  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1089  bytes 184808 (184.8 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 85  bytes 12017 (12.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置子网</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig enp0s8 10.10.32.32 netmask 255.255.0.0</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/08/155/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/08/155/" class="post-title-link" itemprop="url">155. VIM 从偶尔到日常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-08 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-08T00:00:00+08:00">2023-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第22章-Vimrc"><a href="#第22章-Vimrc" class="headerlink" title="第22章 Vimrc"></a>第22章 Vimrc</h1><p>在先前的章节中，您学习了如何使用Vim。在本章，您将学习如何组织和配置Vimrc。</p>
<h2 id="Vim如何找到Vimrc"><a href="#Vim如何找到Vimrc" class="headerlink" title="Vim如何找到Vimrc"></a>Vim如何找到Vimrc</h2><p>对于Vimrc，常见的理解是在根目录下添加一个 <code>.vimrc</code> 点文件（根据您使用的操作系统，文件路径名可能不同）。</p>
<p>实际上，Vim在多个地方查找vimrc文件。下面是Vim检查的路径：</p>
<ul>
<li><code>$VIMINIT</code></li>
<li><code>$HOME/.vimrc</code></li>
<li><code>$HOME/.vim/vimrc</code></li>
<li><code>$EXINIT</code></li>
<li><code>$HOME/.exrc</code></li>
<li><code>$VIMRUNTIME/default.vim</code></li>
</ul>
<p>当您启动Vim时，它将在上面列出的6个位置按顺序检查vimrc文件，第一个被找到的vimrc文件将被加载，而其余的将被忽略。</p>
<p>首先，Vim将查找环境变量 <code>$VIMINIT</code>。如果没有找到，Vim将检查 <code>$HOME/.vimrc</code>。如果还没找到，VIm就检查 <code>$HOME/.vim/vimrc</code>。如果Vim找到了vimrc文件，它就停止查找，并使用 <code>$HOME/.vim/vimrc</code>。</p>
<p>关于第一个位置，<code>$VIMINIT</code> 是一个环境变量。默认情况下它是未定义的。如果您想将 <code>~/dotfiles/testvimrc</code> 作为 <code>$VIMINTI</code> 的值，您可以创建一个包含那个vimrc路径的环境变量。当您运行 <code>export VIMINIT=&#39;let $MYVIMRC=&quot;$HOME/dotfiles/testvimrc&quot; | source $MYVIMRC&#39;</code>后，VIm将使用 <code>~/dotfiles/testvimrc</code> 作为您的vimrc文件。</p>
<p>第二个位置，<code>$HOME/.vimrc</code> 是很多Vim用户习惯使用的路径。<code>$HOME</code> 大部分情况下是您的根目录（<code>~</code>）。如果您有一个 <code>~/.vimrc</code> 文件，Vim将使用它作为您的vimrc文件。</p>
<p>第三个，<code>$HOME/.vim/vimrc</code>，位于 <code>~/.vim</code> 目录中。您可能已经有了一个 <code>~/.vim</code> 目录用于存放插件、自定义脚本、或视图文件。注意这里的vimrc文件名没有“点”（<code>$HOME/.vim/.vimrc</code> 不会被识别，但 <code>$HOME/.vim/vimrc</code>能被识别）。</p>
<p>第四个，<code>$EXINIT</code> 工作方式与 <code>$VIMINIT</code> 类似。</p>
<p>第五个，<code>$HOME/.exrc</code> 工作方式与 <code>$HOME/.vimrc</code> 类似。</p>
<p>第六个，<code>$VIMRUNTIME/defaults.vim</code> 是Vim编译时自带的默认vimrc文件。在我的电脑中，我是使用Homebrew安装的Vim8.2，所以我的路径是（<code>/usr/local/share/vim/vim82</code>）。如果Vim在前5个位置都没有找到vimrc文件，它将使用这个Vim自带的vimrc文件。</p>
<p>在本章剩余部分，我将假设vimrc使用的路径是 <code>~/.vimrc</code>。</p>
<h2 id="应该把什么放在Vimrc中？"><a href="#应该把什么放在Vimrc中？" class="headerlink" title="应该把什么放在Vimrc中？"></a>应该把什么放在Vimrc中？</h2><p>我刚开始配置Vimrc时，曾问过一个问题，“我究竟该把什么放在Vimrc文件中？”。</p>
<p>答案是，“任何您想放的东西”。 直接复制粘贴别人的vimrc文件的确是一个诱惑，但您应当抵制这个诱惑。如果您仍然坚持使用别人的vimrc文件，确保您知道这个vimrc干了什么，为什么他&#x2F;她要用这些设置？以及他&#x2F;她如何使用这些设置？还有最重要的是，这个vimrc文件是否符合你的实际需要？别人使用并不代表您也要使用。</p>
<h2 id="Vimrc基础内容"><a href="#Vimrc基础内容" class="headerlink" title="Vimrc基础内容"></a>Vimrc基础内容</h2><p>简单地说，一个vimrc是以下内容的集合：</p>
<ul>
<li>插件</li>
<li>设置</li>
<li>自定义函数</li>
<li>自定义命令</li>
<li>键盘映射</li>
</ul>
<p>当然还有一些上面没有提到的内容，但总体说，已经涵盖了绝大部分使用场景。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>在前面的章节中，我曾提到很多不同的插件，比如<a target="_blank" rel="noopener" href="https://github.com/junegunn/fzf.vim">fzf.vim</a>, <a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a>, 还有 <a target="_blank" rel="noopener" href="https://github.com/tpope/vim-fugitive">vim-fugitive</a>.</p>
<p>十年前，管理插件插件是一个噩梦。但随着很多现代插件管理器的开发，现在安装插件可以在几秒内完成。我现在正在使用<a target="_blank" rel="noopener" href="https://github.com/junegunn/vim-plug">vim-plug</a>作为我的插件管理器，所以我在本节中将使用它。相关概念和其他流行的插件管理器应该是类似的。我强烈建议您多试试几个插件管理器，比如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/VundleVim/Vundle.vim">vundle.vim</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tpope/vim-pathogen">vim-pathogen</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Shougo/dein.vim">dein.vim</a></li>
</ul>
<p>除了上面列出的，还有很多插件管理器，可以随便看看。要想安装 vim-plug，如果您使用的是Unix，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>

<p>要添加新的插件，将您的插件名(比如，<code>Plug &#39;github-username/repository-name&#39;</code>) 放置在 <code>call plug#begin()</code> 和 <code>call plug#end()</code> 之间的行中. 所以，如果您想安装 <code>emmet-vim</code> 和 <code>nerdtree</code>，将下面的片段放到您的vimrc中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">  Plug &#x27;mattn/emmet-vim&#x27;</span><br><span class="line">  Plug &#x27;preservim/nerdtree&#x27;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>

<p>然后保存修改，加载当前vimrc (<code>:source %</code>), 然后运行 <code>:PlugInstall</code> 安装插件。</p>
<p>如果以后您想删除不使用的插件，您只需将插件名从 <code>call</code> 代码块之间移除，保存并加载，然后运行 <code>:PlugClean</code> 命令将它从机器上删除。</p>
<p>Vim 8 有自己的内置包管理器。您可以查阅 <code>:h packages</code> 了解更多信息。在后面一章中，我将向您展示如何使用它。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>在任意一个vimrc文件中都可以看到大量的 <code>set</code> 选项。 如果您在命令行模式中运行 set 命令，它只是暂时的。当您关闭Vim，设置就会丢失。比如，为了避免您每次运行Vim时都必须在命令行模式运行 <code>:set relativenumber number</code> 命令，您可以将这个命令添加在vimrc中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set relativenumber number</span><br></pre></td></tr></table></figure>

<p>有一些设置需要您赋予一个值，比如 <code>set tabstop=2</code>。想了解一个设置可以接收什么类型的值，可以查看帮助页。</p>
<p>您也可以使用 <code>let</code> 来代替 <code>set</code>（&#x3D;&#x3D;确保在选项前添加一个 <code>&amp;</code>号&#x3D;&#x3D;）。使用 <code>let</code> ，您可以使用表达式进行赋值。比如，要想仅当某个路径存在时，才将该路径赋予 <code>&#39;dictionary&#39;</code> 选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s:english_dict = &quot;/usr/share/dict/words&quot;</span><br><span class="line"></span><br><span class="line">if filereadable(s:english_dict)</span><br><span class="line">  let &amp;dictionary=s:english_dict</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>在后面的章节中您将了解关于Vimscript赋值和条件的知识。</p>
<p>要查看Vim中所有可用的选项，查阅 <code>:h E355</code>。</p>
<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>Vimrc是一个很好的用来放置自定义函数的地方。在后面的章节中您将学习如何写您自己的Vimscript函数。</p>
<h3 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h3><p>您可以使用 <code>command</code> 创建一个自定义命令行命令。</p>
<p>比如，创建一个用于显示今天日期的基本命令 <code>GimmeDate</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:command! GimmeDate echo call(&quot;strftime&quot;, [&quot;%F&quot;])</span><br></pre></td></tr></table></figure>

<p>当您运行 <code>:GimmeDate</code> 时，Vim将显示一个类似 “2021-01-1”的日期。</p>
<p>要创建一个可以接收输入的基本命令，您可以使用 <code>&lt;args&gt;</code> 。如果您想向 <code>GimmeDate</code> 传递一个时间&#x2F;日期格式参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:command! GimmeDate echo call(&quot;strftime&quot;, [&lt;args&gt;])</span><br><span class="line"></span><br><span class="line">:GimmeDate &quot;%F&quot;</span><br><span class="line">&quot; 2020-01-01</span><br><span class="line"></span><br><span class="line">:GimmeDate &quot;%H:%M&quot;</span><br><span class="line">&quot; 11:30</span><br></pre></td></tr></table></figure>

<p>如果您想限定参数的数目，您可以使用 <code>-nargs</code> 标志。<code>-nargs=0</code> 表示没有参数，<code>-nargs=1</code> 表示传递1个参数，<code>-nargs=+</code> 表示至少1个参数，<code>-nargs=*</code> 表示传递任意数量的参数，<code>-nargs=?</code> 表示传递0个或1个参数。如果您想传递n个参数，使用 <code>-nargs=n</code>（这里 <code>n</code> 是一个任意整数）。</p>
<p><code>&lt;args&gt;</code> 有两个变体：<code>&lt;f-args&gt;</code> 和 <code>&lt;q-args&gt;</code> 。前者用来向Vimscript函数传递参数，后者用来将用户输入自动转换为字符串。</p>
<p>使用 <code>args</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:command! -nargs=1 Hello echo &quot;Hello &quot; . &lt;args&gt;</span><br><span class="line">:Hello &quot;Iggy&quot;</span><br><span class="line">&quot; returns &#x27;Hello Iggy&#x27;</span><br><span class="line"></span><br><span class="line">:Hello Iggy</span><br><span class="line">&quot; Undefined variable error</span><br></pre></td></tr></table></figure>

<p>使用 <code>q-args</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:command! -nargs=1 Hello echo &quot;Hello &quot; . &lt;q-args&gt;</span><br><span class="line">:Hello Iggy</span><br><span class="line">&quot; returns &#x27;Hello Iggy&#x27;</span><br></pre></td></tr></table></figure>

<p>使用 <code>f-args</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:function! PrintHello(person1, person2)</span><br><span class="line">:  echo &quot;Hello &quot; . a:person1 . &quot; and &quot; . a:person2</span><br><span class="line">:endfunction</span><br><span class="line"></span><br><span class="line">:command! -nargs=* Hello call PrintHello(&lt;f-args&gt;)</span><br><span class="line"></span><br><span class="line">:Hello Iggy1 Iggy2</span><br><span class="line">&quot; returns &quot;Hello Iggy1 and Iggy2&quot;</span><br></pre></td></tr></table></figure>

<p>当您学了关于Vimscript函数的章节后，上面的函数将更有意义。</p>
<p>查阅 <code>:h command</code> 和 <code>:args</code> 了解更多关于command和args的信息。</p>
<h3 id="键盘映射"><a href="#键盘映射" class="headerlink" title="键盘映射"></a>键盘映射</h3><p>如果您发现您重复地执行一些相同的复杂操作，那么为这些复杂操作建立一个键盘映射将会很有用：</p>
<p>比如，在我的vimrc文件中有2个键盘映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;silent&gt; &lt;C-f&gt; :GFiles&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">nnoremap &lt;Leader&gt;tn :call ToggleNumber()&lt;CR&gt;</span><br></pre></td></tr></table></figure>

<p>在第一个中，我将 <code>Ctrl-F</code> 映射到 <a target="_blank" rel="noopener" href="https://github.com/junegunn/fzf.vim">fzf.vim</a> 插件的 <code>:Gfiles</code> 命令(快速搜索Git文件)上。在第二个中，我将 <code>&lt;leader&gt;tn</code> 映射到调用一个自定义函数 <code>ToggleNumber</code> （切换 <code>norelativenumber</code> 和 <code>relativenumber</code> 选项）。<code>Ctrl-f</code> 映射覆盖了Vim的原生的页面滚动。如果发生冲突，您的映射将会覆盖Vim的设置。因为从几乎从来不用Vim原生的页面滚动功能，所以我认为可以安全地覆盖它。</p>
<p>另外，在 <code>&lt;Leader&gt;tn</code> 中的 “leader” 键到底是什么?</p>
<p>Vim有一个leader键用来辅助键盘映射。比如，我将 <code>&lt;leader&gt;tn</code> 映射为运行 <code>ToggleNumber()</code> 函数。如果没有leader键，我可能会用 <code>tn</code>，但Vim中的 <code>t</code> 已经用做其他功能（”till”搜索导航命令）了。有了leader键，我现在先按定义好的leader键作为开头，然后按 <code>tn</code>，而不用干扰已经存在的命令。您可以设置leader键作为您映射的连续按键的第一个按键。默认Vim使用反斜杠作为leader键（所以 <code>&lt;Leader&gt;tn</code> 会变成 “反斜杠-t-n”）。</p>
<p>我个人喜欢使用空格 <code>&lt;Space&gt;</code> 作为leader键，代替默认的反斜杠。要想改变您的leader键，将下面的文本添加到您的vimrc中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mapleader = &quot;\&lt;space&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>nnoremap</code> 命令可以分解为三个部分：</p>
<ul>
<li><code>n</code> 表示普通模式。</li>
<li><code>nore</code> 表示禁止递归。</li>
<li><code>map</code> 是键盘映射命令。</li>
</ul>
<p>如果不想使用 <code>nnoremap</code>，您至少也得使用 <code>nmap</code> (<code>nmap &lt;silent&gt; &lt;C-f&gt; :Gfiles&lt;CR&gt;</code>)。但是，最好还是使用禁止递归的版本，这样是为了避免键盘映射时潜在的无限循环风险。</p>
<p>如果您进行键盘映射时不使用禁止递归，下面例子演示了会发生什么。假设您想给 <code>B</code> 添加一个键盘映射，用来在一行的末尾添加一个分号，然后跳回前一个词组（回想一下，<code>B</code> 是Vim普通模式的一个导航命令，用来跳回前一个词组)。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap B A;&lt;esc&gt;B</span><br></pre></td></tr></table></figure>

<p>当您按下 <code>B</code> …哦豁，Vim开始失控了，开始无止尽的添加<code>;</code>（用 <code>Ctrl-c</code>终止）。为什么会发生这样的情况？因为在键盘映射 <code>A;&lt;esc&gt;B</code>中，这个 <code>B</code>不再是Vim原生的导航命令，它已经被映射到您刚才创建的键盘映射中了。这是您实际上执行的操作序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A;&lt;esc&gt;A;&lt;esc&gt;A;&lt;esc&gt;A;esc&gt;...</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，您需要指定键盘映射禁止递归：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap B A;&lt;esc&gt;B</span><br></pre></td></tr></table></figure>

<p>现在再按一下 <code>B</code> 试试。这一次它成功地在行尾添加了一个 <code>;</code>，然后跳回到前一个词组。这个映射中的 <code>B</code> 就表示Vim原生的 <code>B</code>了。</p>
<p>Vim针对不同的模式有不同的键盘映射命令。如果您想创建一个插入模式下的键盘映射 <code>jk</code>，用来退出插入模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure>

<p>其他模式的键盘映射命令有：<code>map</code>（普通、可视、选择、以及操作符等待模式）， <code>vmap</code>（可视、选择）， <code>smap</code>（选择）， <code>xmap</code>（可视）， <code>omap</code>（操作符等待模式）， <code>map!</code>（插入、命令行）， <code>lmap</code>（插入，命令行，Lang-arg模式）， <code>cmap</code>（命令行）， 还有<code>tmap</code>（终端任务）。在这里我不会详细的讲解它们，要了解更多信息，查阅 <code>:h map.txt</code>。</p>
<p>创建最直观、最一致、最易于记忆的键盘映射。</p>
<h2 id="组织管理Vimrc"><a href="#组织管理Vimrc" class="headerlink" title="组织管理Vimrc"></a>组织管理Vimrc</h2><p>一段时候键，您的vimrc文件就会变大且复杂得难以阅读。有两种方法让您的vimrc文件保持整洁：</p>
<ul>
<li>将您的vimrc文件划分为几个文件</li>
<li>折叠您的vimrc文件</li>
</ul>
<h3 id="划分您的vimrc"><a href="#划分您的vimrc" class="headerlink" title="划分您的vimrc"></a>划分您的vimrc</h3><p>您可以使用Vim的 <code>:source</code> 命令将您的vimrc文件划分为多个文件。这个命令可以根据给定的文件参数，读取文件中的命令行命令。</p>
<p>让我们在 <code>~/.vim</code> 下创建一个子文件夹，取名为 <code>/settings</code>（<code>~/.vim/settings</code>）。名字可以取为任意您喜欢的名字。</p>
<p>然后你在这个文件夹下创建4个文件：</p>
<ul>
<li>第三方插件 (<code>~/.vim/settings/plugins.vim</code>).</li>
<li>通用设置 (<code>~/.vim/settings/configs.vim</code>).</li>
<li>自定义函数 (<code>~/.vim/settings/functions.vim</code>).</li>
<li>键盘映射 (<code>~/.vim/settings/mappings.vim</code>) .</li>
</ul>
<p>在 <code>~/.vimrc</code> 里面添加:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source $HOME/.vim/settings/plugins.vim</span><br><span class="line">source $HOME/.vim/settings/configs.vim</span><br><span class="line">source $HOME/.vim/settings/functions.vim</span><br><span class="line">source $HOME/.vim/settings/mappings.vim</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.vim/settings/plugins.vim</code> 里面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">  Plug &#x27;mattn/emmet-vim&#x27;</span><br><span class="line">  Plug &#x27;preservim/nerdtree&#x27;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.vim/settings/configs.vim</code> 里面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">set relativenumber</span><br><span class="line">set number</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.vim/settings/functions.vim</code> 里面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function! ToggleNumber()</span><br><span class="line">  if(&amp;relativenumber == 1)</span><br><span class="line">    set norelativenumber</span><br><span class="line">  else</span><br><span class="line">    set relativenumber</span><br><span class="line">  endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.vim/settings/mappings.vim</code> 里面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inoremap jk &lt;esc&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;C-f&gt; :GFiles&lt;CR&gt;</span><br><span class="line">nnoremap &lt;Leader&gt;tn :call ToggleNumber()&lt;CR&gt;</span><br></pre></td></tr></table></figure>

<p>这样您的vimrc文件依然能够正常工作，但现在它只有4行了。</p>
<p>使用这样的设置，您可以轻易知道到哪去修改配置。如果您要添加一些键盘映射，就将它们添加在 <code>/mappings.vim</code> 文件中。以后，当您的vimrc变大时，您总是可以新建几个子文件来缩小它的大小。比如，如果您想为主题配色创建相关设置，您可以添加 <code>~/.vim/settings/themes.vim</code>。</p>
<h3 id="保持单独的一个Vimrc文件"><a href="#保持单独的一个Vimrc文件" class="headerlink" title="保持单独的一个Vimrc文件"></a>保持单独的一个Vimrc文件</h3><p>如果您倾向于保持一个单独的vimrc文件，以使它更加便于携带，您可以使用标志折叠让它保持有序。在vimrc文件的顶部添加一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot; setup folds &#123;&#123;&#123;</span><br><span class="line">augroup filetype_vim</span><br><span class="line">  autocmd!</span><br><span class="line">  autocmd FileType vim setlocal foldmethod=marker</span><br><span class="line">augroup END</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Vim能够检测当前buffer所属的文件类型 (<code>:set filetype?</code>). 如果发现属于 <code>vim</code> 类型，您可以使用标志折叠。回想一个标志折叠的用法，它使用 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 来指明折叠的开始和结束。</p>
<p>添加 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 标志将您的vimrc文件其他部分折叠起来。(别忘了使用 <code>&quot;</code> 对标志进行注释):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&quot; setup folds &#123;&#123;&#123;</span><br><span class="line">augroup filetype_vim</span><br><span class="line">  autocmd!</span><br><span class="line">  autocmd FileType vim setlocal foldmethod=marker</span><br><span class="line">augroup END</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&quot; plugins &#123;&#123;&#123;</span><br><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">  Plug &#x27;mattn/emmet-vim&#x27;</span><br><span class="line">  Plug &#x27;preservim/nerdtree&#x27;</span><br><span class="line">call plug#end()</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&quot; configs &#123;&#123;&#123;</span><br><span class="line">set nocompatible</span><br><span class="line">set relativenumber</span><br><span class="line">set number</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&quot; functions &#123;&#123;&#123;</span><br><span class="line">function! ToggleNumber()</span><br><span class="line">  if(&amp;relativenumber == 1)</span><br><span class="line">    set norelativenumber</span><br><span class="line">  else</span><br><span class="line">    set relativenumber</span><br><span class="line">  endif</span><br><span class="line">endfunc</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&quot; mappings &#123;&#123;&#123;</span><br><span class="line">inoremap jk &lt;esc&gt;</span><br><span class="line">nnoremap &lt;silent&gt; &lt;C-f&gt; :GFiles&lt;CR&gt;</span><br><span class="line">nnoremap &lt;Leader&gt;tn :call ToggleNumber()&lt;CR&gt;</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>您的vimrc文件将会看起来类似下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-- 6 lines: setup folds -----</span><br><span class="line"></span><br><span class="line">+-- 6 lines: plugins ---------</span><br><span class="line"></span><br><span class="line">+-- 5 lines: configs ---------</span><br><span class="line"></span><br><span class="line">+-- 9 lines: functions -------</span><br><span class="line"></span><br><span class="line">+-- 5 lines: mappings --------</span><br></pre></td></tr></table></figure>

<h2 id="启动Vim时加载-不加载Vimrc和插件"><a href="#启动Vim时加载-不加载Vimrc和插件" class="headerlink" title="启动Vim时加载&#x2F;不加载Vimrc和插件"></a>启动Vim时加载&#x2F;不加载Vimrc和插件</h2><p>如果您要启动Vim时，既不加载Vimrc，也不加载插件，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -u NONE</span><br></pre></td></tr></table></figure>

<p>如果您要启动Vim时，不加载Vimrc，但加载插件，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -u NORC</span><br></pre></td></tr></table></figure>

<p>如果您要启动Vim时，加载Vimrc，但不加载插件，运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --noplugin</span><br></pre></td></tr></table></figure>

<p>如果您要Vim启动加载一个 <em>其他的</em> vimrc, 比如 <code>~/.vimrc-backup</code>, 运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -u ~/.vimrc-backup</span><br></pre></td></tr></table></figure>

<h2 id="聪明地配置Vimrc"><a href="#聪明地配置Vimrc" class="headerlink" title="聪明地配置Vimrc"></a>聪明地配置Vimrc</h2><p>Vimrc是定制Vim时的一个重要组件，学习构建您的Vimrc最好是首先阅读他人的vimrc文件，然后逐渐地建立自己的。最好的vimrc并不是谁谁谁使用的，而是最适合您的工作需要和编辑风格的。</p>
<h1 id="第23章-Vim软件包"><a href="#第23章-Vim软件包" class="headerlink" title="第23章 Vim软件包"></a>第23章 Vim软件包</h1><p>在前面的章节中，我提到使用第三方插件管理器来安装插件。从Vim 8开始，Vim自带了一个内置的插件管理器，名叫 <em>软件包（packages）</em>。在本章，您将学习如何使用Vim软件包来安装插件。</p>
<p>要看您的Vim编译版本是否能够使用软件包，运行 <code>:version</code>。然后查看是否有 <code>+packages</code>属性。另外，您也可以运行 <code>:echo has(&#39;packages&#39;)</code>（如果返回1，表示可以使用软件包）。</p>
<h2 id="包目录"><a href="#包目录" class="headerlink" title="包目录"></a>包目录</h2><p>在根目录下查看您是否有一个 <code>~/.vim</code> 文件夹。如果没有就新建一个。在文件夹里面，创建一个子文件夹取名 <code>pack</code>(<code>~/.vim/pack/</code>)。Vim会在这个子文件夹内自动搜索插件。</p>
<h2 id="两种加载方式"><a href="#两种加载方式" class="headerlink" title="两种加载方式"></a>两种加载方式</h2><p>Vim软件包有两种加载机制：自动加载和手动加载。</p>
<h3 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h3><p>要想让Vim启动时自动加载插件，你需要将它们放置在 <code>start/</code>子目录中。路径看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/start/</span><br></pre></td></tr></table></figure>

<p>现在您可能会问，为什么在<code>pack/</code> 和 <code>start/</code> 之间有一个 <code>*</code> ？这个星号可以是任意名字。让我们将它取为<code>packdemo/</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/packdemo/start/</span><br></pre></td></tr></table></figure>

<p>记住，如果您忽略这一点，用下面的路径代替的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/start/</span><br></pre></td></tr></table></figure>

<p>软件包系统是不会正常工作的。 必须在<code>pack/</code> 和 <code>start/</code>之间添加一个名字才能正常运行。</p>
<p>在这个示例中，让我们尝试安装 [NERDTree](<a target="_blank" rel="noopener" href="https://github.com/preservim/nThe">https://github.com/preservim/nThe</a> package system won’t work. It is imperative to put a name between <code>pack/</code> and <code>start/</code>.erdtree) 插件。用任意方法进入 <code>start/</code> 目录（<code>cd ~/.vim/pack/packdemo/start/</code>），然后将NERDTree的仓库克隆下来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/preservim/nerdtree.git</span><br></pre></td></tr></table></figure>

<p>完成了！您已经完成了安装。下一次您启动Vim，您可以立即执行 NERDTree 命令 <code>:NERDTreeToggle</code>。</p>
<p>在 <code>~/.vim/pack/*/start/</code> 目录中，您想克隆多少插件仓库就克隆多少。Vim将会自动加载每一个插件。如果您删除了克隆的仓库（<code>rm -rf nerdtree</code>），那么插件就失效了。</p>
<h3 id="手动加载"><a href="#手动加载" class="headerlink" title="手动加载"></a>手动加载</h3><p>要想在Vim启动时手动加载插件，您得将相关插件放置在 <code>opt/</code> 目录中，类似于自动加载，这个路径看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/opt/</span><br></pre></td></tr></table></figure>

<p>让我们继续使用前面的 <code>packdemo/</code> 这个名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/packdemo/opt/</span><br></pre></td></tr></table></figure>

<p>这一次，让我们安装<a target="_blank" rel="noopener" href="https://github.com/vim/killersheep">killersheep</a> 游戏（需要Vim8.2以上版本）。进入<code>opt/</code> 目录(<code>cd ~/.vim/pack/packdemo/opt/</code>) 然后克隆仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vim/killersheep.git</span><br></pre></td></tr></table></figure>

<p>启动Vim。执行游戏的命令是 <code>:KillKillKill</code>。试着运行一下。Vim将会提示这不是一个有效的编辑命令。您需要首先 <em>手动</em> 加载插件，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:packadd killersheep</span><br></pre></td></tr></table></figure>

<p>现在再运行一下 <code>:KillKillKill</code> 。命令已经可以使用了。</p>
<p>您可能好奇，“为什么我需要手动加载插件？启动时自动加载岂不是更好？”</p>
<p>很好的问题。有时候有些插件我们并不是所有的时候都在用，比如 KillerSheep 游戏。您可能不会想要加载10个不同的游戏导致Vim启动变慢。但是偶尔当您觉得乏味的时候，您可能想要玩几个游戏，使用手动加载一些非必须的插件。</p>
<p>您也可以使用这个方法有条件的加载插件。可能您同时使用了Neovim和Vim，有一些插件是为NeoVim优化过的。您可以添加类似下列的内容到您的vimrc中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if has(&#x27;nvim&#x27;)</span><br><span class="line">  packadd! neovim-only-plugin</span><br><span class="line">else</span><br><span class="line">  packadd! generic-vim-plugin</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h2 id="组织管理软件包"><a href="#组织管理软件包" class="headerlink" title="组织管理软件包"></a>组织管理软件包</h2><p>回想一下，要使用Vim的软件包系统必须有以下需求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/start/</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/*/opt/</span><br></pre></td></tr></table></figure>

<p>实际上，<code>*</code>星号可以使 <em>任意</em> 名字，这个名字就可以用来管理您的插件。假设您想将您的插件根据类型（颜色、语法、游戏）分组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/colors/</span><br><span class="line">~/.vim/pack/syntax/</span><br><span class="line">~/.vim/pack/games/</span><br></pre></td></tr></table></figure>

<p>您仍然可以使用各个目录下的 <code>start/</code> 和 <code>opt/</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~/.vim/pack/colors/start/</span><br><span class="line">~/.vim/pack/colors/opt/</span><br><span class="line"></span><br><span class="line">~/.vim/pack/syntax/start/</span><br><span class="line">~/.vim/pack/syntax/opt/</span><br><span class="line"></span><br><span class="line">~/.vim/pack/games/start/</span><br><span class="line">~/.vim/pack/games/opt/</span><br></pre></td></tr></table></figure>

<h2 id="聪明地添加插件"><a href="#聪明地添加插件" class="headerlink" title="聪明地添加插件"></a>聪明地添加插件</h2><p>您可能好奇，Vim软件包是否让一些流行的插件管理器，比如 vim-pathogen, vundle.vim, dein.vim, a还有vim-plug面临淘汰？</p>
<p>答案永远是：“看情况而定。”</p>
<p>我仍然使用vim-plug，因为使用它添加、删除、更新插件很容易。如果您使用了很多插件，插件管理器的好处更加明显，因为使用它可以对很多插件进行同时更新。有些插件管理器同时也提供了一些异步功能。</p>
<p>如果您是极简主义者，可以尝试一下Vim软件包。如果您是一名插件重度使用者，您可能需要一个插件管理器。</p>
<h1 id="第24章-Vim-Runtime"><a href="#第24章-Vim-Runtime" class="headerlink" title="第24章 Vim Runtime"></a>第24章 Vim Runtime</h1><p>在前面的章节中，我提到Vim会自动查找一些特殊的路径，比如在<code>~/.vim/</code> 中的 <code>pack/</code>(第23章) <code>compiler/</code>（第19章）。这些都是Vim runtime路径的例子。</p>
<p>除了上面提到的两个，Vim还有更多runtime路径。在本章，您将学习关于Vim runtime路径的高层次概述。本章的目标是向您展示它们什么时候被调用。知道这些知识能够帮您更进一步理解和定制Vim。</p>
<h2 id="Runtime路径"><a href="#Runtime路径" class="headerlink" title="Runtime路径"></a>Runtime路径</h2><p>在一台Unix机器中，其中一个vim runtime路径就是 <code>$HOME/.vim/</code> （如果您用的是其他操作系统，比如Windows，您的路径可能有所不同）。要查看不同的操作系统有什么样的runtime路径，查阅 <code>:h runtimepath</code>。在本章，我将使用 <code>~/.vim/</code> 作为默认的runtime路径。</p>
<h2 id="Plugin脚本"><a href="#Plugin脚本" class="headerlink" title="Plugin脚本"></a>Plugin脚本</h2><p>Vim有一个runtime路径 plugin，每次Vim启动时都会执行这个路径中的所有脚本。不要把这个名字 “plugin” 和Vim的外部插件（external plugins，比如NERDTree, fzf.vim, 等)搞混了。</p>
<p>进入 <code>~/.vim/</code> 目录，然后创建 <code>plugin/</code> 子目录。 创建两个文件： <code>donut.vim</code> 和 <code>chocolate.vim</code>。</p>
<p>在 <code>~/.vim/plugin/donut.vim</code>里面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;donut!&quot;</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.vim/plugin/chocolate.vim</code>里面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;chocolate!&quot;</span><br></pre></td></tr></table></figure>

<p>现在关闭Vim。下次您启动Vim，您将会看到 <code>&quot;donut!&quot;</code> 和 <code>:chocolate!</code> 的显示。此 plugin runtime路径可以用来执行一些初始化脚本。</p>
<h2 id="文件类型检测"><a href="#文件类型检测" class="headerlink" title="文件类型检测"></a>文件类型检测</h2><p>在开始之前，为保证检测能正常运行，确保在您的vimrc中至少包含了下列的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure>

<p>查阅 <code>:h filetype-overview</code> 了解更多信息。本质上，这条代码开启Vim的文件类型检测。</p>
<p>当您打开一个新的文件，Vim通常知道这个文件是什么类型。如果您有一个文件 <code>hello.rb</code>，运行 <code>:set filetype?</code> 会返回正确的相应 <code>filetype=ruby</code>。</p>
<p>Vim知道如何检测 “常见” 的文件类型（Ruby, Python, Javascript, 等）。但如果是一个自定义文件会怎样呢？您需要告诉Vim去检测它，并给它指派一个正确的文件类型。</p>
<p>有两种检测方法：使用文件名和使用文件内容</p>
<h3 id="文件名检测"><a href="#文件名检测" class="headerlink" title="文件名检测"></a>文件名检测</h3><p>文件名检测使用一个文件的文件名来检测文件类型。当您打开 <code>hello.rb</code>文件时，Vim依靠扩展名 <code>.rb</code> 知道它是一个Ruby文件。</p>
<p>有两种方法实现文件名检测：一是使用 <code>ftdetect</code> runtime目录，二是使用 <code>filetype.vim</code> runtime文件。我们两个都看一看。</p>
<h4 id="ftdetect"><a href="#ftdetect" class="headerlink" title="ftdetect/"></a><code>ftdetect/</code></h4><p>让我们创建一个古怪（但优雅）的名字，<code>hello.chocodonut</code>。当您打开它后运行 <code>:set filetype?</code> ，因为它的后缀名不是常见的文件名，Vim不知道它是什么类型，会返回 <code>filetype=</code>。</p>
<p>您需要指示Vim将所有以 <code>.chocodonut</code>结尾的文件设置为 “chocodonut”类型的文件。在runtime路径根目录(<code>~/.vim/</code>)创建一个子目录，名为 <code>ftdetect/</code> 。在子目录里面，再创建一个名叫 <code>chocodonut.vim</code> 的文件（<code>~/.vim/ftdetect/chocodonut.vim</code>），在文件里面，添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile,BufRead *.chocodonut set filetype=chocodonut</span><br></pre></td></tr></table></figure>

<p>当您创建新buffer或打开新buffer时，事件<code>BufNewFile</code> 和 <code>BufRead</code> 就会被触发。 <code>*.chocodonut</code> 意思是只有当新打开的buffer文件名后缀是 <code>.chocodonut</code> 时事件才会被触发。最后，<code>set filetype=chocodonut</code> 命令将文件类型设置为chocodonut类型。</p>
<p>重启Vim。新建一个 <code>hello.chocodonut</code> 文件然后运行 <code>:set filetype?</code>。它将返回 <code>filetype=chocodonut</code>.</p>
<p>好极了！只要您想，您可以将任意多的文件放置在 <code>ftdetect/</code> 中。以后，如果您想扩展您的 donut 文件类型，你可以添加 <code>ftdetect/strawberrydonut.vim</code>, <code>ftdetect/plaindonut.vim</code> 等等。</p>
<p>在Vim中，实际上有两种方法设置文件类型。其中给一个是您刚刚使用的 <code>set filetype=chocodonut</code>。另一种方法是运行 <code>setfiletype chocodonut</code>。前一个命令 <code>set filetype=chocodonut</code> 将 <em>总是</em> 设置文件类型为chocodonut。 而后者<code>setfiletype chocodonut</code>只有当文件类型尚未设置时，才会将文件类型设置为chocodonut。</p>
<h4 id="文件类型文件"><a href="#文件类型文件" class="headerlink" title="文件类型文件"></a>文件类型文件</h4><p>第二种文件类型检测需要你创建一个名为 <code>filetype.vim</code>的文件，并将它放置在根目录(<code>~/.vim/filetype.vim</code>)。在文件内添加一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufNewFile,BufRead *.plaindonut set filetype=plaindonut</span><br></pre></td></tr></table></figure>

<p>创建一个名为 <code>hello.plaindonut</code> 的文件。当你打开它后运行 <code>:set filetype?</code> Vim会显示正确的自定义文件类型 <code>filetype=plaindonut</code>。</p>
<p>太好了，修改生效了。另外，如果您仔细看看 <code>filetype.vim</code> ，您会发现当您打开<code>hello.plaindonut</code>时，这个文件文件运行了多次。为防止这一点，您可以添加一个守卫，让主脚本只运行一次。更新 <code>filetype.vim</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if exists(&quot;did_load_filetypes&quot;)</span><br><span class="line">  finish</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">augroup donutfiletypedetection</span><br><span class="line">  autocmd! BufRead,BufNewFile *.plaindonut setfiletype plaindonut</span><br><span class="line">augroup END</span><br></pre></td></tr></table></figure>

<p><code>finish</code> 是一个Vim命令，用来停止执行剩余的脚本。表达式<code>&quot;did_load_filetypes&quot;</code> 并 <em>不是</em> 一个Vim内置函数。它实际上是<code>$VIMRUNTIME/filetype.vim</code> 中的一个全局变量。如果您好奇，运行<code>:e $VIMRUNTIME/filetype.vim</code>。您将会发现以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if exists(&quot;did_load_filetypes&quot;)</span><br><span class="line">  finish</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">let did_load_filetypes = 1</span><br></pre></td></tr></table></figure>

<p>当Vim调用这个文件时，它会定义 <code>did_load_filetypes</code> 变量，并将它设置为 1 。在Vim中，1 表示真。你可以试着读完 <code>filetype.vim</code> 剩余的内容，看看您是否能够理解当Vim调用它时干了什么。</p>
<h3 id="文件类型脚本"><a href="#文件类型脚本" class="headerlink" title="文件类型脚本"></a>文件类型脚本</h3><p>让我们学习如何基于文件内容检测文件类型。</p>
<p>假设您有一个无扩展名的文件的集合。这些文件唯一相同的地方是，第一行都是以 “donutify” 开头。您现在想给这些文件指派一个 <code>donut</code> 的文件类型。创建新文件，起名为 <code>sugardonut</code>, <code>glazeddonut</code>, 还有 <code>frieddonut</code>（没有扩展名）。在每个文件中，添加下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donutify</span><br></pre></td></tr></table></figure>

<p>当您在<code>sugardonut</code>中运行 <code>:set filetype?</code>，Vim无法知道应该给这个文件指派什么文件类型，会返回 <code>filetype=</code>。</p>
<p>在runtime根目录，添加一个 <code>scripts.vim</code> 文件(<code>~/.vim/scripts.vim</code>)，在文件中，添加一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if did_filetype()</span><br><span class="line">  finish</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">if getline(1) =~ &#x27;^\\&lt;donutify\\&gt;&#x27;</span><br><span class="line">  setfiletype donut</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>函数 <code>getline(1)</code> 返回文件第一行的内容。它检查第一行是否以 “donutify” 开头。函数 <code>did_filetype()</code> 是Vim的内置函数，当一个与文件类型相关的事件发生至少一次时，它返回真。它用来做守卫，防止文件类型事件反复运行。</p>
<p>打开文件 <code>sugardonut</code> 然后运行 <code>:set filetype?</code>，Vim现在返回 <code>filetype=donut</code>。如果您打开另外一个donut文件 (<code>glazeddonut</code> 和 <code>frieddonut</code>)，Vim同样会将它们的文件类型定义为 <code>donut</code> 类型。</p>
<p>注意，<code>scripts.vim</code> 仅当Vim打开一个未知文件类型的文件时才会运行。如果Vim打开一个已知文件类型的文件，<code>scripts.vim</code> 将不会运行。</p>
<h2 id="文件类型插件"><a href="#文件类型插件" class="headerlink" title="文件类型插件"></a>文件类型插件</h2><p>如果您想让Vim仅当您打开一个 chocodonut 文件时才运行 chocodonut 相关的特殊脚本，而当您打开的是 plaindonut 文件时，Vim就不运行这些脚本。能否做到呢？</p>
<p>您可以使用文件类型插件runtime路径(<code>~/.vim/ftplugin/</code>)来完成这个功能。Vim会在这个目录中查找一个文件，这个文件的文件名与您打开的文件类型一样。创建一个文件，起名为<code>chocodonut.vim</code> (<code>~/.vim/ftplugin/chocodonut.vim</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Calling from chocodonut ftplugin&quot;</span><br></pre></td></tr></table></figure>

<p>创建另一个 ftplugin 文件，起名为<code>plaindonut.vim</code> (<code>~/.vim/ftplugin/plaindonut.vim</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Calling from plaindonut ftplugin&quot;</span><br></pre></td></tr></table></figure>

<p>现在，每次您打开一个 chocodonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/chocodonut.vim</code>中的脚本。每次您打开 plaindonut 类型的文件时，Vim会运行 <code>~/.vim/ftplugin/plaindonut.vim</code> 中的脚本。</p>
<p>一个警告：每当一个buffer的文件类型被设置时(比如，<code>set filetype=chocodonut</code>)，上述脚本就会运行一次。如果您打开3个不同的 chocodonut 文件，该脚本将运行 <em>总共</em> 3次。</p>
<h2 id="缩进文件"><a href="#缩进文件" class="headerlink" title="缩进文件"></a>缩进文件</h2><p>Vim有一个 缩进runtime路径，其工作方式与ftplugin类似，Vim也会在这个目录中查找一个与打开的文件类型名字一样的文件。缩进runtime路径的目的是存储缩进相关的代码。如果您有文件 <code>~/.vim/indent/chocodonut.vim</code>，它仅当您打开一个 chocodonut 类型的文件时执行。您可以将 chocodonut 文件中缩进相关的代码存储在这里。</p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>Vim 有一个颜色runtime路径 (<code>~/.vim/colors/</code>) ，用来存储颜色主题。这个目录中的任何文件都会在命令行命令 <code>:color</code> 中显示出来。</p>
<p>如果您有一个文件 <code>~/.vim/colors/beautifulprettycolors.vim</code>，当您运行 <code>:color</code> 然后按 Tab，您将会看到 <code>beautifulprettycolors</code> 出现在颜色选项中。  如果您想添加自己的颜色主题，就放在这个地方。</p>
<p>如果您想看其他人做的颜色主题，有一个好地方值得推荐：<a target="_blank" rel="noopener" href="https://vimcolors.com/">vimcolors</a>。</p>
<h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>Vim有一个语法runtime路径 (<code>~/.vim/syntax/</code>)，用来定义语法高亮。</p>
<p>假设您有一个文件 <code>hello.chocodonut</code>，在文件里面有以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(donut &quot;tasty&quot;)</span><br><span class="line">(donut &quot;savory&quot;)</span><br></pre></td></tr></table></figure>

<p>虽然Vim现在知道了正确的文件类型，但所有的文本都是相同的颜色。让我们添加语法高亮规则，使 “donut” 关键词高亮显示。创建一个新的 chocodonut 语法文件 <code>~/.vim/syntax/chocodonut.vim</code>，在文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax keyword donutKeyword donut</span><br><span class="line"></span><br><span class="line">highlight link donutKeyword Keyword</span><br></pre></td></tr></table></figure>

<p>现在重新打开 <code>hello.chocodonut</code> 文件，关键词 <code>donut</code> 已经高亮显示了。</p>
<p>本章不会详细介绍语法高亮。它是一个庞大的主题。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/sheerun/vim-polyglot">vim-polyglot</a> 插件非常的棒，它提供了很多流行的编程语言的语法高亮。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>如果您写了一个插件，您还得创建一个您自己的文档。您可以使用文档runtime路径完成这个。</p>
<p>让我们为 chocodonut 和 plaindonut 关键字创建一个基本文档。创建文件 <code>donut.txt</code> (<code>~/.vim/doc/donut.txt</code>)。在文件中，添加一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*chocodonut* Delicious chocolate donut</span><br><span class="line"></span><br><span class="line">*plaindonut* No choco goodness but still delicious nonetheless</span><br></pre></td></tr></table></figure>

<p>如果您试着搜索 <code>chocodonut</code> 或 <code>plaindonut</code> (<code>:h chocodonut</code> 或 <code>:h plaindonut</code>)，您找不到任何东西。</p>
<p>首先，你需要运行 <code>:helptags</code>来创建新的帮助入口。运行 <code>:helptags ~/.vim/doc/</code></p>
<p>现在，如果您运行 <code>:h chocodonut</code> 或 <code>:h plaindonut</code>，您将找到上面那些新的帮助入口。注意，现在文件是只读的，而且类型是 “help”。</p>
<h2 id="延时加载脚本"><a href="#延时加载脚本" class="headerlink" title="延时加载脚本"></a>延时加载脚本</h2><p>到现在，本章您学到的所有runtime路径都是自动运行的。如果您想手动加载一个脚本，可使用 autoload runtime路径。</p>
<p>创建一个目录名为 autoload(<code>~/.vim/autoload/</code>)。在目录中，创建一个新文件，起名为 <code>tasty.vim</code> (<code>~/.vim/autoload/tasty.vim</code>)。在文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;tasty.vim global&quot;</span><br><span class="line"></span><br><span class="line">function tasty#donut()</span><br><span class="line">  echo &quot;tasty#donut&quot;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<p>注意，函数名是 <code>tasty#donut</code> 而不是 <code>donut()</code>。要想使用autoload功能，井号(<code>#</code>)是必须的。在使用autoload功能时，函数的命名惯例是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fileName#functionName()</span><br><span class="line">  ...</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<p>在本例中，文件名是 <code>tasty.vim</code>，而函数名是<code>donut</code>。</p>
<p>要调用一个函数，可以使用 <code>call</code> 命令。让我们call这个函数 <code>:call tasty#donut()</code>。</p>
<p>您第一次调用这个函数时，您应当会 <em>同时</em> 看到两条信息 (“tasty.vim global” 和 “tasty#donut”) 。后面再调用 <code>tasty#donut</code> 函数，将只会显示 “testy#donut”。</p>
<p>当您在Vim中打开一个文件，不像前面说的runtime路径，autoload脚本不会被自动加载。仅当您显式地调用 <code>tasty#donut()</code>，Vim才会查找文件<code>tasty.vim</code>，然后加载文件中的内容，包括函数 <code>tasty#donut()</code>。有些函数会占用大量资源，但我们又不常用，这时候 Autoload runtime路径就是最佳的解决方案。 </p>
<p>您可以在autoload目录任意添加嵌套的目录。如果您有一个runtime路径 <code>~/.vim/autoload/one/two/three/tasty.vim</code>，您可以使用<code>:call one#two#three#tasty#donut()</code>来调用函数。</p>
<h2 id="After脚本"><a href="#After脚本" class="headerlink" title="After脚本"></a>After脚本</h2><p>Vim有一个 after runtime路径 (<code>~/.vim/after/</code>) ，它的结构是 <code>~/.vim/</code>的镜像。在此目录中的任何脚本都会最后执行，所以开发者通常使用这个路径来重载脚本。</p>
<p>比如，如果您想重载 <code>plugin/chocolate.vim</code> 中的脚本，您可以创建<code>~/.vim/after/plugin/chocolate.vim</code>来放置重载脚本。Vim将会先运行 <code>~/.vim/plugin/chocolate.vim</code>， <em>然后运行</em> <code>~/.vim/after/plugin/chocolate.vim</code></p>
<h2 id="VIMRUNTIME"><a href="#VIMRUNTIME" class="headerlink" title="$VIMRUNTIME"></a>$VIMRUNTIME</h2><p>Vim有一个环境变量 <code>$VIMRUNTIME</code> 用来加载默认脚本和支持文件。您可以运行 <code>:e $VIMRUNTIME</code>查看。</p>
<p>它的结构应该看起来很熟悉。它包含的很多runtime路径都是我们本章前面学过的。</p>
<p>回想第22章，当您打开Vim时，它会在6个不同的位置查找vimrc文件。当时我说最后一个位置就是 <code>$VIMRUNTIME/default.vim</code>，如果Vim在前5个位置查找用户vimrc文件失败，就会使用<code>default.vim</code> 作为vimrc。</p>
<p>不知您是否尝试过，运行Vim是不加载比如vim-polyglot之类的语法插件，但您的文件依然有语法高亮?这是因为当Vim在runtime路径查找语法文件失败时，会从<code>$VIMRUNTIME</code> 的语法目录中查找语法文件。</p>
<p>查阅 <code>:h $VIMRUNTIME</code>了解更多信息。</p>
<h2 id="Runtimepath选项"><a href="#Runtimepath选项" class="headerlink" title="Runtimepath选项"></a>Runtimepath选项</h2><p>运行 <code>:set runtimepath?</code>，可以查看您的runtime路径。</p>
<p>如果您使用 Vim-Plug 或其他流行的第三方插件管理器，它应该会显示一个目录列表。比如，我的显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimepath=~/.vim,~/.vim/plugged/vim-signify,~/.vim/plugged/base16-vim,~/.vim/plugged/fzf.vim,~/.vim/plugged/fzf,~/.vim/plugged/vim-gutentags,~/.vim/plugged/tcomment_vim,~/.vim/plugged/emmet-vim,~/.vim/plugged/vim-fugitive,~/.vim/plugged/vim-sensible,~/.vim/plugged/lightline.vim, ...</span><br></pre></td></tr></table></figure>

<p>插件管理器做了一件事，就是将每个插件添加到runtime路径中。每个runtime路径都有一个类似 <code>~/.vim/</code>的目录结构。</p>
<p>如果您有一个目录 <code>~/box/of/donuts/</code>，然后您想将这个目录添加到您的runtime路径中，您可以在vimrc中添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rtp+=$HOME/box/of/donuts/</span><br></pre></td></tr></table></figure>

<p>如果在 <code>~/box/of/donuts/</code> 里面，您有一个plugin目录 (<code>~/box/of/donuts/plugin/hello.vim</code>) 以及ftplugin目录 (<code>~/box/of/donuts/ftplugin/chocodonut.vim</code>)，当您打开Vim时，Vim将会运行 <code>plugin/hello.vim</code> 中所有脚本。同样，当您打开一个 chocodonut 文件时，Vim 将会运行 <code>ftplugin/chocodonut.vim</code>。</p>
<p>自己试着做一下：创建一个任意目录，然后将它添加到您的 runtimepath中。添加一些我们本章学到的runtime路径。确保它们按预期工作。</p>
<h2 id="聪明地学习Runtime"><a href="#聪明地学习Runtime" class="headerlink" title="聪明地学习Runtime"></a>聪明地学习Runtime</h2><p>花点时间阅读本章，还有认真研究一下这些runtime路径。看一下真实环境下runtime路径是如何使用的。浏览一下您最喜欢的Vim插件仓库，仔细研究一下它的目录结构，您应该能够理解它们中的绝大部分。试着领会重点并跟着做。现在您已经理解了Vim的目录结构，您可以准备学习Vimscript了。</p>
<h1 id="第25章-Vimscript-基础和数据类型"><a href="#第25章-Vimscript-基础和数据类型" class="headerlink" title="第25章 Vimscript 基础和数据类型"></a>第25章 Vimscript 基础和数据类型</h1><h2 id="Ex-模式"><a href="#Ex-模式" class="headerlink" title="Ex 模式"></a>Ex 模式</h2><p>技术上来说，Vim 没有内置的交互式解释器 (REPL)，但是有一个 Ex 模式，可以使 vim 像使用 REPL 一样、Ex 模式更现实命令行模式的拓展，即非停止的命令行模式</p>
<p>进入EX模式的方法：</p>
<ul>
<li><code>Q</code></li>
<li><code>gQ</code></li>
</ul>
<p>退出Ex模式</p>
<ul>
<li>输入: <code>:visual</code></li>
</ul>
<h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>类似于 <code>python</code> 的 <code>print()</code></p>
<p><code>echom</code>: 和 echo 相同， 不同支出在于 <code>echom</code> 会将结果保存到 message 历史记录中</p>
<ul>
<li><p>查看 message 历史记录</p>
<p> <code>:messages</code></p>
</li>
<li><p>清空 mwssage 历史记录</p>
<p> <code>:message clear</code></p>
</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>模式指的是&#x3D;&#x3D;十进制&#x3D;&#x3D;数字</p>
<h3 id="十进制-Decimal"><a href="#十进制-Decimal" class="headerlink" title="十进制 Decimal"></a>十进制 Decimal</h3><p>1, -1, -10</p>
<h3 id="十六进制-Hexadecimal"><a href="#十六进制-Hexadecimal" class="headerlink" title="十六进制 Hexadecimal"></a>十六进制 Hexadecimal</h3><p>以 <code>0x</code> 或 <code>oX</code> 开头</p>
<h3 id="二进制-Binary"><a href="#二进制-Binary" class="headerlink" title="二进制 Binary"></a>二进制 Binary</h3><p>以 <code>0b</code> 或 <code>0B</code> 开头</p>
<h3 id="八进制-Octal"><a href="#八进制-Octal" class="headerlink" title="八进制 Octal"></a>八进制 Octal</h3><p>以 <code>0</code>, <code>0o</code> 或 <code>0O</code> 开头</p>
<h3 id="真假值"><a href="#真假值" class="headerlink" title="真假值"></a>真假值</h3><ul>
<li>真：非0</li>
<li>假：0</li>
</ul>
<h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><p>同 C++ 的数值运算</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>使用 双引号(<code>&quot;&quot;</code>) 或 单引号(<code>&#39;&#39;</code>) 包裹起来</p>
<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>使用 <code>.</code> 连接字符串</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">echo</span> <span class="string">&quot;Hello&quot;</span> . <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串算数"><a href="#字符串算数" class="headerlink" title="字符串算数"></a>字符串算数</h3><p>当使用数字和字符串使用运算符 <code>+ - * /</code> 进行算数运算时，vim会将字符串转化为数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:echo &quot;12 donuts&quot; + 3</span><br></pre></td></tr></table></figure>

<p>也可以是字符串与字符串进行数值计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:echo &quot;12 donuts&quot; * &quot;6 pastries&quot;</span><br></pre></td></tr></table></figure>

<p><strong>要求</strong>：</p>
<ul>
<li>数字字符必须是字符串的第一个字符</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>当使用浮点型进行运算时，将被转化成整数</li>
</ul>
<h3 id="数字与字符串连接"><a href="#数字与字符串连接" class="headerlink" title="数字与字符串连接"></a>数字与字符串连接</h3><p>使用 <code>.</code> 运算符</p>
<p><strong>注意</strong></p>
<ul>
<li>不适用于浮点数</li>
</ul>
<h3 id="字符串作为条件时"><a href="#字符串作为条件时" class="headerlink" title="字符串作为条件时"></a>字符串作为条件时</h3><ul>
<li>真：第一个字符为数字</li>
<li>假：第一个字符不为数字</li>
</ul>
<h3 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h3><ul>
<li>单引号只会输出字面值</li>
<li>双引号可以接受特殊字符，如: <code>\n, \&quot;</code></li>
</ul>
<h3 id="内置字符串程序"><a href="#内置字符串程序" class="headerlink" title="内置字符串程序"></a>内置字符串程序</h3><table>
<thead>
<tr>
<th>程序</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen()</code></td>
<td>获取字符串长度</td>
</tr>
<tr>
<td><code>str2nr()</code></td>
<td>将字符串转化为数字</td>
</tr>
<tr>
<td><code>str2float()</code></td>
<td>将字符串转化为浮点数</td>
</tr>
<tr>
<td><code>substitute()</code></td>
<td>字符串模式替换<br/>可以结合 <code>getline()</code> 使用</td>
</tr>
<tr>
<td>其他函数</td>
<td><code>:h string-functions</code></td>
</tr>
</tbody></table>
<p><code>getline()</code>: 获取传入行号的文本</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>类似于 Python 的列表，类型可以混合在一起</p>
<h3 id="子列表"><a href="#子列表" class="headerlink" title="子列表"></a>子列表</h3><p><strong>获取单个值</strong></p>
<p>同 Python 的索引，类似于<code>list[n]</code></p>
<p><strong>切片</strong></p>
<ul>
<li><code>list[n:m]</code> 获取 <code>list</code> 列表中的索引号 n 到 m 的元素 （包括m）</li>
<li><code>list[n:]</code>: n到末尾</li>
<li><code>list[:m]</code>: 从头到m</li>
</ul>
<p>注: 若 <code>m</code> &gt; <code>list</code> 的长度，那么就是获取 m 到末尾的元素</p>
<h3 id="切片字符串"><a href="#切片字符串" class="headerlink" title="切片字符串"></a>切片字符串</h3><p>同list</p>
<h3 id="数值运算-1"><a href="#数值运算-1" class="headerlink" title="数值运算"></a>数值运算</h3><p>使用 <code>+</code>: 连接两个劫镖</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>len()</code></td>
<td>获得列表长度</td>
</tr>
<tr>
<td><code>insert()</code></td>
<td>将元素传输到列表开始位置</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>删除列表元素</td>
</tr>
<tr>
<td><code>map()</code><br/><code>filter()</code></td>
<td>用来过滤元素 &#x3D;&#x3D;？？？？&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:let sweeterList = [&quot;glazed&quot;, &quot;chocolate&quot;, &quot;strawberry&quot;]</span><br><span class="line">:call filter(sweeterList, &#x27;v:val !~ &quot;choco&quot;&#x27;)</span><br><span class="line">:echo sweeterList</span><br><span class="line">&quot; returns [&quot;glazed&quot;, &quot;strawberry&quot;]</span><br><span class="line"></span><br><span class="line">:let sweetestList = [&quot;chocolate&quot;, &quot;glazed&quot;, &quot;sugar&quot;]</span><br><span class="line">:call map(sweetestList, &#x27;v:val . &quot; donut&quot;&#x27;)</span><br><span class="line">:echo sweetestList</span><br><span class="line">&quot; returns [&#x27;chocolate donut&#x27;, &#x27;glazed donut&#x27;, &#x27;sugar donut&#x27;]</span><br></pre></td></tr></table></figure>



<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>像python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:let favoriteFlavor = [&quot;chocolate&quot;, &quot;glazed&quot;, &quot;plain&quot;]</span><br><span class="line">:let [flavor1, flavor2, flavor3] = favoriteFlavor</span><br><span class="line"></span><br><span class="line">:echo flavor1</span><br><span class="line">&quot; returns &quot;chocolate&quot;</span><br><span class="line"></span><br><span class="line">:echo flavor2</span><br><span class="line">&quot; returns &quot;glazed&quot;</span><br></pre></td></tr></table></figure>

<p>使用 <code>;</code> 分配剩余的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:let favoriteFruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;lemon&quot;, &quot;blueberry&quot;, &quot;raspberry&quot;]</span><br><span class="line">:let [fruit1, fruit2; restFruits] = favoriteFruits</span><br><span class="line"></span><br><span class="line">:echo fruit1</span><br><span class="line">&quot; returns &quot;apple&quot;</span><br><span class="line"></span><br><span class="line">:echo restFruits</span><br><span class="line">&quot; returns [&#x27;lemon&#x27;, &#x27;blueberry&#x27;, &#x27;raspberry&#x27;]</span><br></pre></td></tr></table></figure>



<h3 id="修改列表"><a href="#修改列表" class="headerlink" title="修改列表"></a>修改列表</h3><p><strong>修改一项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:let favoriteFlavor = [&quot;chocolate&quot;, &quot;glazed&quot;, &quot;plain&quot;]</span><br><span class="line">:let favoriteFlavor[0] = &quot;sugar&quot;</span><br><span class="line">:echo favoriteFlavor</span><br><span class="line">&quot; returns [&#x27;sugar&#x27;, &#x27;glazed&#x27;, &#x27;plain&#x27;]</span><br></pre></td></tr></table></figure>



<p><strong>修改多项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:let favoriteFlavor = [&quot;chocolate&quot;, &quot;glazed&quot;, &quot;plain&quot;]</span><br><span class="line">:let favoriteFlavor[2:] = [&quot;strawberry&quot;, &quot;chocolate&quot;]</span><br><span class="line">:echo favoriteFlavor</span><br><span class="line">&quot; returns [&#x27;chocolate&#x27;, &#x27;glazed&#x27;, &#x27;strawberry&#x27;, &#x27;chocolate&#x27;]</span><br></pre></td></tr></table></figure>



<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>类似于 python</p>
<p>&#x3D;&#x3D;区别&#x3D;&#x3D;在于 vim 只使用字符串为“键”，即使使用数字，也会将数字转化为字符串</p>
<h3 id="偷懒方法"><a href="#偷懒方法" class="headerlink" title="偷懒方法"></a>偷懒方法</h3><p>使用 <code>#&#123;&#125;</code> 来表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:let mealPlans = #&#123;breakfast: &quot;waffles&quot;, lunch: &quot;pancakes&quot;, dinner: &quot;donuts&quot;&#125;</span><br><span class="line"></span><br><span class="line">:echo mealPlans</span><br><span class="line">&quot; returns &#123;&#x27;lunch&#x27;: &#x27;pancakes&#x27;, &#x27;breakfast&#x27;: &#x27;waffles&#x27;, &#x27;dinner&#x27;: &#x27;donuts&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要求</strong></p>
<p>“键”的字符必须满足一下条件：</p>
<ul>
<li>ASCII character.</li>
<li>Digit.</li>
<li>An underscore (<code>_</code>).</li>
<li>A hyphen (<code>-</code>).</li>
</ul>
<h3 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h3><ul>
<li><p><code>[]</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meal[&#x27;breakfast&#x27;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meal.lunch</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><ul>
<li><p>[]&#96;</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meal[&#x27;breakfast&#x27;] = &quot;...&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meal.lunch = &quot;...&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>len()</code></td>
<td>获取字典长度</td>
</tr>
<tr>
<td><code>has_key()</code></td>
<td>获取字典的键</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>字典是否有键值对</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>移除键值对</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>将键值对转化为列表：每个键值对为一个列表</td>
</tr>
<tr>
<td><code>filter()</code> and <code>map()</code></td>
<td>过滤作用</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="特殊基元"><a href="#特殊基元" class="headerlink" title="特殊基元"></a>特殊基元</h2><ul>
<li><code>v:false</code></li>
<li><code>v:true</code></li>
<li><code>v:none</code></li>
<li><code>v:null</code></li>
</ul>
<blockquote>
<p>注：</p>
<ul>
<li><code>v:</code> 是 vim 内置的变量</li>
<li>这些不常用</li>
<li>常用如下<ul>
<li>布尔值：0(假)；non-0 (真)</li>
<li>空字符串：<code>&quot;&quot;</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="True"><a href="#True" class="headerlink" title="True"></a>True</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:echo json_encode(&#123;&quot;test&quot;: v:true&#125;)</span><br><span class="line">&quot; returns &#123;&quot;test&quot;: true&#125;</span><br></pre></td></tr></table></figure>



<h3 id="False"><a href="#False" class="headerlink" title="False"></a>False</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:echo json_encode(&#123;&quot;test&quot;: v:false&#125;)</span><br><span class="line">&quot; returns &#123;&quot;test&quot;: false&#125;</span><br></pre></td></tr></table></figure>



<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:echo json_encode(&#123;&quot;test&quot;: v:none&#125;)</span><br><span class="line">&quot; returns &#123;&quot;test&quot;: null&#125;</span><br></pre></td></tr></table></figure>

<p>被解释成 <code>null</code></p>
<h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:echo json_encode(&#123;&quot;test&quot;: v:null&#125;)</span><br><span class="line">&quot; returns &#123;&quot;test&quot;: null&#125;</span><br></pre></td></tr></table></figure>

<p>类似于 <code>v:none</code></p>
<h1 id="第26章-条件和循环"><a href="#第26章-条件和循环" class="headerlink" title="第26章 条件和循环"></a>第26章 条件和循环</h1><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><ul>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
</ul>
<blockquote>
<p>注意：这里的字符串仍被转换为数字</p>
</blockquote>
<h3 id="字符串逻辑运算"><a href="#字符串逻辑运算" class="headerlink" title="字符串逻辑运算"></a>字符串逻辑运算</h3><p>用关系运算符来比较字符串</p>
<ul>
<li><code>=~</code>：对字符串进行正则表达式匹配：可以模式匹配上</li>
<li><code>!~</code>: 对字符串进行正则表达式匹配：不可以匹配上</li>
<li><code>==</code>: 完全匹配：相等</li>
<li><code>!=</code>：完全匹配：不相等</li>
</ul>
<blockquote>
<p>注意：如果在设置了 <code>set ignorecase</code>，那么比较时也会忽略大小写</p>
</blockquote>
<p><strong>设置总是忽略大小写</strong></p>
<ul>
<li><p>在末尾加一个 <code>#</code>，如：<code>=~#</code> （推荐：安全）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo str =~# &quot;hearty&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在末尾加一个 <code>?</code>，如：<code>=~?</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo str =~? &quot;hearty&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="最小的-if-语句"><a href="#最小的-if-语句" class="headerlink" title="最小的 if 语句"></a>最小的 if 语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if &#123;clasuse&#125;</span><br><span class="line">	&#123;some expression&#125;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>



<h3 id="if-全貌"><a href="#if-全貌" class="headerlink" title="if 全貌"></a>if 全貌</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if &#123;predicate1&#125;</span><br><span class="line">	&#123;expression1&#125;</span><br><span class="line">elseif &#123;predicate2&#125;</span><br><span class="line">	&#123;expression2&#125;</span><br><span class="line">elseif &#123;predicate3&#125;</span><br><span class="line">	&#123;expression3&#125;</span><br><span class="line">else</span><br><span class="line">	&#123;expression4&#125;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>



<h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;predicate&#125; ? expressiontrue : expressionfalse</span><br></pre></td></tr></table></figure>



<p><strong>补充</strong></p>
<ul>
<li><code>background</code>: 背景</li>
<li><code>strftime()</code>： 目前时间</li>
</ul>
<h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><p><code>||</code></p>
<blockquote>
<p>注意：短路运算</p>
</blockquote>
<h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p><code>&amp;&amp;</code></p>
<blockquote>
<p>注意：短路运算</p>
</blockquote>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let breakfasts = [&quot;pancakes&quot;, &quot;waffles&quot;, &quot;eggs&quot;]</span><br><span class="line"></span><br><span class="line">for breakfast in breakfasts</span><br><span class="line">  echo breakfast</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure>



<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let meals = [[&quot;breakfast&quot;, &quot;pancakes&quot;], [&quot;lunch&quot;, &quot;fish&quot;], [&quot;dinner&quot;, &quot;pasta&quot;]]</span><br><span class="line"></span><br><span class="line">for [meal_type, food] in meals</span><br><span class="line">  echo &quot;I am having &quot; . food . &quot; for &quot; . meal_type</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure>



<h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let beverages = #&#123;breakfast: &quot;milk&quot;, lunch: &quot;orange juice&quot;, dinner: &quot;water&quot;&#125;</span><br><span class="line">for beverage_type in keys(beverages)</span><br><span class="line">  echo &quot;I am drinking &quot; . beverages[beverage_type] . &quot; for &quot; . beverage_type</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure>



<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><h3 id="常见"><a href="#常见" class="headerlink" title="常见"></a>常见</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let counter = 1</span><br><span class="line">while counter &lt; 5</span><br><span class="line">  echo &quot;Counter is: &quot; . counter</span><br><span class="line">  let counter += 1</span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure>



<h3 id="获得每行内容"><a href="#获得每行内容" class="headerlink" title="获得每行内容"></a>获得每行内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let current_line = line(&quot;.&quot;)</span><br><span class="line">let last_line = line(&quot;$&quot;)</span><br><span class="line"></span><br><span class="line">while current_line &lt;= last_line</span><br><span class="line">  echo getline(current_line)</span><br><span class="line">  let current_line += 1</span><br><span class="line">endwhile</span><br></pre></td></tr></table></figure>



<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>和 python 一样：中断循环</p>
<h3 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h3><p>和 python 一样：跳过当前轮</p>
<h3 id="try-finally-and-catch"><a href="#try-finally-and-catch" class="headerlink" title="try, finally, and catch"></a>try, finally, and catch</h3><p>和 python 一样</p>
<ul>
<li>finally: 总是被执行，且是最后被执行</li>
<li>catch: 捕获错误</li>
</ul>
<blockquote>
<p>注</p>
<ul>
<li><code>throw</code>：抛出一个错误</li>
</ul>
</blockquote>
<p><strong>catch 捕捉的错误</strong></p>
<p><code>:h :catch</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catch /^Vim:Interrupt$/.             &quot; catch interrupts (CTRL-C)</span><br><span class="line">catch /^Vim\\%((\\a\\+)\\)\\=:E/.    &quot; catch all Vim errors</span><br><span class="line">catch /^Vim\\%((\\a\\+)\\)\\=:/.     &quot; catch errors and interrupts</span><br><span class="line">catch /^Vim(write):/.                &quot; catch all errors in :write</span><br><span class="line">catch /^Vim\\%((\\a\\+)\\)\\=:E123:/ &quot; catch error E123</span><br><span class="line">catch /my-exception/.                &quot; catch user exception</span><br><span class="line">catch /.*/                           &quot; catch everything</span><br><span class="line">catch.                               &quot; same as /.*/</span><br></pre></td></tr></table></figure>





<h1 id="第27章-变量范围"><a href="#第27章-变量范围" class="headerlink" title="第27章 变量范围"></a>第27章 变量范围</h1><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>定义变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let val = &quot;value&quot;</span><br></pre></td></tr></table></figure>

<p><code>let</code> 定义的是&#x3D;&#x3D;变量&#x3D;&#x3D;</p>
<p><strong>修改变量</strong></p>
<p>当需要改变变量的值时，需要使用 <code>let</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let val = &quot;value&quot;</span><br><span class="line">let val = &quot;value1&quot;</span><br></pre></td></tr></table></figure>



<p><strong>使用变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo val</span><br></pre></td></tr></table></figure>



<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>定义</strong></p>
<p>使用 <code>const</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const val = &quot;value&quot;</span><br></pre></td></tr></table></figure>



<h2 id="变量源"><a href="#变量源" class="headerlink" title="变量源"></a>变量源</h2><ul>
<li>环境变量</li>
<li>选项变量</li>
<li>寄存器变量</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>vim 可以访问&#x3D;&#x3D;终端的环境变量&#x3D;&#x3D;</p>
<p><strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;Enviroment_variable&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：不要使用 <code>&#123;&#125;</code>，错误的用法: <code>echo $&#123;SHELL&#125;</code></p>
</blockquote>
<h3 id="选项变量"><a href="#选项变量" class="headerlink" title="选项变量"></a>选项变量</h3><p>这些变量也就是 <code>.vimrc</code> 中使用 <code>set</code> 设置的那些变量</p>
<p><strong>访问</strong></p>
<ul>
<li><p>方法1<code>: 使用 </code>&amp;&#96;</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &amp;background</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2: <code>set background?</code></p>
</li>
</ul>
<h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p><strong>访问</strong></p>
<p>使用 <code>@</code></p>
<p><strong>更新寄存器的值</strong></p>
<p>使用 <code>let</code></p>
<p><strong>示例</strong></p>
<ul>
<li><p>访问寄存器 a</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo @a</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新寄存器 a 的值</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let @a .= &quot; donut&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h2><table>
<thead>
<tr>
<th>变量范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>g:</code></td>
<td>Global variable</td>
</tr>
<tr>
<td><code>&#123;nothing&#125;</code></td>
<td>Global variable</td>
</tr>
<tr>
<td><code>b:</code></td>
<td>Buffer-local variable</td>
</tr>
<tr>
<td><code>w:</code></td>
<td>Window-local variable</td>
</tr>
<tr>
<td><code>t:</code></td>
<td>Tab-local variable</td>
</tr>
<tr>
<td><code>s:</code></td>
<td>Sourced Vimscript variable</td>
</tr>
<tr>
<td><code>l:</code></td>
<td>Function local variable</td>
</tr>
<tr>
<td><code>a:</code></td>
<td>Function formal parameter variable</td>
</tr>
<tr>
<td><code>v:</code></td>
<td>Built-in Vim variable</td>
</tr>
</tbody></table>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p><strong>范围</strong></p>
<p>可以在任何地方使用</p>
<p><strong>定义</strong></p>
<ul>
<li><code>let val = &quot;value&quot;</code></li>
<li><code>let g:val = &quot;value&quot;</code></li>
</ul>
<p><strong>使用</strong></p>
<ul>
<li><code>echo val</code></li>
<li><code>echo g:val</code></li>
</ul>
<h3 id="缓冲区变量"><a href="#缓冲区变量" class="headerlink" title="缓冲区变量"></a>缓冲区变量</h3><p><strong>定义</strong></p>
<p>添加前缀 <code>b:</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const b:donut = &quot;chocoldate donut&quot;</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong></p>
<p>定义的每个缓冲区变量仅在定义时所在的缓冲区有效，也就是说缓冲区变量的作用域是定义所在缓冲区</p>
<p><strong>特殊缓冲区值</strong></p>
<p><code>b:changedtick</code>: 跟踪了在当前缓冲区所有的改变</p>
<h3 id="窗口变量"><a href="#窗口变量" class="headerlink" title="窗口变量"></a>窗口变量</h3><p><strong>定义</strong></p>
<p>添加前缀 <code>w:</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let w:donut = &quot;donut&quot;</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong></p>
<p>类似于缓冲区变量，变量的作用域为定义的窗口</p>
<p><strong>标签变量</strong></p>
<p><strong>定义</strong></p>
<p>添加前缀 <code>t:</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let t:done</span><br></pre></td></tr></table></figure>



<p><strong>说明</strong></p>
<p>类似于窗口变量和缓冲区变量</p>
<h3 id="脚本变量"><a href="#脚本变量" class="headerlink" title="脚本变量"></a>脚本变量</h3><p><strong>定义</strong></p>
<p>使用前缀 <code>s:</code></p>
<p><strong>说明</strong></p>
<p>仅在定义变量的脚本内部才可以访问到</p>
<h3 id="Function-Local-and-Function-Formal-Parameter-Variable"><a href="#Function-Local-and-Function-Formal-Parameter-Variable" class="headerlink" title="Function Local and Function Formal Parameter Variable"></a>Function Local and Function Formal Parameter Variable</h3><p><strong>定义</strong></p>
<ul>
<li>函数局部变量：<code>l:</code></li>
<li>函数形参变量: <code>a:</code></li>
</ul>
<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p><strong>说明</strong></p>
<p>前缀为 <code>v:</code></p>
<p><strong>注意</strong></p>
<p>无法定义这些变量</p>
<p><strong>常见</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>v:version</code></td>
<td>vim 版本</td>
</tr>
<tr>
<td><code>v:key</code></td>
<td>contains the current item value when iterating through a dictionary.</td>
</tr>
<tr>
<td><code>v:val</code></td>
<td>contains the current item value when running a map() or filter() operation.</td>
</tr>
<tr>
<td><code>v:true</code>, <code>v:false</code>, <code>v:null</code>, and <code>v:none</code></td>
<td>special data types.</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：查看其他的内置变量 <code>:h vim-variable</code> or <code>:h v:</code>.</p>
</blockquote>
<h1 id="第28章-函数"><a href="#第28章-函数" class="headerlink" title="第28章 函数"></a>第28章 函数</h1><h2 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function &#123;FunctionNmae&#125;()</span><br><span class="line">	&#123;do-something&#125;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>&#x3D;&#x3D;函数名必须以大写字母开头&#x3D;&#x3D;</li>
<li>函数名不能以数字开头</li>
</ul>
</blockquote>
<h3 id="函数名小写字母开始"><a href="#函数名小写字母开始" class="headerlink" title="函数名小写字母开始"></a>函数名小写字母开始</h3><p>使用脚本变量前缀 <code>s:</code>，如：<code>function s:tasty()</code></p>
<h3 id="同名函数"><a href="#同名函数" class="headerlink" title="同名函数"></a>同名函数</h3><p>不允许有重名函数</p>
<p><strong>覆写函数</strong></p>
<p>在 <code>function</code> 后面使用 <code>!</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function！ Tasty()</span><br><span class="line">	echo &quot;Tasty&quot;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<p>覆写之后上面的函数就会没有。&#x3D;&#x3D;覆写不是重载&#x3D;&#x3D;哦</p>
<h2 id="查看所有可用函数"><a href="#查看所有可用函数" class="headerlink" title="查看所有可用函数"></a>查看所有可用函数</h2><p>使用 <code>:function</code></p>
<h3 id="查看某一个函数内容"><a href="#查看某一个函数内容" class="headerlink" title="查看某一个函数内容"></a>查看某一个函数内容</h3><p><code>:function Tasty</code></p>
<h3 id="模式搜索函数"><a href="#模式搜索函数" class="headerlink" title="模式搜索函数"></a>模式搜索函数</h3><p><code>:function /pattern</code></p>
<h3 id="查看函数位置"><a href="#查看函数位置" class="headerlink" title="查看函数位置"></a>查看函数位置</h3><p>使用 <code>:verbose</code> 和 <code>:function 命令</code></p>
<ul>
<li><p>某一函数</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:verbose function &lt;FunctionName&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模式匹配函数</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:verbose function /&lt;pattern&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><p>删除一个已有函数: <code>:delfunction &#123;FunctionName&#125;</code></p>
<p>例如: <code>:delfunction Tasty</code></p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ul>
<li>默认返回 0</li>
<li><code>return</code>: 等价于返回0</li>
</ul>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p><strong>用法</strong></p>
<p>使用 <code>a:</code></p>
<p><strong>示例</strong></p>
<p>如函数 <code>Tasty()</code> 使用参数 <code>food</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function! Tasty(food)</span><br><span class="line">	return &quot;Tasty&quot; . a:food</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>



<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>使用 <code>l:</code></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>问题 1</strong></p>
<p>若在函数内部定义一个变量，那么这个变量默认为局部变量</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function!</span> <span class="title">Tasty</span><span class="params">()</span></span><br><span class="line">	<span class="keyword">let</span> location = <span class="string">&quot;tasty&quot;</span></span><br><span class="line">	<span class="keyword">return</span> location . <span class="string">&quot; in Tasty&quot;</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>与下面代码等价，但是&#x3D;&#x3D;没有下面的代码好&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function! Tasty()</span><br><span class="line">	let l:location = &quot;tasty&quot;</span><br><span class="line">	return l:location . &quot; in Tasty&quot;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>



<p><strong>问题 2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function! Calories()</span><br><span class="line">  let count = &quot;count&quot;</span><br><span class="line">  return &quot;I do not &quot; . count . &quot; my calories&quot;</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">echo Calories()</span><br><span class="line">&quot; throws an error</span><br></pre></td></tr></table></figure>

<p>变量会与特殊变量同名，导致错误</p>
<p>错误根源：<code>let count = &quot;count&quot;</code></p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>纯粹调用函数</strong></p>
<p>使用 <code>call</code> 调用函数</p>
<ul>
<li><p>命令行</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:call Tasty()</span><br></pre></td></tr></table></figure>
</li>
<li><p>脚本</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call Tasty()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>You cannot call a command-line command with another command-line command. </p>
<p>你不能使用命令行命令调用命令行命令</p>
<p><strong>使用函数返回值</strong><br>使用 <code>call(&quot;&lt;FunctionName&gt;&quot;, [&lt;参数列表&gt;])</code></p>
<p><code>[]</code> 不可以省略</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>:call</code> 是命令行命令</li>
<li><code>call()</code>： 函数<ul>
<li>第一个参数接收函数名</li>
<li>第二个参数接收形参列表</li>
</ul>
</li>
</ul>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>使用 <code>=</code></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function! Breakfast(meal, beverage = &quot;Milk&quot;)</span><br><span class="line">  return &quot;I had &quot; . a:meal . &quot; and &quot; . a:beverage . &quot; for breakfast&quot;</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">echo Breakfast(&quot;Hash Browns&quot;)</span><br><span class="line">&quot; returns I had hash browns and milk for breakfast</span><br><span class="line"></span><br><span class="line">echo Breakfast(&quot;Cereal&quot;, &quot;Orange Juice&quot;)</span><br><span class="line">&quot; returns I had Cereal and Orange Juice for breakfast</span><br></pre></td></tr></table></figure>



<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>使用 <code>...</code></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function! Buffet(...)</span><br><span class="line">  return a:1</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a:0</code>: 共有多少个参数</li>
<li><code>a:1</code> 是第一个参数</li>
<li><code>a:2</code> 是第二个参数</li>
<li>…</li>
<li><code>a:20</code> 是第20个参数</li>
<li><code>a:000</code> 是所有参数值组成的列表</li>
</ul>
<p><strong>a:0 示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function! Buffet(...)</span><br><span class="line">  let l:food_counter = 1</span><br><span class="line">  let l:foods = &quot;&quot;</span><br><span class="line">  while l:food_counter &lt;= a:0</span><br><span class="line">    let l:foods .= a:&#123;l:food_counter&#125; . &quot; &quot;</span><br><span class="line">    let l:food_counter += 1</span><br><span class="line">  endwhile</span><br><span class="line">  return l:foods</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>



<p><strong>a:000 + for</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function! Buffet(...)</span><br><span class="line">  let l:foods = &quot;&quot;</span><br><span class="line">  for food_item in a:000</span><br><span class="line">    let l:foods .= food_item . &quot; &quot;</span><br><span class="line">  endfor</span><br><span class="line">  return l:foods</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">echo Buffet(&quot;Noodles&quot;, &quot;Sushi&quot;, &quot;Ice cream&quot;, &quot;Tofu&quot;, &quot;Mochi&quot;)</span><br><span class="line">&quot; returns Noodles Sushi Ice cream Tofu Mochi</span><br></pre></td></tr></table></figure>



<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>在定义函数的第一行最后加入 <code>range</code></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>会给该函数添加两个特定变量：</p>
<ul>
<li><code>a:firstline</code>: 所选范围的第一行的行号</li>
<li><code>b:lastline</code>: 所选范围的最后一行的行号</li>
</ul>
<h3 id="与-line-“-”-区别"><a href="#与-line-“-”-区别" class="headerlink" title="与 line(“.”) 区别"></a>与 line(“.”) 区别</h3><ul>
<li><code>line(&quot;.&quot;)</code>： 会在所选范围的所有行上，每行会执行一次函数</li>
<li><code>range</code>： 只会在第一行执行一次</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function! Breakfast() range</span><br><span class="line">    echo line(&quot;.&quot;)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:11,20 call Breakfast</span><br></pre></td></tr></table></figure>



<h2 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h2><p>没什么用处</p>
<p>也没怎么看懂</p>
<h2 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h2><p>类似于函数指针，将变量指向一个函数</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>使用 <code>function()</code></p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function! Breakfast(item)</span><br><span class="line">  return &quot;I am having &quot; . a:item . &quot; for breakfast&quot;</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">let Breakfastify = Breakfast</span><br><span class="line">&quot; returns error</span><br><span class="line"></span><br><span class="line">let Breakfastify = function(&quot;Breakfast&quot;)</span><br><span class="line"></span><br><span class="line">echo Breakfastify(&quot;oatmeal&quot;)</span><br><span class="line">&quot; returns &quot;I am having oatmeal for breakfast&quot;</span><br><span class="line"></span><br><span class="line">echo Breakfastify(&quot;pancake&quot;)</span><br><span class="line">&quot; returns &quot;I am having pancake for breakfast&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>未命名函数</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let Plus = &#123;x,y -&gt; x + y&#125;</span><br><span class="line">echo Plus(1,2)</span><br><span class="line">&quot; returns 3</span><br><span class="line"></span><br><span class="line">let Tasty = &#123; -&gt; &#x27;tasty&#x27;&#125;</span><br><span class="line">echo Tasty()</span><br><span class="line">&quot; returns &quot;tasty&quot;</span><br></pre></td></tr></table></figure>



<p>You can call a function from insisde a lambda expression（没看懂）</p>
<h2 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>使用 <code>-&gt;</code></p>
<p><code>-&gt;</code>跟在函数名后面，且中间不能添加空格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Source-&gt;Method1()-&gt;Method2()-&gt;...-&gt;MethodN()</span><br></pre></td></tr></table></figure>



<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>像 <code>shell</code> 的 &#x3D;&#x3D;管道&#x3D;&#x3D;</p>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function! Lunch()</span><br><span class="line">  let appetizer = &quot;shrimp&quot;</span><br><span class="line"></span><br><span class="line">  function! SecondLunch()</span><br><span class="line">    return appetizer</span><br><span class="line">  endfunction</span><br><span class="line"></span><br><span class="line">  return funcref(&quot;SecondLunch&quot;)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>

<p>appetizer在Lunch函数中定义，该函数返回SecondLunch函数。注意，SecondLunch使用了appetizer，但在Vimscript中，它没有访问该变量的权限。如果你尝试运行<code>echo Lunch()()</code>， Vim将抛出一个未定义变量错误。</p>
<p><strong>解决</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function! Lunch()</span><br><span class="line">  let appetizer = &quot;shrimp&quot;</span><br><span class="line"></span><br><span class="line">  function! SecondLunch() closure</span><br><span class="line">    return appetizer</span><br><span class="line">  endfunction</span><br><span class="line"></span><br><span class="line">  return funcref(&quot;SecondLunch&quot;)</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>







<h1 id="写插件"><a href="#写插件" class="headerlink" title="写插件"></a>写插件</h1><p>略</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/05/154/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/05/154/" class="post-title-link" itemprop="url">154. VIM 从放弃到偶尔</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-05 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-05T00:00:00+08:00">2023-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第13章-全局命令"><a href="#第13章-全局命令" class="headerlink" title="第13章 全局命令"></a>第13章 全局命令</h1><p>到目前为止，您已经了解了如何使用点命令(<code>.</code>)重复上一次更改，如何使用宏(<code>q</code>)重复动作以及将文本存储在寄存器中(<code>&quot;</code>)。</p>
<p>在本章中，您将学习如何在全局命令中重复命令行命令。</p>
<h2 id="全局命令概述"><a href="#全局命令概述" class="headerlink" title="全局命令概述"></a>全局命令概述</h2><p>Vim的全局命令用于同时在多行上运行命令行命令。</p>
<p>顺便说一句，您之前可能已经听说过 “Ex命令” 一词。在本书中，我将它们称为&#x3D;&#x3D;命令行命令&#x3D;&#x3D;，但Ex命令和命令行命令是相同的。它们是以冒号（<code>:</code>）开头的命令。在上一章中，您了解了替代命令。这是一个Ex命令的示例。它们之所以称为Ex，是因为它们最初来自Ex文本编辑器。在本书中，我将继续将它们称为命令行命令。有关Ex命令的完整列表，请查看<code>:h ex-cmd-index</code>。</p>
<p>全局命令具有以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/pattern/command</span><br></pre></td></tr></table></figure>

<p><code>pattern</code>匹配包含该模式串的所有行，类似于替代命令中的模式串。<code>command</code>可以是任何命令行命令。全局命令通过对与<code>pattern</code>匹配的每一行执行<code>command</code>来工作。</p>
<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>要删除所有包含”console”的行，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/d</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br></pre></td></tr></table></figure>

<p>全局命令在与”console”模式串匹配的所有行上执行删除命令(<code>d</code>)。</p>
<p>运行<code>g</code>命令时，Vim对文件进行两次扫描。在第一次运行时，它将扫描每行并标记与<code>/console/</code>模式传教匹配的行。一旦所有匹配的行都被标记，它将进行第二次运行，并在标记的行上执行d命令。</p>
<p>如果要删除所有包含”const”的行，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/const/d</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<h2 id="逆向匹配"><a href="#逆向匹配" class="headerlink" title="逆向匹配"></a>逆向匹配</h2><p>要在不匹配的行上运行全局命令，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g!/&#123;pattern&#125;/&#123;command&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:v/&#123;pattern&#125;/&#123;command&#125;</span><br></pre></td></tr></table></figure>

<p>如果运行<code>:v/console/d</code>，它将删除 <strong>不</strong> 包含”console”的所有行。</p>
<h2 id="模式串"><a href="#模式串" class="headerlink" title="模式串"></a>模式串</h2><p>全局命令使用与替代命令相同的模式串系统，因此本节将作为更新。随意跳到下一部分或继续阅读！</p>
<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>要删除包含”one”或”two”的行，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/one\|two/d</span><br></pre></td></tr></table></figure>

<p>要删除包含任何一位数字的行，请运行以下任一命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/[0-9]/d</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/\d/d</span><br></pre></td></tr></table></figure>

<p>如果您有表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const oneMillion = 1000000;</span><br><span class="line">const oneThousand = 1000;</span><br><span class="line">const one = 1;</span><br></pre></td></tr></table></figure>

<p>要匹配包含三到六个零的行，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/0\&#123;3,6\&#125;/d</span><br></pre></td></tr></table></figure>

<h2 id="传递范围参数"><a href="#传递范围参数" class="headerlink" title="传递范围参数"></a>传递范围参数</h2><p>您可以在<code>g</code>命令之前传递一个范围。您可以通过以下几种方法来做到这一点：</p>
<ul>
<li><code>:1,5g/console/d</code>  删除第1行和第5行之间匹配字符串”console”的行。</li>
<li><code>:,5g/console/d</code> 如果逗号前没有地址，则从当前行开始。它在当前行和第5行之间寻找字符串”console”并将该行删除。</li>
<li><code>:3,g/console/d</code> 如果逗号后没有地址，则在当前行结束。它在第3行和当前行之间寻找字符串”console”并将该行删除。</li>
<li><code>:3g/console/d</code> 如果只传递一个地址而不带逗号，则仅在第3行执行命令。在第3行查找，如果包含字符串”console”，则将其删除。</li>
</ul>
<p>除了数字，您还可以将这些符号用作范围：</p>
<ul>
<li><code>.</code> 表示当前行。范围<code>.,3</code>表示当前行和第3行之间。</li>
<li><code>$</code> 表示文件的最后一行。 <code>3,$</code>范围表示在第3行和最后一行之间。</li>
<li><code>+n</code> 表示当前行之后的n行。您可以将其与<code>.</code>结合使用，也可以不结合使用。  <code>3,+1</code>或<code>3,.+1</code>表示在第3行和当前行之后的行之间。</li>
</ul>
<p>如果您不给它任何范围，默认情况下它将影响整个文件。这实际上不是常态。如果您不传递任何范围，Vim的大多数命令行命令仅在当前行上运行(两个值得注意的例外是：这里介绍的全局命令(<code>:g</code>)和save(<code>:w</code>)命令)。</p>
<h2 id="普通模式命令"><a href="#普通模式命令" class="headerlink" title="普通模式命令"></a>普通模式命令</h2><p>您可以将全局命令和<code>:normal</code>命令行命令一起运行。</p>
<p>如果您有以下文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const one = 1</span><br><span class="line">console.log(&quot;one: &quot;, one)</span><br><span class="line"></span><br><span class="line">const two = 2</span><br><span class="line">console.log(&quot;two: &quot;, two)</span><br><span class="line"></span><br><span class="line">const three = 3</span><br><span class="line">console.log(&quot;three: &quot;, three)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要添加”;”运行到每一行的末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/./normal A;</span><br></pre></td></tr></table></figure>

<p>让我们分解一下：</p>
<ul>
<li><code>:g</code> 是全局命令。</li>
<li><code>/./</code> 是“非空行”的模式。它匹配至少包含1个字符的行。因此将与包含“const”和“console”的行匹配。它不匹配空行。</li>
<li><code>normal A;</code> 运行<code>:normal</code>命令行命令。 <code>A;</code> 是普通模式命令，用于在该行的末尾插入”;”。</li>
</ul>
<h2 id="执行宏"><a href="#执行宏" class="headerlink" title="执行宏"></a>执行宏</h2><p>您也可以使用全局命令执行宏。宏只是普通模式下的操作，因此可以使用<code>:normal</code>来执行宏。如果您有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>请注意，带有”const”的行没有分号。让我们创建一个宏，以在寄存器”a”的这些行的末尾添加逗号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0A;&lt;esc&gt;q</span><br></pre></td></tr></table></figure>

<p>如果您需要复习，请查看有关宏的章节。现在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/const/normal @a</span><br></pre></td></tr></table></figure>

<p>现在，所有带有”const”的行的末尾将带有”;”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>如果您一步一步按照示例做，您将会在第一行末尾看到两个分号。为避免这种情况，使用全局命令时，给一个范围参数，从第2行到最后一行, <code>:2,$g/const/normal @a</code>。</p>
<h2 id="递归全局命令"><a href="#递归全局命令" class="headerlink" title="递归全局命令"></a>递归全局命令</h2><p>全局命令本身是命令行命令的一种，因此您可以从技术上在全局命令中运行全局命令。</p>
<p>给定表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/g/two/d</span><br></pre></td></tr></table></figure>

<p>首先，<code>g</code>将查找包含模式”console”的行，并找到3个匹配项。然后，第二个”g”将从那三个匹配项中查找包含模式”two”的行。最后，它将删除该匹配项。</p>
<p>您也可以将<code>g</code>与<code>v</code>结合使用以找到正负模式。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/v/two/d</span><br></pre></td></tr></table></figure>

<p>与前面的命令不同，它将查找 <strong>不</strong> 包含”two”的行。</p>
<h2 id="更改定界符"><a href="#更改定界符" class="headerlink" title="更改定界符"></a>更改定界符</h2><p>您可以像替代命令一样更改全局命令的定界符。规则是相同的：您可以使用任何单字节字符，但字母，数字，<code>&quot;</code>, <code>|</code>, 和 <code>\</code>除外。</p>
<p>要删除包含”console”的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g@console@d</span><br></pre></td></tr></table></figure>

<p>如果在全局命令中使用替代命令，则可以有两个不同的定界符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g@one@s+const+let+g</span><br></pre></td></tr></table></figure>

<p>此处，全局命令将查找包含”one”的所有行。 替换命令将从这些匹配项中将字符串”const”替换为”let”。</p>
<h2 id="默认命令"><a href="#默认命令" class="headerlink" title="默认命令"></a>默认命令</h2><p>如果在全局命令中未指定任何命令行命令，会发生什么？</p>
<p>全局命令将使用打印(<code>:p</code>)命令来打印当前行的文本。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console</span><br></pre></td></tr></table></figure>

<p>它将在屏幕底部打印所有包含”console”的行。</p>
<p>顺便说一下，这是一个有趣的事实。因为全局命令使用的默认命令是<code>p</code>，所以这使<code>g</code>语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/re/p</span><br></pre></td></tr></table></figure>
<ul>
<li><code>g</code> &#x3D; 全局命令</li>
<li><code>re</code> &#x3D; 正则表达式模式</li>
<li><code>p</code> &#x3D; 打印命令</li>
</ul>
<p>这三个元素连起来拼写为 **”grep”**，与命令行中的<code>grep</code> 相同。但这 <strong>不</strong> 是巧合。 <code>g/re/p</code>命令最初来自Ed编辑器（一个行文本编辑器）。 <code>grep</code>命令的名称来自Ed。</p>
<p>您的计算机可能仍具有Ed编辑器。从终端运行<code>ed</code>（提示：要退出，请键入<code>q</code>）。</p>
<h2 id="反转整个缓冲区"><a href="#反转整个缓冲区" class="headerlink" title="反转整个缓冲区"></a>反转整个缓冲区</h2><p>要翻转整个文件，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^/m 0 </span><br></pre></td></tr></table></figure>

<p><code>^</code>表示行的开始。使用<code>^</code>匹配所有行，包括空行。</p>
<p>如果只需要反转几行，请将其传递一个范围。要将第5行到第10行之间的行反转，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:5,10g/^/m 0</span><br></pre></td></tr></table></figure>

<p>要了解有关move命令的更多信息，请查看<code>:h :move</code>。</p>
<h2 id="汇总所有待办事项"><a href="#汇总所有待办事项" class="headerlink" title="汇总所有待办事项"></a>汇总所有待办事项</h2><p>当我编码时，有时我会想到一个随机的绝妙主意。不想失去专注，我通常将它们写在我正在编辑的文件中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">// TODO: 喂小狗</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure>

<p>跟踪所有已创建的TODO可能很困难。 Vim有一个<code>:t</code>（copy）方法来将所有匹配项复制到一个地址。要了解有关复制方法的更多信息，请查看<code>:h :copy</code>。</p>
<p>要将所有TODO复制到文件末尾以便于自省，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/TODO/t $</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">// TODO：喂小狗</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br><span class="line"></span><br><span class="line">// TODO：喂小狗</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure>

<p>现在，我可以查看我创建的所有TODO，另外找个时间来完成它们，或将它们委托给其他人，然后继续执行下一个任务。</p>
<p>如果不想复制，而是将所有的 TODO 移动到末尾，可以使用移动命令 <code>m</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/TODO/m $</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line"></span><br><span class="line">// TODO：喂小狗</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure>

<h2 id="黑洞删除"><a href="#黑洞删除" class="headerlink" title="黑洞删除"></a>黑洞删除</h2><p>回想一下寄存器那一章，已删除的文本存储在编号寄存器中（允许它们足够大）。每当运行<code>:g/console/d</code>时，Vim都会将删除的行存储在编号寄存器中。如果删除多行，所有编号的寄存器将很快被填满。为了避免这种情况，您可以使用黑洞寄存器（<code>&quot;_</code>） <strong>不</strong> 将删除的行存储到寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/console/d _</span><br></pre></td></tr></table></figure>

<p>通过在<code>d</code>之后传递<code>_</code>，Vim不会将删除的行保存到任何寄存器中。</p>
<h2 id="将多条空行减少为一条空行"><a href="#将多条空行减少为一条空行" class="headerlink" title="将多条空行减少为一条空行"></a>将多条空行减少为一条空行</h2><p>如果您的文件带有多个空行，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>您可以快速将多个空行减少为一条空行。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^$/,/./-1j</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>一般情况下全局命令遵循下列格式：<code>:g/pattern/command</code>。但是，您也可以使用下面的格式：<code>:g/pattern1/,/pattern2/command</code>。用这种格式，Vim将会使<code>command</code>作用在<code>pattern1</code>和<code>pattern2</code>上。</p>
<p>记住上面说的格式，让我们根据<code>:g/pattern1/,/pattern2/command</code>这个格式分解一下命令<code>:g/^$/,/./-1j</code>：</p>
<ul>
<li><code>/pattern1/</code> 就是 <code>/^$/</code> 。它表示一个空行（一个没有任何字符的行）。</li>
<li><code>/pattern2/</code> 就是 <code>/./</code>（用-1作为行修正）。<code>/./</code>表示一个非空行（一个含有至少1个字符的行）。这里的 <code>-1</code> 意思是向上偏移1行。</li>
<li><code>command</code> 就是 <code>j</code>，一个联接命令(<code>:j</code>)。在这个示例中，该全局命令联接所有给定的行。</li>
</ul>
<p>顺便说一句，如果您想要将多个空行全部删去，运行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^$/,/./j</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^$/-j</span><br></pre></td></tr></table></figure>

<p>您的文本将会减少为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>

<p>（译者补充：<code>j</code>连接命令的格式是：<code>:[range]j</code>。比如：<code>:1,5j</code>将连接第1至5行。在前面的命令中<code>:g/pattern1/,/pattern2/-1j</code>，<code>/pattern1/</code>和<code>/pattern2</code>都是<code>j</code>命令的范围参数，表示连接空行至非空行上方一行，这样就会保留1个空行。在早前的英文版本中有关于<code>j</code>命令的介绍，不知为何在后面的更新中，原作者删除了关于<code>j</code>命令的介绍）</p>
<h2 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h2><p>Vim有一个<code>:sort</code>命令来对一个范围内的行进行排序。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">e</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>您可以通过运行<code>:sort</code>对它们进行排序。如果给它一个范围，它将只对该范围内的行进行排序。例如，<code>:3,5sort</code>仅在第三和第五行之间排序。</p>
<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const arrayB = [</span><br><span class="line">  &quot;i&quot;,</span><br><span class="line">  &quot;g&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const arrayA = [</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果需要排序数组中的元素，而不是数组本身，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/\[/+1,/\]/-1sort</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const arrayB = [</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;g&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;i&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const arrayA = [</span><br><span class="line">  &quot;a&quot;</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这很棒！但是命令看起来很复杂。让我们分解一下。该命令依然遵循 <code>:g/pattern1/,/pattern2/command</code>这个格式。</p>
<ul>
<li><code>:g</code> 是全局命令</li>
<li><code>/\[/+1</code> 是第一个模式串，它匹配左方括号”[“。<code>+1</code>表示匹配行的下面1行。</li>
<li><code>/\]/-1</code> 是第二个模式串，它匹配右方括号”]”。<code>-1</code>表示匹配行的上面1行。</li>
<li><code>/\[/+1,/\]/-1</code> 表示在”[“和”]”之间的行。</li>
<li><code>sort</code> 是命令行命令：排序。</li>
</ul>
<h2 id="聪明地学习全局命令"><a href="#聪明地学习全局命令" class="headerlink" title="聪明地学习全局命令"></a>聪明地学习全局命令</h2><p>全局命令针对所有匹配的行执行命令行命令。有了它，您只需要运行一次命令，Vim就会为您完成其余的工作。要精通全局命令，需要做两件事：良好的命令行命令词汇表和正则表达式知识。随着您花费更多的时间使用Vim，您自然会学到更多的命令行命令。正则表达式知识需要更多的实际操作。但是一旦您适应了使用正则表达式，您将领先于很多其他人。</p>
<p>这里的一些例子很复杂。不要被吓到。真正花时间了解它们。认真阅读每个模式串，不要放弃。</p>
<p>每当需要在多个位置应用命令时，请暂停并查看是否可以使用<code>g</code>命令。寻找最适合工作的命令，并编写一个模式串以同时定位多个目标。</p>
<p>既然您已经知道全局命令的功能强大，那么让我们学习如何使用外部命令来增加工具库。</p>
<h1 id="第14章-外部命令"><a href="#第14章-外部命令" class="headerlink" title="第14章 外部命令"></a>第14章 外部命令</h1><p>在Unix系统内部，您会发现许多小型的，超专业化命令，每个命令只做一件事（而且能很好地完成）。您可以将这些命令链接在一起以共同解决一个复杂的问题。如果可以从Vim内部使用这些命令，那不是很好吗？</p>
<p>答案是肯定的!在本章中，您将学习如何扩展Vim以使其与外部命令无缝协作。</p>
<h2 id="Bang-命令"><a href="#Bang-命令" class="headerlink" title="Bang 命令"></a>Bang 命令</h2><p>Vim有一个Bang(<code>!</code>)命令，可以执行三件事：</p>
<p>1.将外部命令的STDOUT读入当前缓冲区。<br>2.将缓冲区的内容作为STDIN写入外部命令。<br>3.从Vim内部执行外部命令。</p>
<p>让我们一个个认真看一下。</p>
<h2 id="将外部命令的标准输出STDOUT读入Vim"><a href="#将外部命令的标准输出STDOUT读入Vim" class="headerlink" title="将外部命令的标准输出STDOUT读入Vim"></a>将外部命令的标准输出STDOUT读入Vim</h2><p>将外部命令的STDOUT读入当前缓冲区的语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !&#123;cmd&#125;</span><br></pre></td></tr></table></figure>

<p><code>:r</code>是Vim的读命令。如果不带<code>!</code>使用它，则可以使用它来获取文件的内容。如果当前目录中有文件<code>file1.txt</code>，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r file1.txt</span><br></pre></td></tr></table></figure>

<p>Vim会将<code>file1.txt</code>的内容放入当前缓冲区。</p>
<p>如果您运行的<code>:r</code>命令后面跟一个<code>!</code>和外部命令，则该命令的输出将插入到当前缓冲区中。要获取<code>ls</code>命令的结果，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !ls</span><br></pre></td></tr></table></figure>

<p>它返回类似下列的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line">file3.txt</span><br></pre></td></tr></table></figure>

<p>您可以从<code>curl</code>命令读取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r !curl -s &#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span><br></pre></td></tr></table></figure>

<p>r命令也接受一个地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:10r !cat file1.txt</span><br></pre></td></tr></table></figure>

<p>现在，将在第10行之后插入来自运行<code>cat file.txt</code>的STDOUT。</p>
<h2 id="将缓冲区内容写入外部命令"><a href="#将缓冲区内容写入外部命令" class="headerlink" title="将缓冲区内容写入外部命令"></a>将缓冲区内容写入外部命令</h2><p><code>:w</code>命令除了保存文件，还可以用来将当前缓冲区中的文本作为作为STDIN传递给外部命令。语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w !cmd</span><br></pre></td></tr></table></figure>

<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello Vim&quot;);</span><br><span class="line">console.log(&quot;Vim is awesome&quot;);</span><br></pre></td></tr></table></figure>

<p>确保在计算机中安装了<a target="_blank" rel="noopener" href="https://nodejs.org/en/">node</a>，然后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w !node</span><br></pre></td></tr></table></figure>

<p>Vim将使用<code>node</code>执行Javascript表达式来打印”Hello Vim”和”Vim is awesome”。</p>
<p>当使用<code>：w</code>命令时，Vim使用当前缓冲区中的所有文本，与global命令类似（大多数命令行命令，如果不给它传递范围，则仅对当前行执行该命令）。如果您通过<code>：w</code>来指定地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:2w !node</span><br></pre></td></tr></table></figure>

<p>“Vim”只使用第二行中的文本到<code>node</code>解释器中。</p>
<p><code>:w !node</code>和<code>:w! node</code>形式上区别很小，但功能上相隔千里。使用<code>:w !node</code>，您是将当前缓冲区中的文本”写入”到外部命令<code>node</code>中。用<code>:w! node</code>，则您将强制保存文件并将其命名为”node”。</p>
<h2 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h2><p>您可以使用bang命令从Vim内部执行外部命令。语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!cmd</span><br></pre></td></tr></table></figure>

<p>要以长格式查看当前目录的内容，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!ls -ls</span><br></pre></td></tr></table></figure>

<p>要终止在PID 3456上运行的进程，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!kill -9 3456</span><br></pre></td></tr></table></figure>

<p>您可以在不离开Vim的情况下运行任何外部命令，因此您可以专注于自己的任务。</p>
<h2 id="过滤文本"><a href="#过滤文本" class="headerlink" title="过滤文本"></a>过滤文本</h2><p>如果给<code>!</code>范围，则可用于过滤文本。假设您有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hello vim</span><br></pre></td></tr></table></figure>

<p>让我们使用<code>tr</code> (translate)命令将当前行大写。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.!tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELLO VIM</span><br><span class="line">hello vim</span><br></pre></td></tr></table></figure>

<p>命令分解：</p>
<ul>
<li><code>.!</code> 在当前行执行filter命令。</li>
<li><code>!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code> 调用<code>tr</code>外部命令将所有小写字符替换为大写字符。</li>
</ul>
<p>&#x3D;&#x3D;必须传递范围以运行外部命令作为过滤器。&#x3D;&#x3D;如果您尝试在没有<code>.</code>的情况下运行上述命令(<code>:!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code>)，则会看到错误。</p>
<p>假设您需要使用awk命令删除两行的第二列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!awk &quot;&#123;print $1&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>命令分解：</p>
<ul>
<li><code>:%!</code>  在所有行(<code>%</code>)上执行filter命令。</li>
<li><code>awk &quot;&#123;print $1&#125;&quot;</code> 仅打印匹配项的第一列。</li>
</ul>
<p>您可以使用管道运算符（<code>|</code>）链接多个命令，就像在终端中一样。假设您有一个包含这些美味早餐的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name price</span><br><span class="line">chocolate pancake 10</span><br><span class="line">buttermilk pancake 9</span><br><span class="line">blueberry pancake 12</span><br></pre></td></tr></table></figure>

<p>如果您需要根据价格对它们进行排序，并且仅以均匀的间距显示菜单，则可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!awk &#x27;NR &gt; 1&#x27; | sort -nk 3 | column -t</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buttermilk pancake 9</span><br><span class="line">chocolate pancake 10</span><br><span class="line">blueberry pancake 12</span><br></pre></td></tr></table></figure>

<p>命令分解：</p>
<ul>
<li><code>:%!</code> 将过滤器应用于所有行(<code>%</code>)。</li>
<li><code>awk &#39;NR &gt; 1&#39;</code> 仅从第二行开始显示文本。</li>
<li><code>|</code>链接下一个命令。</li>
<li><code>sort -nk 3</code>使用列3（<code>k 3</code>）中的值对数字进行排序（<code>n</code>）。</li>
<li><code>column -t</code>以均匀的间距组织文本。</li>
</ul>
<h2 id="普通模式命令-1"><a href="#普通模式命令-1" class="headerlink" title="普通模式命令"></a>普通模式命令</h2><p>在普通模式下，Vim有一个过滤运算符（<code>!</code>）。如果您有以下问候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">bonjour vim</span><br><span class="line">salve vim</span><br></pre></td></tr></table></figure>

<p>要大写当前行和下面的行，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!jtr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span><br></pre></td></tr></table></figure>

<p>命令分解：</p>
<ul>
<li><code>!j</code> 运行常规命令过滤器运算符（<code>!</code>），目标是当前行及其下方的行。回想一下，因为它是普通模式运算符，所以适用语法规则”动词+名词”。</li>
<li><code>tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>将小写字母替换为大写字母。</li>
</ul>
<p>filter normal命令仅适用于至少一行以上的motion或至少一行以上的文本对象。如果您尝试运行<code>!iwtr&#39;[az]&#39;&#39;[AZ]&#39;</code>（在内部单词上执行<code>tr</code>），您会发现它在整个行上都应用了tr命令，而不是光标所在的单词。</p>
<h2 id="聪明地学习外部命令"><a href="#聪明地学习外部命令" class="headerlink" title="聪明地学习外部命令"></a>聪明地学习外部命令</h2><p>Vim不是IDE。它是一种轻量级的模式编辑器，通过设计可以高度扩展。由于这种可扩展性，您可以轻松访问系统中的任何外部命令。这样，Vim离成为IDE仅一步之遥。有人说Unix系统是有史以来的第一个IDE。</p>
<p>Bang 命令的有用程度与您知道多少个外部命令相关。如果您的外部命令知识有限，请不要担心。我还有很多东西要学。以此作为持续学习的动力。每当您需要过滤文本时，请查看是否存在可以解决问题的外部命令。不必担心掌握所有的命令。只需学习完成当前任务所需的内容即可。</p>
<h1 id="第15章-命令行模式"><a href="#第15章-命令行模式" class="headerlink" title="第15章 命令行模式"></a>第15章 命令行模式</h1><p>在前三章中，您已经学习了如何使用搜索命令(<code>/</code>, <code>?</code>)、替换命令(<code>:s</code>)、全局命令(<code>:g</code>)，以及外部命令(<code>!</code>)。这些都是命令行模式命令的一些例子。</p>
<p>在本章中，您将学习命令行模式的更多技巧。</p>
<h2 id="进入和退出命令行模式"><a href="#进入和退出命令行模式" class="headerlink" title="进入和退出命令行模式"></a>进入和退出命令行模式</h2><p>命令行模式本身也是一种模式，就像普通模式、输入模式、可视模式一样。在这种模式中，光标将转到屏幕底部，此时您可以输入不同的命令。</p>
<p>有 4 种进入命令行模式的方式：</p>
<ul>
<li>搜索命令 (<code>/</code>, <code>?</code>)</li>
<li>命令行指令 (<code>:</code>)</li>
<li>外部命令 (<code>!</code>)</li>
</ul>
<p>您可以从正常模式或可视模式进入命令行模式。</p>
<p>若要离开命令行模式，您可以使用 <code>&lt;esc&gt;</code>、<code>Ctrl-c</code>、<code>Ctrl-[</code>。</p>
<p><strong>有时其他资料可能会将”命令行指令”称为”Ex 命令”，将”外部命令”称为”过滤命令”或者”叹号运算符”。</strong></p>
<h2 id="重复上一个命令"><a href="#重复上一个命令" class="headerlink" title="重复上一个命令"></a>重复上一个命令</h2><p>您可以用 <code>@:</code> 来重复上一个命令行指令或外部命令。</p>
<p>如果您刚运行 <code>:s/foo/bar/g</code>，执行 <code>@:</code> 将重复该替换。如果您刚运行 <code>:.!tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>，执行 <code>@:</code> 将重复上一次外部命令转换过滤。</p>
<h2 id="命令行模式快捷键"><a href="#命令行模式快捷键" class="headerlink" title="命令行模式快捷键"></a>命令行模式快捷键</h2><p>在命令行模式中，您可以使用 <code>Left</code> 或 <code>Right</code> 方向键，来左右移动一个字符。</p>
<p>如果需要移动一个单词，使用 <code>Shift-Left</code> 或 <code>Shift-Right</code> (在某些操作系统中，您需要使用 <code>Ctrl</code> 而不是 <code>Shift</code>)。</p>
<p>使用 <code>Ctrl-b</code>移动到该行的开始，使用 <code>Ctrl-e</code>移动到该行的结束。</p>
<p>和输入模式类似，在命令行模式中，有三种方法可以删除字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure>
<p>最后，如果您想像编辑文本文件一样来编辑命令，可以使用 <code>Ctrl-f</code>。</p>
<p>这样还可以查看过往的命令，并在这种”命令行编辑的普通模式”中编辑它们，同时还能按下 <code>Enter</code> 来运行它们。</p>
<h2 id="寄存器和自动补全"><a href="#寄存器和自动补全" class="headerlink" title="寄存器和自动补全"></a>寄存器和自动补全</h2><p>当处于命令行模式时，您可以像在插入模式中一样使用 <code>Ctrl-r</code> 从Vim寄存器中插入文本。如果您在寄存器 a 中存储了字符串 “foo” ，您可以执行 <code>Ctrl-r a</code> 从寄存器a中插入该文本。任何在插入模式中您可以从寄存器中获取的内容，在命令行模式中您也可以获取。</p>
<p>另外，您也可以按 <code>Ctrl-r Ctrl-w</code> 获取当前光标下的单词（按 <code>Ctrl-r Ctrl-A</code> 获取当前光标下的词组）。还可以按 <code>Ctrl-r Ctlr-l</code> 获取当前光标所在行。按 <code>Ctrl-r Ctrl-f</code> 获取光标下的文件名。</p>
<p>您也可以对已存在的命令使用自动补全。要自动补全 <code>echo</code> 命令，当处于命令行模式时，首先输入 “ec”，接着按下 <code>&lt;Tab&gt;</code>，此时您应该能在左下角看到一些 “ec” 开头的 Vim 命令（例如：<code>echo echoerr echohl echomsg econ</code>）。按下 <code>&lt;Tab&gt;</code> 或 <code>Ctrl-n</code> 可以跳到下一个选项。按下 <code>&lt;Shift-Tab&gt;</code> 或 <code>Ctrl-p</code> 可以回到上一个选项。</p>
<p>一些命令行指令接受文件名作为参数。<code>edit</code> 就是一个例子，这时候您也可以使用自动补全。当输入 <code>:e </code> 后（不要忘记空格了），按下 <code>&lt;Tab&gt;</code>，Vim 将列出所有相关的文件名，这样您就可以进行选择而不必完整的输入它们。</p>
<h2 id="历史记录窗口"><a href="#历史记录窗口" class="headerlink" title="历史记录窗口"></a>历史记录窗口</h2><p>您可以查看命令行指令和搜索项的历史记录（要确保在运行 <code>vim --version</code> 时，Vim 的编译选项中含有<code>+cmdline_hist</code>）。</p>
<p>运行 <code>:his :</code> 来查看命令行指令的历史记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##  cmd History</span><br><span class="line">2  e file1.txt</span><br><span class="line">3  g/foo/d</span><br><span class="line">4  s/foo/bar/g</span><br></pre></td></tr></table></figure>

<p>Vim 列出了您运行的所有 <code>:</code> 命令。默认情况下，Vim 存储最后 50 个命令。运行 <code>:set history=100</code> 可以将 Vim 记住的条目总数更改为 100。</p>
<p>一个更有用的做法是使用命令行历史记录窗口，按<code>q:</code>将会打开一个可搜索、可编辑的历史记录窗口。假设按下<code>q:</code>后您有如下的表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">51  s/verylongsubstitutionpattern/pancake/g</span><br><span class="line">52  his :</span><br><span class="line">53  wq</span><br></pre></td></tr></table></figure>

<p>如果您当前任务是执行 <code>s/verylongsubstitutionpattern/donut/g</code>（”pancake”换成了”donut”），为什么不复用 <code>s/verylongsubstitutionpattern/pancake/g</code> 呢？毕竟，两条命令唯一不同的是替换的单词，”donut” vs “pancake” ，所有其他的内容都是相同的。</p>
<p>当您运行 <code>q:</code>后，在历史记录中找到 <code>s/verylongsubstitutionpattern/pancake/g</code>（在这个环境中，您可以使用Vim导航），然后直接编辑它！ 在历史记录窗口中将 “pancake” 改为 “donut” ，然后按 <code>&lt;Enter</code>。Vim立刻执行 <code>s/verylongsubstitutionpattern/donut/g</code> 命令，超级方便！</p>
<p>类似地，运行 <code>:his /</code> 或 <code>:his ?</code> 可以查看搜索记录。要想打开您可以直接搜索和编辑的搜索历史记录窗口，您可以运行 <code>q/</code> 和 <code>q?</code>。</p>
<p>要退出这个窗口，按 <code>Ctrl-c</code>, <code>Ctrl-w c</code>, 或输入 <code>:quit</code>。</p>
<h2 id="更多命令行指令"><a href="#更多命令行指令" class="headerlink" title="更多命令行指令"></a>更多命令行指令</h2><p>Vim有几百个内置指令，要查看Vim的所有指令，执行 <code>:h ex-cmd-index</code> 或 <code>:h :index</code>。</p>
<h2 id="聪明地学习命令行模式"><a href="#聪明地学习命令行模式" class="headerlink" title="聪明地学习命令行模式"></a>聪明地学习命令行模式</h2><p>对比其他三种模式，命令行模式就像是文本编辑中的瑞士军刀。寥举几例，您可以编辑文本、修改文件和执行命令。本章是命令行模式的零碎知识的集合。同时，Vim 模式的介绍也走向尾声。现在，您已经知道如何使用普通、输入、可视以及命令行模式，您可以比以往更快地使用 Vim 来编辑文本了。</p>
<p>是时候离开 Vim 模式，来了解如何使用 Vim 标记进行更快的导航了。</p>
<h1 id="第16章-标签"><a href="#第16章-标签" class="headerlink" title="第16章 标签"></a>第16章 标签</h1><p>快速转到任意定义处，是文本编辑中一个非常有用的特性。在本章中，您将学习如何使用 Vim 标签来做到这一点。</p>
<h2 id="标签概述"><a href="#标签概述" class="headerlink" title="标签概述"></a>标签概述</h2><p>假设有人给了您一个新的代码库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one = One.new</span><br><span class="line">one.donut</span><br></pre></td></tr></table></figure>

<p><code>One</code>？<code>donut</code>？呃，对于当时编写代码的开发者而言，这些代码的含义可能显而易见。问题是当时的开发者已经不在了，现在要由您来理解这些费解的代码。而跟随有<code>One</code> 和 <code>donut</code>定义的源代码，是帮助您理解的一个有效方法。</p>
<p>您可以使用<code>fzf</code> 或 <code>grep</code>来搜索它们，但这种情况下，但使用标签将更快。</p>
<p>把标签想象成地址簿：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Name    Address</span><br><span class="line">Iggy1   1234 Cool St, 11111</span><br><span class="line">Iggy2   9876 Awesome Ave, 2222</span><br></pre></td></tr></table></figure>

<p>当然，标签可不是存储着“姓名-地址”对，而是“定义-地址”对。</p>
<p>假设您在一个目录中有两个 Ruby 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## one.rb</span><br><span class="line">class One</span><br><span class="line">  def initialize</span><br><span class="line">    puts &quot;Initialized&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def donut</span><br><span class="line">    puts &quot;Bar&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## two.rb</span><br><span class="line">require &#x27;./one&#x27;</span><br><span class="line"></span><br><span class="line">one = One.new</span><br><span class="line">one.donut</span><br></pre></td></tr></table></figure>

<p>在普通模式下，您可以使用<code>Ctrl-]</code>跳转到定义。在<code>two.rb</code>中，转到<code>one.donut</code>所在行，将光标移到<code>donut</code>处，按下<code>Ctrl-]</code>。</p>
<p>哦豁，Vim 找不到标签文件，您需要先生成它。</p>
<h2 id="标签生成器"><a href="#标签生成器" class="headerlink" title="标签生成器"></a>标签生成器</h2><p>现代 Vim 不自带标签生成器，您需要额外下载它。有几个选项可供选择：</p>
<ul>
<li>ctags &#x3D; 仅用于 C，基本随处可见。</li>
<li>exuberant ctags &#x3D; 最流行的标签生成器之一，支持许多语言。</li>
<li>universal ctags &#x3D; 和 exuberant ctags 类似，但比它更新。</li>
<li>etags &#x3D; 用于 Emacs，嗯……</li>
<li>JTags &#x3D; Java</li>
<li>ptags.py &#x3D; Python</li>
<li>ptags &#x3D; Perl</li>
<li>gnatxref &#x3D; Ada</li>
</ul>
<p>如果您查看 Vim 在线教程，您会发现许多都会推荐 <a target="_blank" rel="noopener" href="http://ctags.sourceforge.net/">exuberant ctags</a>，它支持 <a target="_blank" rel="noopener" href="http://ctags.sourceforge.net/languages.html">41 种编程语言</a>，我用过它，挺不错的。但自2009年以来一直没有维护，因此 Universal ctags 更好些，它和 exuberant ctags 相似，并仍在维护。</p>
<p>我不打算详细介绍如何安装 Universal ctags，您可以在 <a target="_blank" rel="noopener" href="https://github.com/universal-ctags/ctags">universal ctags</a> 仓库了解更多说明。</p>
<p>假设您已经安装好了ctags，接下来，生成一个基本的标签文件。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R .</span><br></pre></td></tr></table></figure>

<p> <code>R</code> 选项告诉 <code>ctags</code> 从当前位置 (<code>.</code>) 递归扫描文件。稍后，您应该在当前文件夹看到一个<code>tags</code> 文件，里面您将看到类似这样的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;&quot; to lines/</span><br><span class="line">!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/</span><br><span class="line">!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/</span><br><span class="line">!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/</span><br><span class="line">!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/</span><br><span class="line">!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//</span><br><span class="line">!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/</span><br><span class="line">!_TAG_PROGRAM_URL	&lt;https://ctags.io/&gt;	/official site/</span><br><span class="line">!_TAG_PROGRAM_VERSION	0.0.0	/b43eb39/</span><br><span class="line">One	one.rb	/^class One$/;&quot;	c</span><br><span class="line">donut	one.rb	/^  def donut$/;&quot;	f	class:One</span><br><span class="line">initialize	one.rb	/^  def initialize$/;&quot;	f	class:One</span><br></pre></td></tr></table></figure>

<p>根据 Vim 设置和 ctag 生成器的不同，您的<code>tags</code> 文件可能会有些不同。一个标签文件由两部分组成：标签元数据和标签列表。那些标签元数据 (<code>!TAG_FILE...</code>) 通常由 ctags 生成器控制。这里我不打算介绍它们，您可以随意查阅文档。标签列表是一个由所有定义组成的列表，由ctags建立索引。</p>
<p>现在回到 <code>two.rb</code>，将光标移至 <code>donut</code>，再输入<code>Ctrl-]</code>，Vim 将带您转到 <code>one.rb</code> 文件里<code>def donut</code> 所在的行上。成功啦！但 Vim 怎么做到的呢？</p>
<h2 id="解剖标签文件"><a href="#解剖标签文件" class="headerlink" title="解剖标签文件"></a>解剖标签文件</h2><p>来看看<code>donut</code> 标签项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">donut	one.rb	/^  def donut$/;&quot;	f	class:One</span><br></pre></td></tr></table></figure>

<p>上面的标签项由四个部分组成：一个<code>tagname</code>、一个<code>tagfile</code>、一个<code>tagaddress</code>，以及标签选项。</p>
<ul>
<li><code>donut</code> 是 <code>tagname</code>。当光标在 “donut” 时，Vim 搜索标签文件里含有 “donut” 字符串的一行。</li>
<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>
<li><code>/^ def donut$/</code> 是 <code>tagaddress</code>。<code>/.../</code> 是模式指示器。<code>^</code> 代表一行中第一个元素，后面跟着两个空格，然后是<code>def donut</code>字符串，最后 <code>$</code> 代表一行中最后一个元素。</li>
<li><code>f class:One</code> 是标签选项，它告诉 Vim，<code>donut</code> 是一种函数 (<code>f</code>)，并且是 <code>One</code> 类的一部分。</li>
</ul>
<p>再看看另一个标签项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One	one.rb	/^class One$/;&quot;	c</span><br></pre></td></tr></table></figure>

<p>这一行和 <code>donut</code>也是一样的：</p>
<ul>
<li><code>One</code> 是 <code>tagname</code>。注意，对于标签，第一次扫描区分大小写。如果列表中有 <code>One</code> 和 <code>one</code>， Vim 会优先考虑 <code>One</code> 而不是 <code>one</code>。</li>
<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>
<li><code>/^class One$/</code> 是 <code>tagaddress</code> 。Vim 会查找以 <code>class</code> 开头 (<code>^</code>) 、以 <code>One</code> 结尾 (<code>$</code>) 的行。</li>
<li><code>c</code> 是可用标签选项之一。由于 <code>One</code> 是一个 ruby 类而不是过程，因此被标签为 <code>c</code>。</li>
</ul>
<p>标签文件的内容可能不尽相同，根据您使用的标签生成器而定。但至少，标签文件必须具有以下格式之一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.  &#123;tagname&#125; &#123;TAB&#125; &#123;tagfile&#125; &#123;TAB&#125; &#123;tagaddress&#125;</span><br><span class="line">2.  &#123;tagname&#125; &#123;TAB&#125; &#123;tagfile&#125; &#123;TAB&#125; &#123;tagaddress&#125; &#123;term&#125; &#123;field&#125; ..</span><br></pre></td></tr></table></figure>

<h2 id="标签文件"><a href="#标签文件" class="headerlink" title="标签文件"></a>标签文件</h2><p>您知道，在运行 <code>ctags -R .</code> 后，一个新 <code>tags</code> 文件会被创建。但是，Vim 是如何知道在哪儿查找标签文件的呢？</p>
<p>如果运行 <code>:set tags?</code>，您可能会看见 <code>tags=./tags,tags</code>（根据您的 Vim 设置，内容可能有所不同）。对于 <code>./tags</code>，Vim 会在当前文件所在路径查找所有标签；对于 <code>tags</code>，Vim 会在当前目录（您的项目根路径）中查找。</p>
<p>此外，对于 <code>./tags</code>，Vim 会在当前文件所在路径内查找一个标签文件，无论它被嵌套得有多深。接下来，Vim 会在当前目录（项目根路径）查找。Vim 在找到第一个匹配项后会停止搜索。</p>
<p>如果您的 <code>&#39;tags&#39;</code> 文件是 <code>tags=./tags,tags,/user/iggy/mytags/tags</code>，那么 Vim 在搜索完 <code>./tags</code> 和 <code>tags</code> 目录后，还会在 <code>/user/iggy/mytags</code> 目录内查找。所以您可以分开存放标签文件，不必将它们置于项目文件夹中。</p>
<p>要添加标签文件位置，只需要运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set tags+=path/to/my/tags/file</span><br></pre></td></tr></table></figure>

<h2 id="为大型项目生成标签："><a href="#为大型项目生成标签：" class="headerlink" title="为大型项目生成标签："></a>为大型项目生成标签：</h2><p>如果您尝试在大型项目中运行 ctag，则可能需要很长时间，因为 Vim 也会查看每个嵌套目录。如果您是 Javascript 开发者，您会知道 <code>node_modules</code> 非常大。假设您有五个子项目，每个都包含自己的 <code>node_modules</code> 目录。一旦运行 <code>ctags -R .</code>，ctags 将尝试扫描这5个 <code>node_modules</code>。但您可能不需要为 <code>node_modules</code> 运行 ctag。</p>
<p>如果要排除 <code>node_modules</code> 后执行 ctags，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --exclude=node_modules .</span><br></pre></td></tr></table></figure>

<p>这次应该只需要不到一秒钟的时间。另外，您还可以多次使用 <code>exclude</code> 选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log .</span><br></pre></td></tr></table></figure>

<h2 id="标签导航"><a href="#标签导航" class="headerlink" title="标签导航"></a>标签导航</h2><p>仅使用 <code>Ctrl-]</code> 也挺好，但我们还可以多学几个技巧。其实，标签跳转键 <code>Ctrl-]</code> 还有命令行模式：<code>:tag my-tag</code>。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tag donut</span><br></pre></td></tr></table></figure>

<p>Vim 就会跳转至 <code>donut</code> 方法，就像在 “donut” 字符串上按 <code>Ctrl-]</code> 一样。您还可以使用 <code>&lt;Tab&gt;</code> 来自动补全参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tag d&lt;Tab&gt;</span><br></pre></td></tr></table></figure>

<p>Vim 会列出所有以 “d” 开头的标签。对于上面的命令，结果则是 “donut”。</p>
<p>在实际项目中，您可能会遇到多个同名的方法。我们来更新下这两个文件。先是 <code>one.rb</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## one.rb</span><br><span class="line">class One</span><br><span class="line">  def initialize</span><br><span class="line">    puts &quot;Initialized&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def donut</span><br><span class="line">    puts &quot;one donut&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def pancake</span><br><span class="line">    puts &quot;one pancake&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>然后 <code>two.rb</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## two.rb</span><br><span class="line">require &#x27;./one.rb&#x27;</span><br><span class="line"></span><br><span class="line">def pancake</span><br><span class="line">  &quot;Two pancakes&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">one = One.new</span><br><span class="line">one.donut</span><br><span class="line">puts pancake</span><br></pre></td></tr></table></figure>

<p>由于新添加了一些过程，因此编写完代码后，&#x3D;&#x3D;不要忘记运行 <code>ctags -R .</code>&#x3D;&#x3D;。现在，您有了两个 <code>pancake</code> 过程。如果您在 <code>two.rb</code> 内按下 <code>Ctrl-]</code>，会发生什么呢？</p>
<p>Vim 会跳转到 <code>two.rb</code> 内的 <code>def pancake</code>，而不是 <code>one.rb</code> 的 <code>def pancake</code>。这是因为 Vim 认为 <code>two.rb</code> 内部的 <code>pancake</code> 过程比其他的<code>pancake</code> 过程具有更高优先级。</p>
<h2 id="标签优先级"><a href="#标签优先级" class="headerlink" title="标签优先级"></a>标签优先级</h2><p>并非所有的标签都有着相同的地位。一些标签有着更高的优先级。如果有重复的标签项，Vim 会检查关键词的优先级。顺序是：</p>
<ol>
<li>当前文件中完全匹配的静态标签。</li>
<li>当前文件中完全匹配的全局标签。</li>
<li>其他文件中完全匹配的全局标签。</li>
<li>其他文件中完全匹配的静态标签。</li>
<li>当前文件中不区分大小写匹配的静态标签。</li>
<li>当前文件中不区分大小写匹配的全局标签。</li>
<li>其他文件中区分大小写匹配的全局标签。</li>
<li>当前文件中不区分大小写匹配的静态标签。</li>
</ol>
<p>根据优先级列表，Vim 会对在同一个文件上找到的精确匹配项进行优先级排序。这就是为什么 Vim 会选择 <code>two.rb</code> 里的 <code>pancake</code> 过程而不是 <code>one.rb</code> 里的。但是，上述优先级列表有些例外，取决于您的<code>&#39;tagcase&#39;</code>、<code>&#39;ignorecase&#39;</code>、<code>&#39;smartcase&#39;</code> 设置。我不打算介绍它们，您可以自行查阅 <code>:h tag-priority</code>。</p>
<h2 id="选择性跳转标签"><a href="#选择性跳转标签" class="headerlink" title="选择性跳转标签"></a>选择性跳转标签</h2><p>如果可以选择要跳转到哪个标签，而不是始终转到优先级最高的，那就太好了。因为您可能想跳转到 <code>one.rb</code> 里的 <code>pancake</code> 方法，而不是 <code>two.rb</code> 里的。现在您可以使用 <code>:tselect</code> 做到它！运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tselect pancake</span><br></pre></td></tr></table></figure>

<p>您可以在屏幕底部看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## pri kind tag               file</span><br><span class="line">1 F C f    pancake           two.rb</span><br><span class="line">             def pancake</span><br><span class="line">2 F   f    pancake           one.rb</span><br><span class="line">             class:One</span><br><span class="line">             def pancake</span><br></pre></td></tr></table></figure>

<p>如果输入<code>2</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>one.rb</code> 里的<code>pancake</code> 过程。如果输入<code>1</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>two.rb</code> 里的。</p>
<p>注意<code>pri</code> 列，第一个匹配中该列是<code>F C</code>，第二个匹配中则是<code>F</code>。这就是 Vim 用来确定标签优先级的凭据。<code>F C</code>表示在当前 (<code>C</code>) 文件中完全匹配 (<code>F</code>) 的全局标签。<code>F</code> 表示仅完全匹配 (<code>F</code>) 的全局标签。<code>F C</code> 的优先级永远比 <code>F</code> 高。<em>（译注：<code>F</code>是<code>Fully-matched</code>，<code>C</code>是<code>Current file</code>）</em></p>
<p>如果运行<code>:tselect donut</code>，即使只有一个标签可选，Vim 也会提示您选择跳转到哪一个。有没有什么方法可以让 Vim 仅在有多个匹配项时才提示标签列表，而只找到一个标签时就立即跳转呢？</p>
<p>当然！Vim 有一个 <code>:tjump</code> 方法。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tjump donut</span><br></pre></td></tr></table></figure>

<p>Vim 将立即跳转到 <code>one.rb</code> 里的<code>donut</code> 过程，就像在运行 <code>:tag donut</code> 一样。现在试试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tjump pancake</span><br></pre></td></tr></table></figure>

<p>Vim 将提示您从标签选项中选择一个，就像在运行<code>:tselect pancake</code>。<code>tjump</code> 能两全其美。</p>
<p><code>tjump</code> 在普通模式下有一个快捷键：<code>g Ctrl-]</code>。我个人喜欢<code>g Ctrl-]</code>胜过 <code>Ctrl-]</code>。</p>
<h2 id="标签的自动补全"><a href="#标签的自动补全" class="headerlink" title="标签的自动补全"></a>标签的自动补全</h2><p>标签能有助于自动补全。回想下第6章“插入模式”，您可以使用 <code>Ctrl-x</code> 子模式来进行各式自动补全。其中有一个我没有提到过的自动补全子模式便是 <code>Ctrl-]</code>。如果您在插入模式中输入<code>Ctrl-x Ctrl-]</code>，Vim 将使用标签文件来自动补全。</p>
<p>在插入模式下输入<code>Ctrl-x Ctrl-]</code>，您会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">donut</span><br><span class="line">initialize</span><br><span class="line">pancake</span><br></pre></td></tr></table></figure>

<h2 id="标签堆栈"><a href="#标签堆栈" class="headerlink" title="标签堆栈"></a>标签堆栈</h2><p>Vim 维持着一个标签堆栈，上面记录着所有您从哪儿来、跳哪儿去的标签列表。使用 <code>:tags</code> 可以看到这个堆栈。如果您首先跳转到<code>pancake</code>，紧接着是<code>donut</code>，此时运行<code>:tags</code>，您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">  1  1 pancake            10  ch16_tags/two.rb</span><br><span class="line">  2  1 donut               9  ch16_tags/two.rb</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>注意上面的 <code>&gt;</code> 符号，它代表着您当前在堆栈中的位置。要“弹出”堆栈，从而回到上一次的状态，您可以运行<code>:pop</code>。试试它，再运行<code>:tags</code>看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">  1  1 pancake            10  puts pancake</span><br><span class="line">&gt; 2  1 donut               9  one.donut</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意现在 <code>&gt;</code> 符号位于 <code>donut</code> 所在的第二行了。再 <code>pop</code> 一次，然后运行<code>:tags</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">&gt; 1  1 pancake            10  puts pancake</span><br><span class="line">  2  1 donut               9  one.donut</span><br></pre></td></tr></table></figure>

<p>在普通模式下，您可以按下 <code>Ctrl-t</code> 来达到和 <code>:pop</code> 一样的效果。</p>
<h2 id="自动生成标签"><a href="#自动生成标签" class="headerlink" title="自动生成标签"></a>自动生成标签</h2><p>Vim 标签最大的缺点之一是，每当进行重大改变时，您需要重新生成标签文件。如果您将<code>pancake</code> 过程重命名为 <code>waffle</code>，标签文件不知道 <code>pancake</code> 被重命名了，标签列表仍旧存储着 <code>pancake</code> 过程。运行<code>ctags -R .</code> 可以创建更新的标签文件，但这可能会很缓慢。</p>
<p>幸运的是，有几种可以自动生成标签的方法。这一小节不打算介绍一个简单明了的过程，而是提出一些想法，以便您可以扩展它们。</p>
<h2 id="在保存时生成标签"><a href="#在保存时生成标签" class="headerlink" title="在保存时生成标签"></a>在保存时生成标签</h2><p>Vim 有一个自动命令 (<code>autocmd</code>) 方法，可以在触发事件时执行任意命令。您可以使用这个方法，以便在每次保存时生成标签。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufWritePost *.rb silent !ctags -R .</span><br></pre></td></tr></table></figure>

<p>上面命令的分解如下：</p>
<ul>
<li><code>autocmd</code> 是 Vim 的自动命令方法，它接受一个事件名称、文件和一个命令。</li>
<li><code>BufWritePost</code> 是保存缓冲区时的一个事件。每次保存文件时将触发一次 <code>BufWritePost</code> 事件。</li>
<li><code>.rb</code> 是 ruby (<code>rb</code>) 文件的一种文件模式。</li>
<li>&#x3D;&#x3D;<code>silent</code> 是您传递的命令的一部分。如果不输入它，每次触发自动命令时，Vim 都会提示  <code>press ENTER or type command to continue</code>。&#x3D;&#x3D;</li>
<li><code>!ctags -R .</code> 是要执行的命令。回想一下，<code>!cmd</code> 从 Vim 内部执行终端命令。</li>
</ul>
<p>现在，每次您保存一个 ruby 文件时，Vim 都会运行<code>ctags -R .</code>。</p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>有几种插件可以自动生成 ctags：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ludovicchabant/vim-gutentags">vim-gutentags</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/szw/vim-tags">vim-tags</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xolox/vim-easytags">vim-easytags</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/craigemery/vim-autotag">vim-autotag</a></li>
</ul>
<p>我使用 &#x3D;&#x3D;vim-gutentags&#x3D;&#x3D;。它的使用方法很简单，而且装上就可以直接使用。</p>
<h2 id="Ctags-以及-Git-钩子"><a href="#Ctags-以及-Git-钩子" class="headerlink" title="Ctags 以及 Git 钩子"></a>Ctags 以及 Git 钩子</h2><p>Tim Pope 是一个写了很多非常棒的 Vim 插件的作者，他写了一篇博客，建议使用 git 钩子。<a target="_blank" rel="noopener" href="https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html">可以看一看</a>。</p>
<h2 id="聪明地学习标签"><a href="#聪明地学习标签" class="headerlink" title="聪明地学习标签"></a>聪明地学习标签</h2><p>只要配置得当，标签是非常有用的。假设在一个新的代码库中，您想要搞清楚 <code>functionFood</code> 干了什么，您可以通过跳转到它的定义来搞懂它们。在那儿可以看到，它又调用了 <code>functionBreakfast</code>。继续跟踪，发现还调用了 <code>functionPancake</code>。现在您明白了，函数调用路径图长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionFood -&gt; functionBreakfast -&gt; functionPancake</span><br></pre></td></tr></table></figure>

<p>进一步可以知道，这段代码和早餐吃煎饼有关。</p>
<p>现在您已经知道如何使用标签，通过 <code>:h tags</code> 可以学习更多有关标签的知识。接下来让我们一起来探索另一个功能：折叠。</p>
<h1 id="第17章-折叠"><a href="#第17章-折叠" class="headerlink" title="第17章 折叠"></a>第17章 折叠</h1><p>在阅读文件时，经常会有一些不相关的文本会妨碍您理解。使用 Vim 折叠可以隐藏这些不必要的信息。</p>
<p>本章中，您将学习如何使用不同的折叠方法。</p>
<h2 id="手动折叠"><a href="#手动折叠" class="headerlink" title="手动折叠"></a>手动折叠</h2><p>想象您正在折叠一张纸来覆盖一些文本，实际的文本不会消失，它仍在那儿。Vim 折叠的工作方式与此相同，它<em>折叠</em>一段文本，在显示时会隐藏起来，但实际上并不会真的删除它。</p>
<p>折叠操作符是<code>z</code>。（折叠纸张时，它看起来也像字母 “z”）。</p>
<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fold me</span><br><span class="line">Hold me</span><br></pre></td></tr></table></figure>

<p>把光标放在第一行，输入 <code>zfj</code>。Vim 将这两行折叠成一行，同时会看到类似消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+-- 2 lines: Fold me -----</span><br></pre></td></tr></table></figure>

<p>上面的命令分解如下：</p>
<ul>
<li><code>zf</code> 是折叠操作符。</li>
<li><code>j</code> 是用于折叠操作符的动作。</li>
</ul>
<p>您可以使用 <code>zo</code> 打开&#x2F;展开已折叠文本，使用 <code>zc</code> 关闭&#x2F;收缩文本。</p>
<p>折叠是一个操作符，所以它遵循语法规则（<code>动词+名词</code>）。您可以在折叠运算符后，加上一个动作(motion)或文本对象。例如，使用 <code>zfip</code> 可以折叠内部段落；使用 <code>zfG</code> 可以折叠至文件末尾；使用 <code>zfa&#123;</code> 可以折叠 <code>&#123;</code> 和 <code>&#125;</code> 之间的文本。</p>
<p>您可以在可视模式下进行折叠。高亮您想要折叠的区域后 (<code>v</code>, <code>V</code>, 或 <code>Ctrl-v</code>)，再输入 <code>zf</code> 即可。</p>
<p>您也可以在命令行模式下，使用 <code>:fold</code> 命令执行一次折叠。若要折叠当前行及紧随其后的第二行，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:,+1fold</span><br></pre></td></tr></table></figure>

<p><code>,+1</code> 是要折叠的范围。如果不传递范围参数，默认当前行。<code>+1</code> 是代表下一行的范围指示器。运行 <code>:5,10fold</code> 可以折叠第5至10行。运行 <code>:,$fold</code> 可以折叠当前行至文件末尾。</p>
<p>还有许多其他折叠和展开的命令。我发现他们实在太多，以至于在刚起步时很难记住。最有用的一些命令是：</p>
<ul>
<li><code>zR</code> 展开所有折叠。</li>
<li><code>zM</code> 收缩所有折叠。</li>
<li><code>za</code> 切换折叠状态。</li>
</ul>
<p><code>zR</code> 和 <code>zM</code> 可用于任意行上，但 <code>za</code> 仅能用于已折叠&#x2F;未折叠的行上。输入 <code>:h fold-commands</code> 可查阅更多有关折叠的指令。</p>
<h2 id="不同的折叠方法"><a href="#不同的折叠方法" class="headerlink" title="不同的折叠方法"></a>不同的折叠方法</h2><p>以上部分涵盖了 Vim 手动折叠的内容。实际上，Vim 有六种不同的折叠方法：</p>
<ol>
<li>手动折叠</li>
<li>缩进折叠</li>
<li>表达式折叠</li>
<li>语法折叠</li>
<li>差异折叠</li>
<li>标志折叠</li>
</ol>
<p>运行 <code>:set foldmethod?</code> 可查看您当前正在使用哪一种折叠方式。默认情况下，Vim 使用手动方式。</p>
<p>在本章的剩余部分，您将学习其他五种折叠方法。让我们从缩进折叠开始。</p>
<h2 id="缩进折叠"><a href="#缩进折叠" class="headerlink" title="缩进折叠"></a>缩进折叠</h2><p>要使用缩进折叠，需要将 <code>&#39;foldmethod&#39;</code> 选项更改为缩进：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=indent</span><br></pre></td></tr></table></figure>

<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br></pre></td></tr></table></figure>

<p>运行 <code>:set foldmethod=indent</code> 后将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">+-- 2 lines: Two -----</span><br></pre></td></tr></table></figure>

<p>使用缩进折叠后，Vim 将会查看每行的开头有多少空格，并将它与 <code>&#39;shiftwidth&#39;</code> 选项进行比较，以此来决定该行可折叠性。<code>&#39;shiftwidth&#39;</code> 返回每次缩进所需的空格数。如果运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth?</span><br></pre></td></tr></table></figure>

<p>Vim 的默认 <code>&#39;shiftwidth&#39;</code> 值为2。对于上面的文本而言，”Two” 和 “Two again” 的开头都有两个空格。当 Vim 看到了空格数 <em>且</em> <code>&#39;shiftwidth&#39;</code>值都为2时，Vim 认为该行的缩进折叠级别为1。</p>
<p>假设这次文本开头只有一个空格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line"> Two</span><br><span class="line"> Two again</span><br></pre></td></tr></table></figure>

<p>运行 <code>:set foldmethod=indent</code> 后，Vim 不再折叠已缩进的行了，因为这些行没有足够的空格。1个空格不会被视作一个缩进。然而，当您改变 <code>&#39;shiftwidth&#39; </code> 的值为1后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth=1</span><br></pre></td></tr></table></figure>

<p>文本现在可以折叠了！现在一个空格将被视为一个缩进。</p>
<p>现在，我们将 <code>&#39;shiftwidth&#39; </code> 以及文本开头的空格数都重新恢复为2后，另外添加一些内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br><span class="line">    Three</span><br><span class="line">    Three again</span><br></pre></td></tr></table></figure>

<p>运行折叠命令 (<code>zM</code>) 后可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">+-- 4 lines: Two -----</span><br></pre></td></tr></table></figure>

<p>展开已折叠的行 (<code>zR</code>)，接着移动光标至 “Three”，然后切换文本的折叠状态 (<code>za</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br><span class="line">+-- 2 lines: Three -----</span><br></pre></td></tr></table></figure>

<p>这是啥？叠中叠？</p>
<p>是的，您可以嵌套折叠。文本 “Two” 和 “Two again” 的折叠级别都为1，文本 “Three” 和 “Three again” 的折叠级别都为2。如果在一段可折叠文本中，具有另一段折叠级别更高的可折叠文本，则可以具有多个折叠层。</p>
<h2 id="表达式折叠"><a href="#表达式折叠" class="headerlink" title="表达式折叠"></a>表达式折叠</h2><p>表达式折叠允许您定义要匹配折叠的表达式。定义折叠表达式后，Vim 会计算每行的 <code>&#39;foldexpr&#39;</code> 值。这是必须配置的变量，它要返回适当的值。如果返回 0，则不折叠行。如果它返回 1，则该行的折叠级别为 1。如果它返回 2，则该线的折叠级别为 2。除了整数外还有其他的值，但我不打算介绍它们。如果你好奇，可以查阅<code>:h fold-expr</code>。</p>
<p>首先，更改折叠方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=expr</span><br></pre></td></tr></table></figure>

<p>假设您有一份早餐食品列表，并且想要折叠所有以 “p” 开头的早餐项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">donut</span><br><span class="line">pancake</span><br><span class="line">pop-tarts</span><br><span class="line">protein bar</span><br><span class="line">salmon</span><br><span class="line">scrambled eggs</span><br></pre></td></tr></table></figure>

<p>其次，更改 <code>foldexpr</code> 为捕获以 “p” 开头的表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldexpr=getline(v:lnum)[0]==\\&quot;p\\&quot;</span><br></pre></td></tr></table></figure>

<p>这表达式看起来有点吓人。我们来分解下：</p>
<ul>
<li><code>:set foldexpr</code> 设置 <code>&#39;foldexpr&#39;</code> 为自定义表达式。</li>
<li><code>getline()</code> 是 Vim 脚本的一个函数，它返回指定行的内容。如运行 <code>:echo getline(5)</code> 可以获取第5行的内容。</li>
<li><code>v:lnum</code> 是 Vim <code>&#39;foldexpr&#39;</code> 表达式的特殊变量。Vim 在扫描每一行时，都会将行号存储至 <code>v:lnum</code> 变量。在第5行，<code>v:lnum</code> 值为5。在第10行，<code>v:lnum</code>值为10。</li>
<li><code>[0]</code> 处于 <code>getline(v:lnum)[0]</code> 语境时，代表每一行的第一个字符。Vim 在扫描某一行时，<code>getline(v:lnum)</code> 返回该行的内容，而 <code>getline(v:lnum)[0]</code> 则返回这一行的第一个字符。例如，我们早餐食品列表的第一行是 “donut”，则 <code>getline(v:lnum)[0]</code> 返回 “d”；列表的第二行是 “pancake”，则 <code>getline(v:lnum)[0]</code> 返回 “p”。</li>
<li><code>==\\&quot;p\\&quot;</code> 是等式表达式的后半部分，它检查刚才表达式的计算结果是否等于 “p”。如果是，则返回1，否则返回0。在 Vim 的世界里，1代表真，0代表假。所以，那些以 “p” 开头的行，表达式都会返回1。回想一下本节的开始，如果 <code>&#39;foldexpr&#39;</code> 的值为1，则折叠级别为1。</li>
</ul>
<p>在运行这个表达式后，您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">donut</span><br><span class="line">+-- 3 lines: pancake -----</span><br><span class="line">salmon</span><br><span class="line">scrambled eggs</span><br></pre></td></tr></table></figure>

<h2 id="语法折叠"><a href="#语法折叠" class="headerlink" title="语法折叠"></a>语法折叠</h2><p>语法折叠是由Vim的语法高亮决定的。如果您使用了语法高亮插件，比如<a target="_blank" rel="noopener" href="https://github.com/sheerun/vim-polyglot">vim-polyglot</a>，那么装上插件就可以直接使用语法折叠。仅仅需要将<code>foldmethod</code>选项改为 <code>syntax</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=syntax</span><br></pre></td></tr></table></figure>

<p>假设您正在编辑一个JavaScript文件，而且您已经装好了 vim-polyglot 插件。如果您有以下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const nums = [</span><br><span class="line">  one,</span><br><span class="line">  two,</span><br><span class="line">  three,</span><br><span class="line">  four</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>上述文本将会使用语法折叠折起来。当您为某个特定语言（位于 <code>syntax/</code> 目录中的语言即是典型例子）定义了语法高亮，您可以添加一个 <code>fold</code> 属性，使它支持折叠。下面是 vim-polyglot 中JavaScript语法文件中的一个片段。注意最后的 <code>fold</code> 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntax region  jsBracket                      matchgroup=jsBrackets            start=/\[/ end=/\]/ contains=@jsExpression,jsSpreadExpression extend fold</span><br></pre></td></tr></table></figure>

<p>本书不会详细介绍 <code>syntax</code> 功能。如果您感兴趣，可以查阅 <code>:h syntax.txt</code>。</p>
<h2 id="差异折叠"><a href="#差异折叠" class="headerlink" title="差异折叠"></a>差异折叠</h2><p>Vim 可以对多个文件进行差异比较。</p>
<p>如果您有 <code>file1.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br></pre></td></tr></table></figure>

<p>以及 <code>file2.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">emacs is ok</span><br></pre></td></tr></table></figure>

<p>运行 <code>vimdiff file1.txt file2.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-- 3 lines: vim is awesome -----</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">[vim is awesome] / [emacs is ok]</span><br></pre></td></tr></table></figure>

<p>Vim 会自动折叠一些相同的行。运行 <code>vimdiff</code> 命令时，Vim 会自动使用 <code>foldmethod=diff</code>。此时如果运行 <code>:set foldmethod?</code>，它将返回 <code>diff</code>。</p>
<h2 id="标志折叠"><a href="#标志折叠" class="headerlink" title="标志折叠"></a>标志折叠</h2><p>要使用标志折叠，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmethod=marker</span><br></pre></td></tr></table></figure>

<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#123;</span><br><span class="line">world</span><br><span class="line">vim</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输入 <code>zM</code> 后会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line">+-- 4 lines: -----</span><br></pre></td></tr></table></figure>

<p>Vim 将 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 视为折叠指示器，并折叠其中的内容。使用标志折叠时，Vim 会寻找由 <code>&#39;foldmarker&#39;</code> 选项定义的特殊标志，并标记折叠区域。要查看 Vim 使用的标志，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmarker?</span><br></pre></td></tr></table></figure>

<p>默认情况下，Vim 把 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 作为指示器。如果您想将指示器更改为其他诸如 “coffee1” 和 “coffee2” 的字符串，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set foldmarker=coffee1,coffee2</span><br></pre></td></tr></table></figure>

<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line">coffee1</span><br><span class="line">world</span><br><span class="line">vim</span><br><span class="line">coffee2</span><br></pre></td></tr></table></figure>

<p>现在，Vim 将使用 <code>coffee1</code> 和 <code>coffee2</code> 作为新折叠标志。注意，指示器必须是文本字符串，不能是正则表达式。</p>
<h2 id="持久化折叠"><a href="#持久化折叠" class="headerlink" title="持久化折叠"></a>持久化折叠</h2><p>当关闭 Vim 会话后，您将失去所有的折叠信息。假设您有 <code>count.txt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br></pre></td></tr></table></figure>

<p>手动从第三行开始往下折叠 (<code>:3,$fold</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">+-- 3 lines: three ---</span><br></pre></td></tr></table></figure>

<p>当您退出 Vim 再重新打开 <code>count.txt</code> 后，这些折叠都不见了！</p>
<p>要在折叠后保留它们，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview</span><br></pre></td></tr></table></figure>

<p>当打开 <code>count.txt</code> 后，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure>

<p>您的折叠信息都被保留下来了。然而，您需要手动运行 <code>mkview</code> 和 <code>loadview</code>。我知道，终有一日，我会忘记运行 <code>mkview</code> 就关闭文件了，接着便会丢失所有折叠信息。能不能自动实现这个呢？</p>
<p>当然能！要在关闭 <code>.txt</code> 文件时自动运行 <code>mkview</code>，以及在打开 <code>.txt</code> 文件后自动运行 <code>loadview</code>，将下列内容添加至您的 vimrc：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufWinLeave *.txt mkview</span><br><span class="line">autocmd BufWinEnter *.txt silent loadview</span><br></pre></td></tr></table></figure>

<p>在上一章您已经见过 <code>autocmd</code> 了，它用于在事件触发时执行一条命令。这里的两个事件是：</p>
<ul>
<li><code>BufWinLeave</code> 从窗口中删除缓冲时。</li>
<li><code>BufWinEnter</code> 在窗口中加载缓冲时。</li>
</ul>
<p>现在，即使您在 <code>.txt</code> 文件内折叠内容后直接退出 Vim，下次再打开该文件时，您的折叠信息都能自动恢复。</p>
<p>默认情况下，当运行 <code>mkview</code> 时，Vim将折叠信息保存在<code>~/.vim/view</code> (Unix 系统)。您可以查阅 <code>:h &#39;viewdir&#39;</code> 来了解更多信息。</p>
<h2 id="聪明地学习折叠"><a href="#聪明地学习折叠" class="headerlink" title="聪明地学习折叠"></a>聪明地学习折叠</h2><p>当我刚开始使用 Vim 时， 我会跳过学习 Vim 折叠，因为我觉得它不太实用。然而，随着我码龄的增长，我越发觉得折叠功能大有用处。得当地使用折叠功能，文本结构可以更加清晰，犹如一本书籍的目录。</p>
<p>当您学习折叠时，请从手动折叠开始，因为它可以随学随用。然后逐渐学习不同的技巧来使用缩进和标志折叠。最后，学习如何使用语法和表达式折叠。您甚至可以使用后两个来编写您自己的 Vim 插件。</p>
<h1 id="第18章-Git"><a href="#第18章-Git" class="headerlink" title="第18章 Git"></a>第18章 Git</h1><p>Vim 和 Git 是两种实现不同功能的伟大工具。Vim 用于文本编辑，Git 用于版本控制。</p>
<p>在本章中，您将学习如何将 Vim 和 Git 集成在一起。</p>
<h2 id="差异比较"><a href="#差异比较" class="headerlink" title="差异比较"></a>差异比较</h2><p>在上一章中，您看到了如何运行 <code>vimdiff</code> 命令以显示多个文件之间的差异。</p>
<p>假设您有两个文件，<code>file1.txt</code> 和 <code>file2.txt</code>。</p>
<p><code>file1.txt</code> 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">apples</span><br><span class="line"></span><br><span class="line">milk</span><br><span class="line">apple juice</span><br><span class="line"></span><br><span class="line">yogurt</span><br></pre></td></tr></table></figure>

<p><code>file2.txt</code> 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">oranges</span><br><span class="line"></span><br><span class="line">milk</span><br><span class="line">orange juice</span><br><span class="line"></span><br><span class="line">yogurt</span><br></pre></td></tr></table></figure>

<p>若要查看两个文件之间的差异，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p>或者也可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -d file1.txt file2.txt</span><br></pre></td></tr></table></figure>

<p align="center">
  <img alt="Basic diffing with Vim" width="900" height="auto" data-src="images/diffing-basic.png">
</p>

<p><code>vimdiff</code> 并排显示两个缓冲区。左边是 <code>file1.txt</code>，右边是 <code>file2.txt</code>。不同的两行（apples 和 oranges）会被高亮显示。</p>
<p>假设您要使第二个缓冲区相应位置变成 apples，而不是 oranges。若想从 <code>file1.txt</code> 传输您当前位置（当前您在 <code>file1.txt</code>）的内容到 <code>file2.txt</code>，首先使用 <code>]c</code> 跳转到下一处差异（使用 <code>[c</code> 可跳回上一处差异），现在光标应该在 apples 上了。接着运行 <code>:diffput</code>。此时，这两个文件都是 apples 了。</p>
<p align="center">
  <img alt="Finding files in FZF" width="900" height="auto" data-src="images/diffing-apples.png">
</p>

<p>如果您想从另一个缓冲区（orange juice，<code>file2.txt</code>）传输文本来替代当前缓冲区（apple juice，<code>file1.txt</code>），让您的光标仍然位于 <code>file1.txt</code> 的窗口中，首先使用 <code>]c</code> 跳转至下一处差异，此时光标应该在 apple juice 上。接着运行 <code>:diffget</code> 获取另一个缓冲区的 orange juice 来替代当前缓冲区中的 apple juice。</p>
<p><code>:diffput</code> 将文本从当前缓冲区 <em>输出</em> 到另一个缓冲区。<code>:diffget</code> 从另一个缓冲区 <em>获取</em> 文本到当前缓冲区。</p>
<p>如果有多个缓冲区，可以运行 <code>:diffput fileN.txt</code> 和 <code>:diffget fileN.txt</code> 来指定目标缓冲区 fileN。</p>
<h2 id="使用-Vim-作为合并工具"><a href="#使用-Vim-作为合并工具" class="headerlink" title="使用 Vim 作为合并工具"></a>使用 Vim 作为合并工具</h2><blockquote>
<p>“我非常喜欢解决合并冲突。” ——佚名</p>
</blockquote>
<p>我不知道有谁喜欢解决合并冲突，但总之，合并冲突是无法避免的。在本节中，您将学习如何利用 Vim 作为解决合并冲突的工具。</p>
<p>首先，运行下列命令来将默认合并工具更改为 <code>vimdiff</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config merge.tool vimdiff</span><br><span class="line">git config merge.conflictstyle diff3</span><br><span class="line">git config mergetool.prompt false</span><br></pre></td></tr></table></figure>

<p>或者您也可以直接修改 <code>~/.gitconfig</code>（默认情况下，它应该处于根目录中，但您的可能在不同的位置）。上面的命令应该会将您的 <code>gitconfig</code> 改成如下设置的样子，如果您还没有运行上面的命令，您也可以手动更改您的 gitconfig。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">  editor = vim</span><br><span class="line">[merge]</span><br><span class="line">  tool = vimdiff</span><br><span class="line">  conflictstyle = diff3</span><br><span class="line">[difftool]</span><br><span class="line">  prompt = false</span><br></pre></td></tr></table></figure>

<p>让我们创建一个假的合并冲突来测试一下。首先创建一个目录 <code>/food</code>，并初始化 git 仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>添加 <code>breakfast.txt</code> 文件，内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">oranges</span><br></pre></td></tr></table></figure>

<p>添加文件并提交它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial breakfast commit&quot;</span><br></pre></td></tr></table></figure>

<p>接着，创建一个新分支 apples：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b apples</span><br></pre></td></tr></table></figure>

<p>更改 <code>breakfast.txt</code> 文件为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">apples</span><br></pre></td></tr></table></figure>

<p>保存文件，添加并提交更改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Apples not oranges&quot;</span><br></pre></td></tr></table></figure>

<p>真棒！现在 master 分支有 oranges，而 apples 分支有 apples。接着回到 master 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p>在 <code>breakfast.txt</code> 文件中，您应该能看到原来的文本 oranges。接着将它改成 grapes，因为它是现在的应季水果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">grapes</span><br></pre></td></tr></table></figure>

<p>保存、添加、提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Grapes not oranges&quot;</span><br></pre></td></tr></table></figure>

<p>嚯！这么多步骤！现在准备要将 apples 分支合并进 master 分支了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge apples</span><br></pre></td></tr></table></figure>

<p>您应该会看到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging breakfast.txt</span><br><span class="line">CONFLICT (content): Merge conflict in breakfast.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>没错，一个冲突！现在一起来用一下新配置的 <code>mergetool</code> 来解决冲突吧！运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure>

<p align="center">
  <img alt="Three-way mergetool with Vim" width="900" height="auto" data-src="images/mergetool-initial.png">
</p>

<p>Vim 显示了四个窗口。注意一下顶部三个：</p>
<ul>
<li><code>LOCAL</code> 包含了 <code>grapes</code>。这是“本地”中的变化，也是您要合并的内容。</li>
<li><code>BASE</code> 包含了 <code>oranges</code>。这是 <code>LOCAL</code> 和 <code>REMOTE</code> 的共同祖先，用于比较它们之间的分歧。</li>
<li><code>REMOTE</code> 包含了 <code>apples</code>。这是要被合并的内容。</li>
</ul>
<p>底部窗口（也即第四个窗口），您能看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">grapes</span><br><span class="line">||||||| db63958</span><br><span class="line">oranges</span><br><span class="line">=======</span><br><span class="line">apples</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; apples</span><br></pre></td></tr></table></figure>

<p>第四个窗口包含了合并冲突文本。有了这步设置，就能更轻松看到哪个环境发生了什么变化。您可以同时查看 <code>LOCAL</code>、<code>BASE</code> 和 <code>REMOTE</code> 的内容。</p>
<p>您的光标应该在第四个窗口的高亮区域。再运行 <code>:diffget LOCAL</code>，就可以<em>获取</em>来自 <code>LOCAL</code> 的改变（grapes）。同样，运行 <code>:diffget BASE</code> 可以获取来自 <code>BASE</code> 的改变（oranges），而运行 <code>:diffget REMOTE</code> 可以获取来自 <code>REMOTE</code> 的改变（apples）。</p>
<p>在这个例子中，我们试着获取来自 <code>LOCAL</code> 的改变。运行 <code>:diffget LO</code>（<code>LOCAL</code> 的简写），第四个窗口变成了 grapes。完成后，就可以保存并退出所有文件（<code>:wqall</code>）了。还不错吧？</p>
<p>稍加留意您会发现，现在多了一个 <code>breakfast.txt.orig</code> 文件。这是 Git 防止事与愿违而创建的备份文件。如果您不希望 Git 在合并期间创建备份文件，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global mergetool.keepBackup false</span><br></pre></td></tr></table></figure>

<h2 id="在-Vim-中使用-Git"><a href="#在-Vim-中使用-Git" class="headerlink" title="在 Vim 中使用 Git"></a>在 Vim 中使用 Git</h2><p>Vim 本身没有集成 Git，要在 Vim 中执行 Git 命令，一种方法是在命令行模式中使用 <code>!</code> 叹号运算符。</p>
<p>使用 <code>!</code> 可以运行任何 Git 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:!git status</span><br><span class="line">:!git commit</span><br><span class="line">:!git diff</span><br><span class="line">:!git push origin master</span><br></pre></td></tr></table></figure>

<p>您还可以使用 Vim 的特殊字符 <code>%</code> (当前缓冲区) 或 <code>#</code> (其他缓冲区)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:!git add %         &quot; git add current file</span><br><span class="line">:!git checkout #    &quot; git checkout the other file</span><br></pre></td></tr></table></figure>

<p>这里有一个Vim技巧，您可以用来添加不同Vim窗口中的多个文件，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windo !git add %</span><br></pre></td></tr></table></figure>

<p>然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!git commit &quot;添加了Vim窗口中的所有文件，酷&quot;</span><br></pre></td></tr></table></figure>

<p><code>windo</code>命令是VIm的 “do” 命令其中之一，类似于您前面看到的 <code>argdo</code> 。<code>windo</code> 将命令执行在每一个窗口中。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>这里有很多提供git支持的Vim插件。以下是 Vim 中较流行的 Git 相关插件列表（您读到这篇文章时可能又有更多）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/airblade/vim-gitgutter">vim-gitgutter</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mhinz/vim-signify">vim-signify</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tpope/vim-fugitive">vim-fugitive</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/junegunn/gv.vim">gv.vim</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jreybert/vimagit">vimagit</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sodapopcan/vim-twiggy">vim-twiggy</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tpope/vim-rhubarb">rhubarb</a></li>
</ul>
<p>其中最流行的是 vim-fugitive。本章的剩余部分，我将使用此插件来介绍几个 git 工作流。</p>
<h2 id="Vim-Fugitive"><a href="#Vim-Fugitive" class="headerlink" title="Vim-Fugitive"></a>Vim-Fugitive</h2><p>vim-fugitive 插件允许您在不离开 Vim 编辑器的情况下运行 git 命令行界面。您会发现，有些命令在 Vim 内部执行时会更好。</p>
<p>开始前，请先使用 Vim 插件管理器（<a target="_blank" rel="noopener" href="https://github.com/junegunn/vim-plug">vim-plug</a>、<a target="_blank" rel="noopener" href="https://github.com/VundleVim/Vundle.vim">vundle</a>、<a target="_blank" rel="noopener" href="https://github.com/Shougo/dein.vim">dein.vim</a> 等）安装 vim-fugitive。</p>
<h2 id="Git-Status"><a href="#Git-Status" class="headerlink" title="Git Status"></a>Git Status</h2><p>当您不带参数地运行 <code>:Git</code> 命令时，vim-fugitive 将显示一个 git 概要窗口，它显示了未跟踪、未暂存和已暂存的文件。在此 “<code>git status</code>” 模式下，您可以做一些操作：</p>
<ul>
<li><code>Ctrl-n</code> &#x2F; <code>Ctrl-p</code> 转到下一个 &#x2F; 上一个文件。</li>
<li><code>-</code> 暂存或取消暂存光标处的文件。</li>
<li><code>s</code> 暂存光标处的文件。</li>
<li><code>u</code> 取消暂存光标处的文件。</li>
<li><code>&gt;</code> &#x2F; <code>&lt;</code> 内联显示或隐藏光标处文件的差异变化。</li>
</ul>
<p align="center">
  <img alt="Finding files in FZF" width="900" height="auto" data-src="images/fugitive-git.png">
</p>

<p>查阅 <code>:h fugitive-staging-maps</code> 可获得更多信息。</p>
<h2 id="Git-Blame"><a href="#Git-Blame" class="headerlink" title="Git Blame"></a>Git Blame</h2><p>在当前文件运行 <code>:Git blame</code> 命令，vim-fugitive 可以显示一个拆分的问责窗口。这有助于追踪那些 BUG 是谁写的，接着就可以冲他&#x2F;她怒吼（开个玩笑）。</p>
<p>在  <code>&quot;git blame&quot;</code> 模式下您可以做：</p>
<ul>
<li><code>q</code> 关闭问责窗口。</li>
<li><code>A</code> 调整作者列大小。</li>
<li><code>C</code> 调整提交列大小。</li>
<li><code>D</code> 调整日期&#x2F;时间列大小。</li>
</ul>
<p>查阅 <code>:h :Git_blame</code> 可获得更多信息。</p>
<p align="center">
  <img alt="Finding files in FZF" width="900" height="auto" data-src="images/fugitive-git-blame.png">
</p>

<h2 id="Gdiffsplit"><a href="#Gdiffsplit" class="headerlink" title="Gdiffsplit"></a>Gdiffsplit</h2><p>当您运行 <code>:Gdiffsplit</code> 命令后，vim-fugitive 会执行 <code>vimdiff</code>，比对索引或工作树中的版本与当前文件最新更改的区别。如果运行 <code>:Gdiffsplit &lt;commit&gt;</code>，vim-fugitive 则会根据 <code>&lt;commit&gt;</code> 中的版本来执行 <code>vimdiff</code>。</p>
<p align="center">
  <img alt="Finding files in FZF" width="900" height="auto" data-src="images/fugitive-gdiffsplit.png">
</p>

<p>由于您处于 <code>vimdiff</code> 模式中，因此您可以使用 <code>:diffput</code> 和 <code>:diffget</code> 来 <em>获取</em> 或 <em>输出</em> 差异。</p>
<h2 id="Gwrite-和-Gread"><a href="#Gwrite-和-Gread" class="headerlink" title="Gwrite 和 Gread"></a>Gwrite 和 Gread</h2><p>当您在更改文件后运行 <code>:Gwrite</code> 命令，vim-fugitive 将暂存更改，就像运行 <code>git add &lt;current-file&gt;</code> 一样。</p>
<p>当您在更改文件后运行 <code>:Gread</code> 命令，vim-fugitive 会将文件还原至更改前的状态，就像运行 <code>git checkout &lt;current-file&gt;</code> 一样。使用 <code>:Gread</code> 还有一个好处是操作可撤销。如果在运行 <code>:Gread</code> 后您改变主意，想要保留原来的更改，您只需要撤消（<code>u</code>），Vim 将撤回 <code>:Gread</code> 操作。要换作是在命令行中运行 <code>git checkout &lt;current-file&gt;</code>，就完成不了这种操作了。</p>
<h2 id="Gclog"><a href="#Gclog" class="headerlink" title="Gclog"></a>Gclog</h2><p>当您运行 <code>:Gclog</code> 命令时，vim-fugitive 将显示提交历史记录，就像运行 <code>git log</code> 命令一样。Vim-fugitive 使用 Vim 的 quickfix 来完成此任务，因此您可以使用 <code>:cnext</code> 和 <code>:cprevious</code> 来遍历下一个或上一个日志信息。您还可以使用 <code>:copen</code> 和 <code>:cclose</code> 打开或关闭日志列表。</p>
<p align="center">
  <img alt="Finding files in FZF" width="900" height="auto" data-src="images/fugitive-git-log.png">
</p>

<p>在 <code>&quot;git log&quot;</code> 模式中，您可以做两件事：</p>
<ul>
<li>查看树。</li>
<li>访问父级（上一个提交）。</li>
</ul>
<p>您可以像 <code>git log</code> 命令一样，传递参数给 <code>:Gclog</code> 命令。如果您项目的提交历史记录很长，只想看最后三个提交，则可以运行 <code>:Gclog -3</code>。如果需要根据提交日期来筛选记录，可以运行类似 <code>:Gclog --after=&quot;January 1&quot; --before=&quot;March 14&quot;</code> 的命令。</p>
<h2 id="Vim-Fugitive-的更多功能"><a href="#Vim-Fugitive-的更多功能" class="headerlink" title="Vim-Fugitive 的更多功能"></a>Vim-Fugitive 的更多功能</h2><p>以上只是寥寥几个 vim-fugitive 功能的例子，您可以查阅 <code>:h fugitive.txt</code> 来了解更多有关 vim-fugitive 的信息。大多数流行的 git 命令可能都有 vim-fugitive 的优化版本，您只需在文档中查找它们。</p>
<p>如果您处于 vim-fugitive 的“特殊模式”（如 <code>:Git</code> 或 <code>:Git blame</code> 模式）中，按下 <code>g?</code> 可以了解当前有哪些可用的快捷键，Vim-fugitive 将为您所处的模式显示相应的 <code>:help</code> 窗口。棒极了！</p>
<h2 id="聪明地学习-Vim-和-Git"><a href="#聪明地学习-Vim-和-Git" class="headerlink" title="聪明地学习 Vim 和 Git"></a>聪明地学习 Vim 和 Git</h2><p>每个人都有不同的 git 工作流，可能 vim-fugitive 非常合适您的工作流（也可能不适合）。总之，我强烈建议您试试上面列出的所有插件。可能还有一些其他的我没有列出来，都可以去试一试。</p>
<p>要让Vim-git的集成工作得更好，一个显而易见的办法就是去深入了解git。Git 本身是一个很庞大的主题，我只向您展示了它其中很小的一部分。好了，接下来谈谈如何使用 Vim 编译您的代码。</p>
<h1 id="第19章-编译"><a href="#第19章-编译" class="headerlink" title="第19章 编译"></a>第19章 编译</h1><p>编译是许多编程语言的重要主题。在本章中，您将学习如何在 Vim 中编译。此外，您将看到如何利用好 Vim 的 <code>:make</code> 命令。</p>
<h2 id="从命令行编译"><a href="#从命令行编译" class="headerlink" title="从命令行编译"></a>从命令行编译</h2><p>您可以使用叹号运算符（<code>!</code>）进行编译。如果您需要使用 <code>g++</code> 来编译 <code>.cpp</code> 文件，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure>

<p>但要每次手动指定文件名和输出文件名会非常繁琐和容易出错。而 makefile 是条可行之路。</p>
<h2 id="Make命令"><a href="#Make命令" class="headerlink" title="Make命令"></a>Make命令</h2><p>Vim 有运行 makefile 的 <code>:make</code> 命令。当您运行它时，Vim 会在当前目录查找 makefile 并执行它。</p>
<p>在当前目录创建一个文件名为 <code>makefile</code> ，然后添加下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">	echo &quot;Hello all&quot;</span><br><span class="line">foo:</span><br><span class="line">	echo &quot;Hello foo&quot;</span><br><span class="line">list_pls:</span><br><span class="line">	ls</span><br></pre></td></tr></table></figure>

<p>在 Vim 中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make</span><br></pre></td></tr></table></figure>

<p>Vim 执行它的方式与从终端运行它的方式相同。<code>:make</code> 命令也接受终端中 <code>make</code> 命令的参数。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:make foo</span><br><span class="line">&quot; Outputs &quot;Hello foo&quot;</span><br><span class="line"></span><br><span class="line">:make list_pls</span><br><span class="line">&quot; Outputs the ls command result</span><br></pre></td></tr></table></figure>

<p>如果命令执行异常，<code>:make</code> 命令将使用 Vim 的 <code>quickfix</code> 来存储这些错误。现在试着运行一个不存在的目标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make dontexist</span><br></pre></td></tr></table></figure>

<p>您应该会看到该命令执行错误。运行 <code>quickfix</code> 命令 <code>:copen</code> 可以打开 <code>quickfix</code> 窗口来查看该错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|| make: *** No rule to make target `dontexist&#x27;.  Stop.</span><br></pre></td></tr></table></figure>

<h2 id="使用-Make-编译"><a href="#使用-Make-编译" class="headerlink" title="使用 Make 编译"></a>使用 Make 编译</h2><p>让我们使用 makefile 来编译一个基本的 <code>.cpp</code> 程序。首先创建一个 <code>hello.cpp</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello!\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，更新 <code>makefile</code> 来编译和运行 <code>.cpp</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">	echo &quot;build, run&quot;</span><br><span class="line">build:</span><br><span class="line">	g++ hello.cpp -o hello</span><br><span class="line">run:</span><br><span class="line">	./hello</span><br></pre></td></tr></table></figure>

<p>现在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make build</span><br></pre></td></tr></table></figure>

<p><code>g++</code> 将编译 <code>./hello.cpp</code> 并且生成 <code>./hello</code>。接着运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make run</span><br></pre></td></tr></table></figure>

<p>您应该会看到终端上打印出了 <code>&quot;Hello!&quot;</code>。</p>
<h2 id="不同的Make程序"><a href="#不同的Make程序" class="headerlink" title="不同的Make程序"></a>不同的Make程序</h2><p>当您运行 <code>:make</code> 时，Vim 实际上会执行 <code>makeprg</code> 选项所设置的任何命令，您可以运行 <code>:set makeprg?</code> 来查看它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeprg=make</span><br></pre></td></tr></table></figure>

<p><code>:make</code> 的默认命令是外部的 <code>make</code> 命令。若想修改 <code>:make</code> 命令，使每次运行它时执行 <code>g++ &lt;your-file-name&gt;</code>，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg=g++\ %</span><br></pre></td></tr></table></figure>

<p><code>\</code> 用于转义 <code>g++</code> 后的空格。Vim 中 <code>%</code> 符号代表当前文件。因此，<code>g++\ %</code> 命令等于运行 <code>g++ hello.cpp</code>。</p>
<p>转到 <code>./hello.cpp</code> 然后运行 <code>:make</code>，Vim 将编译 <code>hello.cpp</code> 并输出 <code>a.out</code>（因为您没有指定输出）。让我们重构一下，使用去掉扩展名的原始文件名来命名编译后的输出。运行下面的命令（或将它们添加到vimrc）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg=g++\ %\ -o\ %&lt;</span><br></pre></td></tr></table></figure>

<p>上面的命令分解如下：</p>
<ul>
<li><code>g++\\ %</code> 如上所述，等同于运行 <code>g++ &lt;your-file&gt;</code>。</li>
<li><code>-o</code> 输出选项。</li>
<li><code>%&lt;</code> 在 Vim 中代表了没有扩展名的当前文件名（如 <code>hello.cpp</code> 变成 <code>hello</code>）。</li>
</ul>
<p>当您在 <code>./hello.cpp</code> 中运行 <code>:make</code> 时，它将编译为 <code>./hello</code>。要在 <code>./hello.cpp</code> 中快速地执行 <code>./hello</code>，可以运行 <code>:!./%&lt;</code>。同样，它等同于运行 <code>:!./&lt;无后缀的当前文件名&gt;</code>。</p>
<p>查阅 <code>:h :compiler</code> 和 <code>:h write-compiler-plugin</code> 可以了解更多信息。</p>
<h2 id="保存时自动编译"><a href="#保存时自动编译" class="headerlink" title="保存时自动编译"></a>保存时自动编译</h2><p>有了自动化编译，您可以让生活更加轻松。回想一下，您可以使用 Vim 的 <code>autocmd</code> 来根据某些事件自动执行操作。例如，要自动在每次保存后编译 <code>.cpp</code> 文件，您可以将下面内容添加到vimrc：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:autocmd BufWritePost *.cpp make</span><br></pre></td></tr></table></figure>

<p>现在您每次保存 <code>.cpp</code> 文件后，Vim 都将自动执行 <code>make</code> 命令。</p>
<h2 id="切换编译器"><a href="#切换编译器" class="headerlink" title="切换编译器"></a>切换编译器</h2><p>Vim 有一个 <code>:compiler</code> 命令可以快速切换编译器。您的 Vim 可能附带了一些预构建的编译配置。要检查您拥有哪些编译器，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:e $VIMRUNTIME/compilers/&lt;tab&gt;</span><br></pre></td></tr></table></figure>

<p>您应该会看到一个不同编程语言的编译器列表。</p>
<p>若要使用 <code>:compiler</code> 命令，假设您有一个 ruby 文件 <code>hello.rb</code>，内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts &quot;Hello ruby&quot;</span><br></pre></td></tr></table></figure>

<p>回想一下，如果运行 <code>:make</code>，Vim 将执行赋值给 <code>makeprg</code> 的任何命令（默认是 <code>make</code>）。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:compiler ruby</span><br></pre></td></tr></table></figure>

<p>Vim 执行 <code>$VIMRUNTIME/compiler/ruby.vim</code> 脚本，并将 <code>makeprg</code> 更改为使用 <code>ruby</code> 命令。现在如果您运行 <code>:set makeprg?</code>，它会显示 <code>makeprg=ruby</code>（这取决于您 <code>$VIMRUNTIME/compiler/ruby.vim</code> 里的内容，如果您有其他自定义的 ruby 编译器，您的结果可能会有不同）。<code>:compiler &lt;your-lang&gt;</code> 命令允许您快速切换至其他编译器。如果您的项目使用多种语言，这会非常有用。</p>
<p>您不必使用 <code>:compiler</code> 或 <code>makeprg</code> 来编译程序。您可以运行测试脚本、分析文件、发送信号或任何您想要的内容。</p>
<h2 id="创建自定义编译器"><a href="#创建自定义编译器" class="headerlink" title="创建自定义编译器"></a>创建自定义编译器</h2><p>让我们来创建一个简单的 Typescript 编译器。先在您的设备上安装 Typescript（<code>npm install -g typescript</code>），安装完后您将有 <code>tsc</code> 命令。如果您之前没有尝试过 typescript，<code>tsc</code> 将 Typescript 文件编译成 Javascript 文件。假设您有一个 <code>hello.ts</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;hello&quot;;</span><br><span class="line">console.log(hello);</span><br></pre></td></tr></table></figure>

<p>运行 <code>tsc hello.ts</code> 后，它将被编译成 <code>hello.js</code>。然而，如果您的 <code>hello.ts</code> 文件中有如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;hello&quot;;</span><br><span class="line">hello = &quot;hello again&quot;;</span><br><span class="line">console.log(hello);</span><br></pre></td></tr></table></figure>

<p>这会抛出错误，因为不能更改一个 <code>const</code> 变量。运行 <code>tsc hello.ts</code> 的错误如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello.ts:2:1 - error TS2588: Cannot assign to &#x27;person&#x27; because it is a constant.</span><br><span class="line"></span><br><span class="line">2 person = &quot;hello again&quot;;</span><br><span class="line">  ~~~~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found 1 error.</span><br></pre></td></tr></table></figure>

<p>要创建一个简单的 Typescript 编译器，请在您的 <code>~/.vim/</code> 目录中新添加一个 <code>compiler</code> 目录（即 <code>~/.vim/compiler/</code>），接着创建 <code>typescript.vim</code> 文件（即 <code>~/.vim/compiler/typescript.vim</code>），并添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompilerSet makeprg=tsc</span><br><span class="line">CompilerSet errorformat=%f:\ %m</span><br></pre></td></tr></table></figure>

<p>第一行将 <code>makeprg</code> 设置为运行 <code>tsc</code> 命令。第二行将错误格式设置为显示文件（<code>%f</code>），后跟冒号（<code>:</code>）和转义的空格（<code>\ </code>），最后是错误消息（<code>%m</code>）。查阅 <code>:h errorformat</code> 可了解更多关于错误格式的信息。</p>
<p>您还可以阅读一些预制的编译器，看看它们是如何实现的。输入 <code>:e $VIMRUNTIME/compiler/&lt;some-language&gt;.vim</code> 查看。</p>
<p>有些插件可能会干扰 Typescript 文件，可以使用 <code>--noplugin</code> 标志以零插件的形式打开<code>hello.ts</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --noplugin hello.ts</span><br></pre></td></tr></table></figure>

<p>检查 <code>makeprg</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg?</span><br></pre></td></tr></table></figure>

<p>它应该会显示默认的 <code>make</code> 程序。要使用新的 Typescript 编译器，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:compiler typescript</span><br></pre></td></tr></table></figure>

<p>当您运行 <code>:set makeprg?</code> 时，它应该会显示 <code>tsc</code> 了。我们来测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make %</span><br></pre></td></tr></table></figure>

<p>回想一下，<code>%</code> 代表当前文件。看看您的 Typescript 编译器是否如预期一样工作。运行 <code>:copen</code> 可以查看错误列表。</p>
<h2 id="异步编译器"><a href="#异步编译器" class="headerlink" title="异步编译器"></a>异步编译器</h2><p>有时编译可能需要很长时间。在等待编译时，您不会想眼睁睁盯着已冻结的 Vim 的。如果可以异步编译，就可以在编译期间继续使用 Vim 了，岂不美哉？</p>
<p>幸运的是，有插件来运行异步进程。有两个比较好的是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tpope/vim-dispatch">vim-dispatch</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/skywind3000/asyncrun.vim">asyncrun.vim</a></li>
</ul>
<p>在这一章中，我将介绍 vim-dispatch，但我强烈建议您尝试上述列表中所有插件。</p>
<p><em>Vim 和 NeoVim 实际上都支持异步作业，但它们超出了本章的范围。如果您好奇，可以查阅 <code>:h job-channel-overview.txt</code>。</em></p>
<h2 id="插件：Vim-dispatch"><a href="#插件：Vim-dispatch" class="headerlink" title="插件：Vim-dispatch"></a>插件：Vim-dispatch</h2><p>Vim-dispatch 有几个命令，最主要的两个是 <code>:Make</code> 和 <code>:Dispatch</code>。</p>
<h3 id="异步Make"><a href="#异步Make" class="headerlink" title="异步Make"></a>异步Make</h3><p>Vim-dispatch 的 <code>:Make</code> 命令与 Vim 的 <code>:make</code> 相似，但它以异步方式运行。如果您正处于 Javascript 项目中，并且需要运行 <code>npm t</code>，可以将 <code>makeprg</code> 设置为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set makeprg=npm\\ t</span><br></pre></td></tr></table></figure>

<p>如果运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:make</span><br></pre></td></tr></table></figure>

<p>Vim 将执行 <code>npm t</code>。但同时，您只能盯着冻结了的屏幕。有了 vim-dispatch，您只需要运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:Make</span><br></pre></td></tr></table></figure>

<p>Vim 将启用后台进程异步运行 <code>npm t</code>，同时您还能在 Vim 中继续编辑您的文本。棒极了！</p>
<h3 id="异步调度（Dispatch）"><a href="#异步调度（Dispatch）" class="headerlink" title="异步调度（Dispatch）"></a>异步调度（Dispatch）</h3><p><code>:Dispatch</code> 命令的工作方式和 <code>:compiler</code> 及 <code>:!</code> 类似，它可以在Vim中运行任意外部命令。</p>
<p>假设您在 ruby spec 文件中，需要执行测试，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:Dispatch rspec %</span><br></pre></td></tr></table></figure>

<p>Vim 将对当前文件异步运行 <code>rspec</code> 命令。</p>
<h3 id="自动调度"><a href="#自动调度" class="headerlink" title="自动调度"></a>自动调度</h3><p>Vim-dispatch 有一个缓冲区变量<code>b:dispatch</code>，您可以配置它来自动执行特定命令，您可以利用 <code>autocmd</code>和它一起工作。如果在您的 vimrc 中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufEnter *_spec.rb let b:dispatch = &#x27;bundle exec rspec %&#x27;</span><br></pre></td></tr></table></figure>

<p>现在每当您进入（<code>BufEnter</code>）一个以 <code>_spec.rb</code> 结尾的文件，运行<code>:Dispatch</code> 将自动执行 <code>bundle exec rspec &lt;your-current-ruby-spec-file&gt;</code>。</p>
<h2 id="聪明地学习编译"><a href="#聪明地学习编译" class="headerlink" title="聪明地学习编译"></a>聪明地学习编译</h2><p>在本章中，您了解到可以使用 <code>make</code> 和 <code>compiler</code> 命令从Vim内部异步运行 <em>任何</em> 进程，以完善您的编程工作流程。Vim 拥有通过其他程序来扩展自身的能力，这使其变得强大。</p>
<h1 id="第20章-视图、会话和-Viminfo"><a href="#第20章-视图、会话和-Viminfo" class="headerlink" title="第20章 视图、会话和 Viminfo"></a>第20章 视图、会话和 Viminfo</h1><p>当您做了一段时间的项目后，您可能会发现这个项目逐渐形了成自己的设置、折叠、缓冲区、布局等，就像住了一段时间公寓后，精心装饰了它一样。问题是，关闭 Vim 后，所有的这些更改都会丢失。如果能保留这些更改，等到下次打开 Vim 时，一切恢复如初，岂不美哉？</p>
<p>本章中，您将学习如何使用 视图、会话 和 Viminfo 来保存项目的“快照”。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是这三个部分（视图、会话、Viminfo）中的最小子集，它是单个窗口相关设置的集合。如果您长时间在一个窗口上工作，并且想要保留其映射和折叠，您可以使用视图。</p>
<p>我们来创建一个 <code>foo.txt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo1</span><br><span class="line">foo2</span><br><span class="line">foo3</span><br><span class="line">foo4</span><br><span class="line">foo5</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>

<p>在这个文件中，做三次修改：</p>
<ol>
<li>在第 1 行，创建一个手动折叠 <code>zf4j</code>（折叠接下来 4 行）。</li>
<li>更改 <code>number</code> 设置：<code>setlocal nonumber norelativenumber</code>。这会移除窗口左侧的数字指示器。</li>
<li>创建本地映射，每当按一次 <code>j</code> 时，向下两行：<code>:nnoremap &lt;buffer&gt; j jj</code>。</li>
</ol>
<p>您的文件看起来应该像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-- 5 lines: foo1 -----</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>

<h3 id="配置视图属性"><a href="#配置视图属性" class="headerlink" title="配置视图属性"></a>配置视图属性</h3><p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viewoptions?</span><br></pre></td></tr></table></figure>

<p>默认情况下会显示（根据您的 vimrc 可能会有所不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewoptions=folds,cursor,curdir</span><br></pre></td></tr></table></figure>

<p>我们来配置 <code>viewoptions</code>。要保留的三个属性分别是折叠、映射和本地设置选项。如果您的设置和我的相似，那么您已经有了 <code>folds</code> 选项。运行下列命令使视图记住 <code>localoptions</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viewoptions+=localoptions</span><br></pre></td></tr></table></figure>

<p>查阅 <code>:h viewoptions</code> 可了解 <code>viewoptions</code> 的其他可用选项。现在运行 <code>:set viewoptions?</code>，您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewoptions=folds,cursor,curdir,localoptions</span><br></pre></td></tr></table></figure>

<h3 id="保存视图"><a href="#保存视图" class="headerlink" title="保存视图"></a>保存视图</h3><p>在 <code>foo.txt</code> 窗口经过适当折叠并设置了 <code>nonumber norelativenumber</code> 选项后，现在我们来保存视图。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview</span><br></pre></td></tr></table></figure>

<p>Vim 创建了一个视图文件。</p>
<h3 id="视图文件"><a href="#视图文件" class="headerlink" title="视图文件"></a>视图文件</h3><p>您可能会想“Vim 将这个视图文件保存到哪儿了呢？”，运行下列命令就可以看到答案了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viewdir?</span><br></pre></td></tr></table></figure>

<p>默认情况下会显示 <code>~/.vim/view</code>（根据您的操作系统，可能会有不同的路径。查阅 <code>:h viewdir</code> 获得更多信息）。如果您运行的是基于Unix的操作系统，想修改该路径，可以在您的 vimrc 中添加下列内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set viewdir=$HOME/else/where</span><br></pre></td></tr></table></figure>

<h3 id="加载视图文件"><a href="#加载视图文件" class="headerlink" title="加载视图文件"></a>加载视图文件</h3><p>关闭并重新打开 <code>foo.txt</code>，您会看到原来的文本，没有任何改变。这是预期行为。运行下列命令可以加载视图文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure>

<p>现在您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-- 5 lines: foo1 -----</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>

<p>那些折叠、本地设置以及映射都恢复了。如果您细心还可以发现，光标位于上一次您运行 <code>:mkview</code> 时所处的行上。只要您有 <code>cursor</code> 选项，视图将记住光标位置。</p>
<h3 id="多个视图"><a href="#多个视图" class="headerlink" title="多个视图"></a>多个视图</h3><p>Vim 允许您保存 9 个编号的视图（1-9）。</p>
<p>假设您想用 <code>:9,10 fold</code> 来额外折叠最后两行，我们把这存为视图 1。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview 1</span><br></pre></td></tr></table></figure>

<p>如果您又想用 <code>:6,7 fold</code> 再折叠一次，并存为不同的视图，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mkview 2</span><br></pre></td></tr></table></figure>

<p>关闭并重新打开 <code>foo.txt</code> 文件，运行下列命令可以加载视图 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview 1</span><br></pre></td></tr></table></figure>

<p>要加载视图 2，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview 2</span><br></pre></td></tr></table></figure>

<p>要加载原始视图，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure>

<h3 id="自动创建视图"><a href="#自动创建视图" class="headerlink" title="自动创建视图"></a>自动创建视图</h3><p>有一件可能会发生的很倒霉的事情是，您花了很长时间在一个大文件中进行折叠，一不小心关闭了窗口，接着丢失了所有折叠信息。您可以在 vimrc 中添加下列内容，使得在关闭缓冲区后 Vim 能自动创建视图，防止此类灾难发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufWinLeave *.txt mkview</span><br></pre></td></tr></table></figure>

<p>另外也能在打开缓冲区后自动加载视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd BufWinEnter *.txt silent loadview</span><br></pre></td></tr></table></figure>

<p>现在，当您编辑 <code>txt</code> 文件时，不用再担心创建和加载视图了。但也注意，&#x3D;&#x3D;随着时间的推移，视图文件会不断积累，记得每隔几个月清理一次。&#x3D;&#x3D;</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>如果说视图保存了某个窗口的设置，那么会话则保存了所有窗口（包括布局）的信息。</p>
<h3 id="创建新会话"><a href="#创建新会话" class="headerlink" title="创建新会话"></a>创建新会话</h3><p>假设您在 <code>foobarbaz</code> 工程中编辑着 3 个文件：</p>
<p><code>foo.txt</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo1</span><br><span class="line">foo2</span><br><span class="line">foo3</span><br><span class="line">foo4</span><br><span class="line">foo5</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>

<p><code>bar.txt</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bar1</span><br><span class="line">bar2</span><br><span class="line">bar3</span><br><span class="line">bar4</span><br><span class="line">bar5</span><br><span class="line">bar6</span><br><span class="line">bar7</span><br><span class="line">bar8</span><br><span class="line">bar9</span><br><span class="line">bar10</span><br></pre></td></tr></table></figure>

<p><code>baz.txt</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">baz1</span><br><span class="line">baz2</span><br><span class="line">baz3</span><br><span class="line">baz4</span><br><span class="line">baz5</span><br><span class="line">baz6</span><br><span class="line">baz7</span><br><span class="line">baz8</span><br><span class="line">baz9</span><br><span class="line">baz10</span><br></pre></td></tr></table></figure>

<p>假设您的窗口布局如下所示（适当地使用 <code>split</code> 和 <code>vsplit</code> 来放置）：</p>
<img data-src="/2023/06/05/154/session-layout.png" class="" title="Session Layout">

<p>要保留这个外观，您需要保存会话。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mksession</span><br></pre></td></tr></table></figure>

<p>与默认存储在 <code>~/.vim/view</code> 的 <code>mkview</code> 不同，<code>mksession</code> 在当前目录存储会话文件（<code>Session.vim</code>）。如果好奇，您可以看看文件。</p>
<p>如果您想将会话文件另存他处，可以将参数传递给 <code>mksession</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:mksession ~/some/where/else.vim</span><br></pre></td></tr></table></figure>

<p>使用 <code>!</code> 来调用命令可以覆盖一个已存在的会话文件（<code>:mksession! ~/some/where/else.vim</code>）。</p>
<h3 id="加载会话"><a href="#加载会话" class="headerlink" title="加载会话"></a>加载会话</h3><p>运行下列命令可以加载会话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:source Session.vim</span><br></pre></td></tr></table></figure>

<p>现在 Vim 看起来就像您离开它时的样子！或者，您也可以从终端加载会话文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -S Session.vim</span><br></pre></td></tr></table></figure>

<h3 id="配置会话属性"><a href="#配置会话属性" class="headerlink" title="配置会话属性"></a>配置会话属性</h3><p>您可以配置会话要保存的属性。若要查看当前哪些属性正被保存，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set sessionoptions?</span><br></pre></td></tr></table></figure>

<p>我的显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blank,buffers,curdir,folds,help,tabpages,winsize,terminal</span><br></pre></td></tr></table></figure>

<p>如果在保存会话时不想存储 <code>terminal</code>，可以运行下列命令将其从会话选项中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set sessionoptions-=terminal</span><br></pre></td></tr></table></figure>

<p>如果要在保存会话时存储 <code>options</code>，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set sessionoptions+=options</span><br></pre></td></tr></table></figure>

<p>下面是一些 <code>sessionoptions</code> 可以存储的属性：</p>
<ul>
<li><code>blank</code> 存储空窗口</li>
<li><code>buffers</code> 存储缓冲区</li>
<li><code>folds</code> 存储折叠</li>
<li><code>globals</code> 存储全局变量（必须以大写字母开头，并且至少包含一个小写字母）</li>
<li><code>options</code> 存储选项和映射</li>
<li><code>resize</code> 存储窗口行列</li>
<li><code>winpos</code> 存储窗口位置</li>
<li><code>winsize</code> 存储窗口大小</li>
<li><code>tabpages</code> 存储选项卡</li>
<li><code>unix</code> 以 Unix 格式存储文件</li>
</ul>
<p>查阅 <code>:h &#39;sessionoptions&#39;</code> 来获取完整列表。</p>
<p>会话是保存项目外部属性的好工具。但是，一些内部属性不存储在会话中，如本地标记、寄存器、历史记录等。要保存它们，您需要使用 Viminfo！</p>
<h2 id="Viminfo"><a href="#Viminfo" class="headerlink" title="Viminfo"></a>Viminfo</h2><p>如果您留意，在复制一个单词进寄存器 a，再退出并重新打开 Vim 后，您仍然可以看到存储在寄存器中的文本。这就是 Viminfo 的功劳。没有它，在您关闭 Vim 后，Vim 会忘记这些寄存器。</p>
<p>如果您使用 Vim 8 或更高版本，Vim 会默认启用 Viminfo。因此您可能一直在使用 Viminfo，而您对它毫不知情！</p>
<p>您可能会问：Viminfo 存储了什么？与会话有何不同？</p>
<p>要使用 Viminfo，您必须启用了 <code>+viminfo</code> 特性（<code>:version</code>）。Viminfo 存储着：</p>
<ul>
<li>命令行历史记录。</li>
<li>字符串搜索历史记录。</li>
<li>输入行历史记录。</li>
<li>非空寄存器的内容。</li>
<li>多个文件的标记。</li>
<li>文件标记，它指向文件中的位置。</li>
<li>上次搜索 &#x2F; 替换模式（用于 “n” 和 “&amp;”）。</li>
<li>缓冲区列表。</li>
<li>全局变量。</li>
</ul>
<p>通常，会话存储“外部”属性，Viminfo 存储“内部”属性。</p>
<p>每个项目可以有一个会话文件，而 Viminfo 与会话不同，通常每台计算机只使用一个 Viminfo。Viminfo 是项目无关的。</p>
<p>对于 Unix，Viminfo 的默认位置是 <code>$HOME/.viminfo</code>（<code>~/.viminfo</code>）。如果您用其他操作系统，Viminfo 位置可能会有所不同。可以查阅 <code>:h viminfo-file-name</code>。每一次您做出的“内部”更改，如将文本复制进一个寄存器，Vim 都会自动更新 Viminfo 文件。</p>
<p><em>请确保您设置了 <code>nocompatible</code> 选项（<code>set nocompatible</code>），否则您的 Viminfo 将不起作用。</em></p>
<h3 id="读写-Viminfo"><a href="#读写-Viminfo" class="headerlink" title="读写 Viminfo"></a>读写 Viminfo</h3><p>尽管只使用一个 Viminfo 文件，但您还是可以创建多个 Viminfo 文件。使用 <code>:wviminfo</code> 命令（缩写为 <code>:wv</code>）来创建多个 Viminfo 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wv ~/.viminfo_extra</span><br></pre></td></tr></table></figure>

<p>要覆盖现有的 Viminfo 文件，向 <code>wv</code> 命令多添加一个叹号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wv! ~/.viminfo_extra</span><br></pre></td></tr></table></figure>

<p>Vim 默认情况下会读取 <code>~/.viminfo</code> 文件。运行 <code>:rviminfo</code>（缩写为 <code>:rv</code>）可以读取不同的 Vimfile 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rv ~/.viminfo_extra</span><br></pre></td></tr></table></figure>

<p>要在终端使用不同的 Viminfo 文件来启动 Vim，请使用 “i” 标志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -i viminfo_extra</span><br></pre></td></tr></table></figure>

<p>如果您要将 Vim 用于不同的任务，比如写代码和写作，您可以创建两个 Viminfo，一个针对写作优化，另一个为写代码优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim -i viminfo_writing</span><br><span class="line"></span><br><span class="line">vim -i viminfo_coding</span><br></pre></td></tr></table></figure>

<h3 id="不使用-Viminfo-启动-Vim"><a href="#不使用-Viminfo-启动-Vim" class="headerlink" title="不使用 Viminfo 启动 Vim"></a>不使用 Viminfo 启动 Vim</h3><p>要不使用 Viminfo 启动 Vim，可以在终端运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -i NONE</span><br></pre></td></tr></table></figure>

<p>要永不使用 Viminfo，可以在您的 vimrc 文件添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set viminfo=&quot;NONE&quot;</span><br></pre></td></tr></table></figure>

<h3 id="配置-Viminfo-属性"><a href="#配置-Viminfo-属性" class="headerlink" title="配置 Viminfo 属性"></a>配置 Viminfo 属性</h3><p>和 <code>viewoptions</code> 以及 <code>sessionoptions</code> 类似，您可以用 <code>viminfo</code> 选项指定要存储的属性。请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set viminfo?</span><br></pre></td></tr></table></figure>

<p>您会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!,&#x27;100,&lt;50,s10,h</span><br></pre></td></tr></table></figure>

<p>看起来有点晦涩难懂。命令分解如下：</p>
<ul>
<li><code>!</code> 保存以大写字母开头、却不包含小写字母的全局变量。回想一下 <code>g:</code> 代表了一个全局变量。例如，假设您写了赋值语句 <code>let g:FOO = &quot;foo&quot;</code>，Viminfo 将存储全局变量 <code>FOO</code>。然而如果您写了 <code>let g:Foo = &quot;foo&quot;</code>，Viminfo 将不存储它，因为它包含了小写字母。没有 <code>!</code>，Vim 不会存储这些全局变量。</li>
<li><code>&#39;100</code> 代表标记。在这个例子中，Viminfo 将保存最近 100 个文件的本地标记（a-z）。注意，如果存储的文件过多，Vim 会变得很慢，1000 左右就可以了。</li>
<li><code>&lt;50</code> 告诉 Viminfo 每个寄存器最多保存多少行（这个例子中是 50 行）。如果我复制 100 行文本进寄存器 a（<code>&quot;ay99j</code>）后关闭 Vim，下次打开 Vim 并从寄存器 a（<code>&quot;ap</code>）粘贴时，Vim 最多只粘贴 50 行；如果不指定最大行号， <em>所有</em> 行都将被保存；如果指定 0，什么都不保存了。</li>
<li><code>s10</code> 为寄存器设置大小限制（kb）。在这个例子中，任何大于 10kb 的寄存器都会被排除。</li>
<li><code>h</code> 禁用高亮显示（<code>hlsearch</code> 时）。</li>
</ul>
<p>可以查阅 <code>:h &#39;viminfo&#39;</code> 来了解其他更多选项。</p>
<h2 id="聪明地使用视图、会话和-Viminfo"><a href="#聪明地使用视图、会话和-Viminfo" class="headerlink" title="聪明地使用视图、会话和 Viminfo"></a>聪明地使用视图、会话和 Viminfo</h2><p>Vim 能使用视图、会话和 Viminfo 来保存不同级别的 Vim 环境快照。对于微型项目，可以使用视图；对于大型项目，可以使用会话。您应该花些时间来查阅视图、会话和 Viminfo 提供的所有选项。</p>
<p>为您的编辑风格创建属于您自己的视图、会话和 Viminfo。如果您要换台计算机使用 Vim，只需加载您的设置，立刻就会感到就像在家里的工作环境一样！</p>
<h1 id="第21章-多文件操作"><a href="#第21章-多文件操作" class="headerlink" title="第21章 多文件操作"></a>第21章 多文件操作</h1><p>多文件编辑更新是一个值得掌握、非常有用的编辑工具。前面您已经学会了如何使用 <code>cfdo</code> 命令在多个文本中进行更新。本章，您将学到如何在Vim中进行多文件编辑的更多不同方法。</p>
<h2 id="在多个文件中执行命令的几种方法"><a href="#在多个文件中执行命令的几种方法" class="headerlink" title="在多个文件中执行命令的几种方法"></a>在多个文件中执行命令的几种方法</h2><p>要在多个文件中执行命令，Vim有8种方法：</p>
<ul>
<li>参数列表 (<code>argdo</code>)</li>
<li>缓冲区列表 (<code>bufdo</code>)</li>
<li>窗口列表 (<code>windo</code>)</li>
<li>tab 列表(<code>tabdo</code>)</li>
<li>快速修复列表 (<code>cdo</code>)</li>
<li>文件方式的快速修复列表 (<code>cfdo</code>)</li>
<li>位置列表 (<code>ldo</code>)</li>
<li>文件方式的位置列表 (<code>lfdo</code>)</li>
</ul>
<p>实际上，大部分时间您可能只会用到1种或2种（就我个人而言，我使用 <code>cdo</code> 和 <code>argdo</code>比其他的多得多），但了解所有可行方法还是很有用的，这样您就可以选择一个最符合您个人编辑风格的方法。</p>
<p>学习所有8个命令可能听起来让人有点打退堂鼓。但实际上，这些命令工作方式很相似。学习了其中一个后，再学习剩余的将容易的多。它们的运行方式都大体相同：分别创建一个列表(列表中的元素根据命令有所不同)，然后向列表传递一个您想执行的命令。</p>
<h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><p>参数列表是最基础的列表。它创建一个文件列表。要想为 file1, file2, file3创建文件列表，您可以执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args file1 file2 file3</span><br></pre></td></tr></table></figure>

<p>您也可以传递一个通配符（<code>*</code>），所以如果您想为当前目录下所有的 <code>.js</code> 文件创建一个列表，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args *.js</span><br></pre></td></tr></table></figure>

<p>如果您想为当前目录下所有以 “a” 开头的Javascript文件创建列表，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args a*.js</span><br></pre></td></tr></table></figure>

<p>（<code>*</code>）通配符匹配当前目录下的1个或多个任意文件名中的字符。但如果您想在某个目录下进行递归搜索怎么办呢？您可以使用双通配符（<code>**</code>）。要得到您当前位置下所有子目录中的Javascript文件，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args **/*.js</span><br></pre></td></tr></table></figure>

<p>您运行了 <code>args</code> 命令后，您的当前buffer将会切换到列表中的第一个文件。运行 <code>:args</code>可以查看您刚才创建的文件列表。当您创建好了您的列表后，您就可以遍历它们了。<code>:first</code> 将让您跳至列表中的第一个文件。<code>:last</code> 将跳到最后一个文件。运行<code>:next</code>可以在列表中一次向前移动一个文件。运行 <code>:prev</code>可以在列表中一次向后移动一个文件。运行<code>:wnext</code> 和 <code>:wprev</code>命令，在向前&#x2F;向后移动文件的同时还会保存修改。查阅 <code>: arglist</code> 了解更多导航命令。</p>
<p>参数列表在定位某个特定类型的文件或少量文件时特别有用。假如您需要将所有 <code>yml</code> 文件中的<code>donut</code> 更新为 <code>pancake</code>。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:args **/*.yml</span><br><span class="line">:argdo %s/donut/pancake/g | update</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意如果您再次执行 <code>args</code> 命令，它将覆盖先前的列表。比如，如果您先前运行了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args file1 file2 file3</span><br></pre></td></tr></table></figure>

<p>假设这些文件都是存在的，那么现在您的列表为 <code>file1</code>, <code>file2</code>,以及 <code>file3</code>。然后再运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args file4 file5</span><br></pre></td></tr></table></figure>

<p>您的初始列表 <code>file1</code>, <code>file2</code>, <code>file3</code>将被覆盖为 <code>file4</code>, <code>file5</code>。如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code> ，而您想将 <code>file4</code>, <code>file5</code> 添加到初始列表中，请使用 <code>:arga</code>命令。运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:arga file4 file5</span><br></pre></td></tr></table></figure>

<p>现在您的列表为<code>file1</code>, <code>file2</code>, <code>file3</code>, <code>file4</code>, <code>file5</code>。</p>
<p>如果您运行 <code>:arga</code> 时没有给任何参数，Vim会添加当前buffer到参数列表中。例如，如果您的参数列表中已经有了 <code>file1</code>, <code>file2</code>, <code>file3</code>，而您当前buffer是 <code>file5</code>，运行 <code>:arga</code> 将添加 <code>file5</code> 到您的列表中。</p>
<p>在前面的命令（<code>:argdo %s/donut/pancake/g</code>）中您已经看到过了，当您创建好列表后就可以向它传递任意命令行命令。其他的一些示例：</p>
<ul>
<li>删除参数列表所有文件内包含 “dessert” 的行, 运行 <code>:argdo g/dessert/d</code>.</li>
<li>在参数列表每个文件中执行宏a(假设您已经在a中录好了一个宏)，运行 <code>:argdo norm @a</code>.</li>
<li>向参数列表所有文件的第一行插入”hello “+文件名 ，运行 <code>:argdo 0put=&#39;hello &#39; . @%</code>（译者注：在英文版中，原作者给出的命令是 <code>:argdo 0put=&#39;hello &#39; .. @:</code>，貌似这个命令有问题）。</li>
</ul>
<p>把所有工作完成后，别忘了使用 <code>:update</code> 命令保存(<code>:update</code>只会保存当前buffer，要保存列表所有文件的修改，请用 <code>:argdo update</code>)。</p>
<p>有时候您仅仅需要在参数列表的前n个文件执行某条命令。如果是这种情况，只需要向 <code>argdo</code> 命令传递一个地址就可以了。比如，要在列表的前3个文件执行替换命令，运行：<code>:1,3argdo %s/donut/pancake/g</code>。</p>
<h2 id="缓冲区列表"><a href="#缓冲区列表" class="headerlink" title="缓冲区列表"></a>缓冲区列表</h2><p>因为每次您创建新文件或打开文件时，Vim将它保存在一个buffer中（除非您显式地删除它），所以当您编辑新文件时，缓冲区列表就有组织地被创建了。如果您已经打开了3个文件：<code>file1.rb file2.rb file3.rb</code>，您的缓冲区列表就已经有了3个元素。运行 <code>:buffers</code>（或者<code>:ls</code>、或<code>:files</code>）可以显示缓冲区列表。要想向前或向后遍历缓冲区列表，可以使用 <code>:bnext</code> <code>:bprev</code>。要想跳至列表中第一个或最后一个buffer，可使用 <code>:bfirst</code> 和 <code>:blast</code>。</p>
<p>另外，这里有一个和本章内容不相关，但是很酷的缓冲区技巧：如果您的缓冲区有大量的文件，您可以使用 <code>:ball</code> 显示所有缓冲区。<code>:ball</code> 命令默认使用水平分割窗口进行显示，如果想使用垂直分割的窗口显示，运行：<code>:vertical ball</code></p>
<p>回到本章主题。在缓冲区列表中执行某个操作的方法与参数列表操作非常相似。当您创建好缓冲区列表后，您只需要在您想执行的命令前用 <code>:bufdo</code> 代替 <code>:argdo</code>就可以了。例如，如果您想将缓冲区列表内每个文件中所有的 “donut” 替换为 “pancake”并保存修改，可以运行：<code>:bufdo %s/donut/pancake/g | update</code>。</p>
<h2 id="窗口列表和选项卡（Tab）列表"><a href="#窗口列表和选项卡（Tab）列表" class="headerlink" title="窗口列表和选项卡（Tab）列表"></a>窗口列表和选项卡（Tab）列表</h2><p>窗口列表、选项卡列表的操作和参数列表、缓冲区列表同样非常相似。唯一的区别在于它们的内容和语法。</p>
<p>窗口操作作用在每一个打开的窗口上，使用的命令是 <code>:windo</code>。选项卡（Tab）操作作用在每一个打开的选项卡上，使用的命令是 <code>:tabdo</code>。可以查询 <code>:h list-repeat</code>, <code>:h :windo</code>和<code>:h :tabdo</code>，了解更多信息。</p>
<p>比如，如果您打开了4个窗口（您可以使用 <code>Ctrl-w v</code>打开一个垂直分割的窗口，也可以使用 <code>Ctrl-w s</code>打开一个水平分割的窗口），然后您运行 <code>:windo 0put = &#39;hello&#39; . @%</code>，Vim将在所有打开的窗口的第一行输出 “hello”+文件名。</p>
<h2 id="快速修复列表"><a href="#快速修复列表" class="headerlink" title="快速修复列表"></a>快速修复列表</h2><p>在前面的章节中（第3章和第19章），我曾提到过快速修复（quickfix）。快速修复有很多作用，很多流行的插件都在使用快速修复提供的功能，因此值得花时间去理解它。</p>
<p>如果您是Vim新手，快速修复对于您可能是个新概念。回想以前您执行代码编译的时候，编译期间您可能遇到过错误，而这些错误都显示在一个特殊的窗口。这就是快速修复(quickfix)的由来。当您编译您的代码的时候，Vim会在快速修复窗口显示错误信息，您可以稍后去解决。许多现代语言已经不再需要进行显式地编译，但快速修复并没有被淘汰。现在，人们使用快速修复来做各种各样的事，比如显示虚拟终端的输入、存储搜索结果等。我们重点研究后者，存储搜索结果。</p>
<p>除编译命令外，某些特定的Vim命令也依赖快速修复接口。其中一种就是搜索命令，其使用过程中大量的使用了快速修复窗口，<code>:vimgrep</code> 和 <code>:grep</code> 都默认使用快速修复。</p>
<p>比如，如果您需要在所有的Javascript文件中递归地搜索 “donut”，您可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vimgrep /donut/ **/*.js</span><br></pre></td></tr></table></figure>

<p>“donut”的搜索结果存储在快速修复窗口中。要查看快速修复窗口的结果，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:copen</span><br></pre></td></tr></table></figure>

<p>要关闭快速修复窗口，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:cclose</span><br></pre></td></tr></table></figure>

<p>在快速修复列表中向前或向后遍历，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:cnext</span><br><span class="line">:cprev</span><br></pre></td></tr></table></figure>

<p>跳至第一个或最后一个匹配的元素，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:cfirst</span><br><span class="line">:clast</span><br></pre></td></tr></table></figure>

<p>在前面我提到过，有两种快速修复命令：<code>cdo</code> 和 <code>cfdo</code> 。它们有什么区别？<code>cdo</code> 在修复列表中的每一个元素上执行命令，而 <code>cfdo</code> 在修复列表中的每一个文件上执行命令。</p>
<p>让我讲清楚一点，假设运行完上面的 <code>vimgrep</code> 命令后，您找到以下结果：</p>
<ul>
<li>1 result in <code>file1.js</code></li>
<li>10 results in <code>file2.js</code></li>
</ul>
<p>如果您运行 <code>:cfdo %s/donut/pancake/g</code>, 这个命令将会在 <code>file1.js</code> 和 <code>file2.js</code> 上分别有效地运行一次<code>%s/donut/pancake/g</code>. 它执行的次数与 <em>匹配结果中文件的数量</em> 相同。因为搜索结果中有2个文件，因此Vim在 <code>file1.js</code> 上运行一次替换命令，在 <code>file2.js</code> 上再运行一次替换命令。 尽管在第二个文件中有10个搜索结果，但 <code>cfdo</code> 只关注快速修复列表中有多少个文件。</p>
<p>而如果您运行 <code>:cdo %s/donut/pancake/g</code> ，这个命令将会在 <code>file1.js</code> 上有效运行一次，然后在 <code>file2.js</code> 上运行10次。它执行的次数与 <em>快速修复列表中元素的数量</em> 相同。因为在 <code>file1.js</code> 上找到1个匹配结果，在 <code>file2.js</code> 上找到10个匹配结果，因此它执行的总次数是11次。</p>
<p>由于您要在列表中运行的命令是 <code>%s/donut/pancake/g</code> ，所以使用 <code>cfdo</code>命令是比较合理的。而使用 <code>cdo</code> 是不合理的，因为它将在 <code>file2.js</code> 中运行10次 <code>%s/donut/pancake/g</code>命令（<code>%s</code>已经是一个针对整个文件的替换操作）。一个文件运行一次 <code>%s</code> 就足够了。如果您使用 <code>cdo</code>，则传给它的命令应当改为 <code>s/donut/pancake/g</code> 才是合理的。</p>
<p>那到底什么时候该用 <code>cfdo</code>？什么时候该用 <code>cdo</code>？	这应当想一想您要传递的命令的作用域，要看命令作用域是整个文件（比如 <code>:%s</code> 或 <code>:g</code>）？还是某一行（比如 <code>:s</code> 或 <code>:!</code>）？</p>
<h2 id="位置列表"><a href="#位置列表" class="headerlink" title="位置列表"></a>位置列表</h2><p>位置列表在某种意义上和快速修复列表很像。Vim也使用一个特殊的窗口来显示位置列表的信息。区别在于：您&#x3D;&#x3D;任何时候都只能有1个快速修复列表，而位置列表则是，有多少个窗口就可以有多少个位置列表。&#x3D;&#x3D;</p>
<p>假设您打开了两个窗口，其中一个窗口显示 <code>food.txt</code> ，而另一个显示 <code>drinks.txt</code>。在 <code>food.txt</code>里面，运行一个位置列表搜索命令 <code>:lvimgrep</code> （<code>:vimgrep</code>命令关于位置列表的一个变体）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:lvim /bagel/ **/*.md</span><br></pre></td></tr></table></figure>

<p>Vim将为 <code>food.txt</code>所在 <em>窗口</em>创建一个位置列表，用于存储所有的bagel搜索结果。用 <code>:lopen</code>命令可以查看位置列表。现在转到另一个窗口 <code>drinks.txt</code>，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:lvimgrep /milk/ **/*.md</span><br></pre></td></tr></table></figure>

<p>Vim将为 <code>drinks.txt</code>所在 <em>窗口</em>再创建一个 <em>单独</em>的位置列表，用于存储所有关于milk的搜索结果。</p>
<p>对于每个不同的窗口中您运行的位置命令，Vim都会单独创建一个位置列表。如果您有10个不同的窗口，您就可以有最多10个不同的位置列表。对比前面介绍的快速修复列表，快速修复列表任何时候都只能有1个。就算您有10个不同的窗口，您也只能有1个快速修复列表。</p>
<p>大多数位置列表命令都和快速修复列表命令相似，唯一不同就是位置列表命令有一个 <code>l-</code>前缀，比如： <code>:lvimgrep</code>, <code>:lgrep</code>, 还有 <code>:lmake</code>。在快速修复列表命令中与之对应的是: <code>:vimgrep</code>, <code>:grep</code>, 以及 <code>:make</code>。操作位置列表窗口的方式和快速修复窗口也很相似：<code>:lopen</code>, <code>:lclose</code>, <code>:lfirst</code>, <code>:llast</code>, <code>:lnext</code>, 还有<code>:lprev</code>，与之对应快速修复版本是：<code>:copen</code>, <code>:cclose</code>, <code>:cfirst</code>, <code>:clast</code>, <code>:cnext</code>, and <code>:cprev</code>。</p>
<p>两个位置列表参数的多文件操作命令也和快速修复列表的多文件操作命令也很类似：<code>:ldo</code> 和 <code>:lfdo</code>。<code>:ldo</code> 对位置列表中每一个元素执行命令，而 <code>:lfdo</code> 对位置列表中每一个文件执行命令。可以查阅 <code>:h location-list</code>了解更多信息。</p>
<h2 id="在Vim中运行多文件操作命令"><a href="#在Vim中运行多文件操作命令" class="headerlink" title="在Vim中运行多文件操作命令"></a>在Vim中运行多文件操作命令</h2><p>在编辑工作中，知道如何进行多文件操作是一个非常有用的技能。当您需要在多个文件中改变一个变量名字的时候，您肯定想一个操作就全部搞定。Vim有8种不同的方法支持你完成这个事。</p>
<p>事实上，您可能并不会用到所有8种方法。您会慢慢倾向于其中1中或2种。当您刚开始时，选择其中1个（我个人建议从参数列表开始 <code>:argdo</code>）并掌握它。当您习惯了其中1个，然后再学下一个。您将会发现，学习第二个、第三个、第四个时要容易多了。记得要创造性的使用，即将它和其他各种不同命令组合起来使用。坚持练习直到您可以不经思考地高效的使用它。让它成为您的肌肉记忆。</p>
<p>就像前面已经说过的，您现在已经掌握了Vim的编辑功能。恭喜您！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/04/153/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/04/153/" class="post-title-link" itemprop="url">153. VIM 从入门到放弃</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-04 14:00:00" itemprop="dateCreated datePublished" datetime="2023-06-04T14:00:00+08:00">2023-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/software/" itemprop="url" rel="index"><span itemprop="name">software</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul>
<li><p>本人学习的总原则: 了解功能, 现用现学</p>
<p> 以熟练实用为目标, 以查漏补缺为方法, 达到究竟涅槃不可思议的程度</p>
<p> 以下的顺序即为学习顺序, 分为看过和感觉不错的</p>
</li>
</ul>
<p><strong>学习顺序推荐</strong></p>
<ol>
<li><p>learn vim</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/wsdjeg/Learn-Vim_zh_cn">zh</a></p>
<p> 不全（第25-29章是没有的）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/iggredible/Learn-Vim">en</a></p>
</li>
</ul>
</li>
<li><p>Vim实用技巧必知必会(极客时间吴咏炜)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://yianwillis.github.io/vimcdoc/doc/">Vim参考手册</a> by Bram Molenaar, 译者: Willis</p>
<p>一句话: 布莱姆·米勒（荷兰语：Bram Moolenaar，1961年—2023年8月3日）是一名荷兰程序员，在自由软件界素有盛名。他是Vim软件的最初开发者，软件版本管理者，被推崇为终身仁慈独裁者.</p>
</li>
</ol>
<p><strong>感觉不错的</strong></p>
<ul>
<li><p>控制台运行 <code>vimtutor</code> 这是 Vim 官方实操教程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/dofy/learn-vim">vim实操教程</a></p>
<p> 只能当作入门吧!</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/5426.html">简明 Vim 练级攻略</a></p>
<p> 左耳听风值得信赖, 很不错的入门教程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/mhinz/vim-galore">Vim Galore</a></p>
<p> 更新频繁，Vim 进阶必读. 确实东西很多!!!</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://liuzhijun.iteye.com/category/270228">每日一Vim</a></p>
<p> 共 30 篇，说是比较全, 但是还达不到系统的程度, 可以用来拓展知识面, 而不应该当作系统知识学习</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://openvim.com/">Open Vim</a></p>
<p> 交互式 Vim 教程</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://quickref.me/vim">QuickRef.ME&#x2F;vim</a></p>
<p> Vim cheatsheet</p>
</li>
</ul>
<h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><ul>
<li>移动技术</li>
<li>d</li>
<li>p P</li>
<li>宏命令</li>
<li><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。</li>
</ul>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/junegunn/vim-peekaboo">vim-peekaboo</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/universal-ctags/ctags">universal ctags</a> </li>
<li><a target="_blank" rel="noopener" href="https://github.com/ludovicchabant/vim-gutentags">vim-gutentags</a></li>
<li>git 钩子。<a target="_blank" rel="noopener" href="https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html">可以看一看</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/sheerun/vim-polyglot">vim-polyglot</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tpope/vim-fugitive">vim-fugitive</a></li>
</ul>
<h1 id="g"><a href="#g" class="headerlink" title="g"></a>g</h1><ul>
<li><a target="_blank" rel="noopener" href="https://vimdoc.sourceforge.net/htmldoc/vimindex.html#g">官方版本</a></li>
<li><a target="_blank" rel="noopener" href="https://vim.fandom.com/wiki/Power_of_g">power_of_g</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45086981/what-are-the-vim-commands-that-start-with-g">what-are-the-vim-commands-that-start-with-g</a></li>
</ul>
<h1 id="first"><a href="#first" class="headerlink" title="first"></a>first</h1><h2 id="更多帮助"><a href="#更多帮助" class="headerlink" title="更多帮助"></a>更多帮助</h2><p>关于Vim帮助手册有一个额外的小技巧：假设您想了解关于<code>Ctrl-p</code>在插入模式时的功能。如果您仅仅查找<code>:h CTRL-P</code>，您将被导航到普通模式下关于<code>Ctrl-P</code>的介绍页面，这并不是您想要的信息。在这种情况下，改为查找<code>:h i_CTRL-P</code>。添加的<code>i_</code>表示插入模式。注意它属于哪个模式。</p>
<h2 id="Vimrc"><a href="#Vimrc" class="headerlink" title="Vimrc"></a>Vimrc</h2><p>配置文件</p>
<p>激活这一配置(<code>:source %</code>)</p>
<p>您的vimrc文件中添加<code>set nocompatible</code>。如果启用<code>compatible</code>选项，许多Vim特有的功能将会被禁止</p>
<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从Vim的官方网站或官方仓库可以获得下载链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.vim.org/download.php">Vim 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/vim/vim">Vim 官方仓库</a></li>
<li><a target="_blank" rel="noopener" href="https://hub.fastgit.org/vim/vim">Vim 官方仓库镜像</a></li>
</ul>
<h2 id="退出Vim"><a href="#退出Vim" class="headerlink" title="退出Vim"></a>退出Vim</h2><ul>
<li><code>:q</code></li>
</ul>
<p>在Vim的好几种模式下都可以通过按<code>&lt;Esc&gt;</code>键切回普通模式</p>
<h2 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h2><ul>
<li><code>:w</code></li>
<li><code>:w filename</code></li>
<li><code>:wq</code></li>
<li><code>:q!</code></li>
</ul>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>如果您需要查询一些信息，只需要输入<code>:h</code>后接关键词，然后按<code>&lt;Tab&gt;</code>。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><ul>
<li><p>单个文件</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个文件</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello1.txt hello2.txt hello3.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="当前版本"><a href="#当前版本" class="headerlink" title="当前版本"></a>当前版本</h3><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim --version</span><br></pre></td></tr></table></figure>

<ul>
<li>‘+’表示支持的特性</li>
<li>‘-‘表示不支持的特性</li>
</ul>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">version</span></span><br></pre></td></tr></table></figure>



<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>在Vim中，您可以使用<code>:s</code>命令（<code>substitue</code>的缩写）替换文本。如果您想打开<code>hello.txt</code>后立即将所有的”pancake”替换成”bagel”，在终端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +%s/pancake/bagel/g hello.txt</span><br></pre></td></tr></table></figure>



<p>该命令可以被叠加，在终端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +%s/pancake/bagel/g +%s/bagel/egg/g +%s/egg/donut/g hello.txt</span><br></pre></td></tr></table></figure>

<p>Vim会将所有”pancake” 实例替换为”bagel”，然后将所有”bagel”替换为”egg”，然后将所有”egg”替换为”donut”（在后面的章节中您将学到如何替换）。</p>
<p>您同样可以使用<code>c</code>标志来代替<code>+</code>语法，在终端中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim -c %s/pancake/bagel/g hello.txt</span><br><span class="line">vim -c %s/pancake/bagel/g -c %s/bagel/egg/g -c %s/egg/donut/g hello.txt</span><br></pre></td></tr></table></figure>



<h2 id="打开多个窗口"><a href="#打开多个窗口" class="headerlink" title="打开多个窗口"></a>打开多个窗口</h2><p>使用<code>o</code>和<code>O</code>选项使Vim打开后分别显示为水平或垂直分割的窗口</p>
<p>若想将Vim打开为2个水平分割的窗口，在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o2</span><br></pre></td></tr></table></figure>



<p>若想将Vim打开为5个水平分割的窗口，在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o5</span><br></pre></td></tr></table></figure>



<p>若想将Vim打开为5个水平分割的窗口，并使前两个窗口显示<code>hello1.txt</code>和<code>hello2.txt</code>的内容，在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -o5 hello1.txt hello2.txt</span><br></pre></td></tr></table></figure>



<p>若想将Vim打开为2个垂直分割的窗口、5个垂直分割的窗口、5个垂直分割窗口并显示2个文件，在终端中分别运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim -O2</span><br><span class="line">vim -O5</span><br><span class="line">vim -O5 hello1.txt hello2.txt</span><br></pre></td></tr></table></figure>



<h2 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h2><p>如果您编辑时想将Vim挂起，您可以按下<code>Ctrl-z</code>。同样，您也可以使用<code>:stop</code>或<code>:suspend</code>命令达到相同的效果。若想从挂起状态返回，在终端中运行<code>fg</code>命令。</p>
<h2 id="聪明的启动Vim"><a href="#聪明的启动Vim" class="headerlink" title="聪明的启动Vim"></a>聪明的启动Vim</h2><p>您可以向<code>vim</code>命令传递不同的选项(option)和标志(flag)，就像其他终端命令一样。其中一个选项是命令行命令（<code>+&#123;cmd&#125;</code>或<code>-c cmd</code>）。当您读完本教程学到更多命令后，看看您是否能将相应命令应用到Vim的启动中。同样，作为一个终端命令，您可以将<code>vim</code>命令和其他终端命令联合起来。比如，您可以将<code>ls</code>命令的输出重定向到Vim中编辑，命令是<code>ls -l | vim -</code>。</p>
<h1 id="缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs"><a href="#缓冲区-Buffers-，窗口-Windows-和选项卡-Tabs" class="headerlink" title="缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)"></a>缓冲区(Buffers)，窗口(Windows)和选项卡(Tabs)</h1><p>确保您的vimrc文件中开启了<code>set hidden</code></p>
<h2 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h2><p>buffer就是内存中的一块空间，您可以在这里写入或编辑文本。当您在Vim中打开一个文件时，文件的数据就与一个buffer绑定。当您在Vim中打开3个文件，您就有3个buffers。</p>
<p>运行<code>:buffers</code>命令可以查看所有的buffers（另外，您也可以使用<code>:ls</code>和<code>:files</code>命令）</p>
<h3 id="遍历所有buffers"><a href="#遍历所有buffers" class="headerlink" title="遍历所有buffers"></a>遍历所有buffers</h3><ul>
<li><code>:bnext</code> 切换至下一个buffer（<code>:bprevious</code>切换至前一个buffer）。</li>
<li><code>:buffer</code> + 文件名。（按下<code>&lt;Tab&gt;</code>键Vim会自动补全文件名）。</li>
<li><code>:buffer</code> + <code>n</code>, n是buffer的编号。比如，输入<code>:buffer 2</code>将使您切换到buffer #2。</li>
<li>按下<code>Ctrl-O</code>将跳转至跳转列表中旧的位置，对应的，按下<code>Ctrl-I</code>将跳转至跳转列表中新的位置。这并不是属于buffer的特有方法，但它可以用来在不同的buffers中跳转。我将在第5章详细讲述关于跳转的知识。</li>
<li>按下<code>Ctrl-^</code>跳转至先前编辑过的buffer。</li>
</ul>
<h3 id="删除buffer"><a href="#删除buffer" class="headerlink" title="删除buffer"></a>删除buffer</h3><ul>
<li><code>:bdelete</code></li>
<li>接收一个buffer编号（<code>:bdelete 3</code>将删除buffer #3）一个文件名（<code>:bdelete</code>然后按<code>&lt;Tab&gt;</code>自动补全文件名）。</li>
</ul>
<h3 id="仅保留当前-buffer"><a href="#仅保留当前-buffer" class="headerlink" title="仅保留当前 buffer"></a>仅保留当前 buffer</h3><p><code>%bd | e#</code></p>
<h3 id="退出Vim-1"><a href="#退出Vim-1" class="headerlink" title="退出Vim"></a>退出Vim</h3><p>顺带说一句，如果您已经打开了多个buffers，您可以使用quit -all来关闭所有的buffers：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall</span><br></pre></td></tr></table></figure>



<p>如果您想关闭所有buffers但不保存，仅需要在后面加<code>!</code>（叹号）就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall!</span><br></pre></td></tr></table></figure>



<p>若要保存所有buffers然后退出，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wqall</span><br></pre></td></tr></table></figure>



<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>一个window就是在buffer上的一个视口</p>
<p>在Vim中，您同样可以拥有多个窗口。</p>
<p>先前我说过，您看到的是<code>file1.js</code>的buffer。但这个说法并不完整，现在这句话得更正一下，您看到的是<code>file1.js </code>的buffer通过 <strong>一个窗口</strong> 显示出来。窗口就是您查看的buffer所使用的视口。</p>
<h3 id="如果您想在窗口之间导航，使用这些快捷键："><a href="#如果您想在窗口之间导航，使用这些快捷键：" class="headerlink" title="如果您想在窗口之间导航，使用这些快捷键："></a>如果您想在窗口之间导航，使用这些快捷键：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-W H    移动光标到左边的窗口</span><br><span class="line">Ctrl-W J    移动光标到下面的窗口</span><br><span class="line">Ctrl-W K    移动光标到上面的窗口</span><br><span class="line">Ctrl-W L    移动光标到右边的窗口</span><br></pre></td></tr></table></figure>



<h3 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h3><ul>
<li><p>split: 垂直排列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:split file2.js</span><br></pre></td></tr></table></figure>


</li>
<li><p>vsplit: 水平排列</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:split file2.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个窗口显示同一个buffer</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:buffer file2.js</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:vsplit filename    垂直分割当前窗口，并在新窗口中打开名为filename的文件。</span><br><span class="line">:split filename     水平分割当前窗口，并在新窗口中打开名为filename的文件。</span><br><span class="line">:new filename       创建一个新窗口并打开名为filename的文件。</span><br></pre></td></tr></table></figure>



<h4 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-W V    打开一个新的垂直分割的窗口</span><br><span class="line">Ctrl-W S    打开一个新的水平分割的窗口</span><br><span class="line">Ctrl-W C    关闭一个窗口</span><br><span class="line">Ctrl-W O    除了当前窗口，关闭所有其他的窗口</span><br></pre></td></tr></table></figure>



<h3 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h3><p>您可以按<code>Ctrl-W C</code>或输入<code>:quit</code>。当您关闭一个窗口后，buffers仍然会在列表中。</p>
<h3 id="上下窗口最大化"><a href="#上下窗口最大化" class="headerlink" title="上下窗口最大化"></a>上下窗口最大化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+_</span><br></pre></td></tr></table></figure>



<h3 id="上下窗口对等大小"><a href="#上下窗口对等大小" class="headerlink" title="上下窗口对等大小"></a>上下窗口对等大小</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+=</span><br></pre></td></tr></table></figure>



<h3 id="左右窗口最大化"><a href="#左右窗口最大化" class="headerlink" title="左右窗口最大化"></a>左右窗口最大化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+|</span><br></pre></td></tr></table></figure>



<h3 id="左右窗口对等"><a href="#左右窗口对等" class="headerlink" title="左右窗口对等"></a>左右窗口对等</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+=</span><br></pre></td></tr></table></figure>



<h3 id="上下窗口大小微调"><a href="#上下窗口大小微调" class="headerlink" title="上下窗口大小微调"></a>上下窗口大小微调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+-</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+-</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+[+]</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+shift+[+]</span><br></pre></td></tr></table></figure>



<h3 id="左右窗口大小微调"><a href="#左右窗口大小微调" class="headerlink" title="左右窗口大小微调"></a>左右窗口大小微调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+shift+&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+shift+&lt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+[num]+shift+&lt;</span><br></pre></td></tr></table></figure>



<h3 id="窗口对调"><a href="#窗口对调" class="headerlink" title="窗口对调"></a>窗口对调</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+x</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 窗口必须是对等的才行 </p>
</blockquote>
<h3 id="窗口轮转"><a href="#窗口轮转" class="headerlink" title="窗口轮转"></a>窗口轮转</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+r/R</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 窗口必须是对等的才行 </p>
</blockquote>
<h3 id="移动所在窗口位置"><a href="#移动所在窗口位置" class="headerlink" title="移动所在窗口位置"></a>移动所在窗口位置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+<span class="variable constant_">HJKL</span></span><br></pre></td></tr></table></figure>



<h3 id="不同窗口跳转"><a href="#不同窗口跳转" class="headerlink" title="不同窗口跳转"></a>不同窗口跳转</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crtl+w+hjkl</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crtl+w、ctrl+w</span><br></pre></td></tr></table></figure>



<h2 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h2><p>Tabs就是windows的集合</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>拥有多个tabs的好处是，您可以在不同的tab中使用不同的窗口布局。也许，您想让您的第1个tab包含3个垂直分割的窗口，然后让第2个tab为水平分割和垂直分割混合的窗口布局。tab是完成这件工作的完美工具!</p>
<h3 id="tab启动"><a href="#tab启动" class="headerlink" title="tab启动"></a>tab启动</h3><ul>
<li><p>导航</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:tabnew file.txt    在tab中打开一个文件</span><br><span class="line">:tabclose           关闭当前tab</span><br><span class="line">:tabnext            切换至下一个tab</span><br><span class="line">:tabprevious        切换至前一个tab</span><br><span class="line">:tablast            切换至最后一个tab</span><br><span class="line">:tabfirst           切换至第一个tab</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gt</code>切换到下一个标签页（对应的，可以用<code>gT</code>切换到前一个标签页）。您也可以传递一个数字作为参数给<code>gt</code>，这个数字是tab的编号。若想切换到第3个tab，输入<code>3gt</code></p>
</li>
<li><p>启动</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim -p file1.js file2.js file3.js</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三维移动"><a href="#三维移动" class="headerlink" title="三维移动"></a>三维移动</h2><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>就像在笛卡尔坐标系的二维平面上沿着X-Y轴移动</p>
<p>使用<code>Ctrl-W H/J/K/L</code>移动到上面、右侧、下面、以及左侧的窗口</p>
<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>在笛卡尔坐标系的Z轴上穿梭，想象您的buffer文件在Z轴上呈线性排列</p>
<p>使用<code>:bnext</code>和<code>bprevious</code>在Z轴上一次一个buffer地遍历。您也可以使用<code>:buffer 文件名/buffer编号</code>在Z轴上跳转到任意坐标</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合window和buffer的移动，您可以在 <em>三维空间</em> 中移动</p>
<p>可以使用window导航命令移动到上面、右侧、下面、或左侧的窗口（X-Y平面导航）</p>
<p>因为每个window都可能包含了多个buffers，您可以使用buffer移动命令向前、向后移动（Z轴导航）</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>首先，对于&#x3D;&#x3D;某个特定任务&#x3D;&#x3D;，我先使用buffers存储所有需要的文件。Vim就算打开很多buffer，速度一般也不会减慢。另外打开多个buffers并不会使我的屏幕变得拥挤。我始终只会看到1个buffer（假设我只有1个window），这可以让我注意力集中在1个屏幕上。当我需要使用其他文件时，可以快速切换至对应文件的buffer。</li>
<li>当&#x3D;&#x3D;比对文件、读文档、或追踪代码流&#x3D;&#x3D;时，我使用&#x3D;&#x3D;多窗口来一次查看多个buffers&#x3D;&#x3D;。我尽量保持屏幕上的&#x3D;&#x3D;窗口数不超过3个&#x3D;&#x3D;，因为超过3个屏幕将变得拥挤（我使用的是小型笔记本）。当相应工作完成后，我就关掉多余的窗口。窗口越少可以使注意力更集中。</li>
<li>我使用<a target="_blank" rel="noopener" href="https://github.com/tmux/tmux/wiki">tmux</a>windows来代替tabs。通常一次使用多个tmux窗口。比如，一个tmux窗口用来写客户端代码，一个用来写后台代码。</li>
</ul>
<h1 id="打开和搜索文件"><a href="#打开和搜索文件" class="headerlink" title="打开和搜索文件"></a>打开和搜索文件</h1><h2 id="打开和编辑文件"><a href="#打开和编辑文件" class="headerlink" title="打开和编辑文件"></a>打开和编辑文件</h2><p>Vim中打开一个文件使用<code>:edit</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit file.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>file.txt</code>已经存在，就会打开<code>file.txt</code>buffer。</li>
<li>如果<code>file.txt</code>不存在，会创建一个新buffer名为<code>file.txt</code>、</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p><code>:edit</code>命令支持使用<code>&lt;Tab&gt;</code>进行自动补全</p>
</li>
<li><p><code>:edit</code>可以接收通配符参数。<code>*</code>匹配当前目录下的任意文件</p>
<ul>
<li><p><code>:edit *.yml&lt;Tab&gt;</code>: Vim将列出当前目录下所有<code>.yml</code>文件供您选择。</p>
</li>
<li><p>可以使用<code>**</code>进行递归的搜索</p>
<ul>
<li><p>查找当前项目文件夹下所有<code>*.md</code>文件，但您不知道在哪个目录，您可以这样做</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:edit **/*.md&lt;Tab&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><code>:edit</code>可以用于运行<code>netrw</code>（Vim的内置文件浏览器）</p>
<ul>
<li><p>使用：给<code>:edit</code>一个目录参数而不是文件名就行了</p>
</li>
<li><p>示例</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:edit .</span><br><span class="line">:edit test/unit/</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="使用find命令搜索文件"><a href="#使用find命令搜索文件" class="headerlink" title="使用find命令搜索文件"></a>使用find命令搜索文件</h2><h3 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h3><p>使用<code>:find</code>命令搜索文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:find package.json</span><br><span class="line">:find app/controllers/users_controller.rb</span><br></pre></td></tr></table></figure>

<p><code>:find</code>命令同样支持自动补全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:find p&lt;Tab&gt;                &quot; to find package.json</span><br><span class="line">:find a&lt;Tab&gt;c&lt;Tab&gt;u&lt;Tab&gt;    &quot; to find app/controllers/users_controller.rb</span><br></pre></td></tr></table></figure>



<h2 id="Find-和-Path"><a href="#Find-和-Path" class="headerlink" title="Find 和 Path"></a>Find 和 Path</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>:find</code>命令根据<code>path</code>选项配置的路径查找文件</li>
<li><code>:edit</code>不会</li>
</ul>
<p>查看一下您的<code>path</code>是什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path?</span><br></pre></td></tr></table></figure>

<p>默认情况下，您的<code>path</code>内容很可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path=.,/usr/include,,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code> 意思是在当前文件所在目录下搜索。(译者注：注意不是命令行输入pwd返回的当前目录，而是 <strong>当前所打开的文件</strong> 所在的目录)</li>
<li><code>,</code> means to search in the current directory.(译者注：此处貌似作者有点小错误，逗号<code>,</code>应该是表示路径之间的分割符。连续的两个<code>,,</code>（两个逗号之间为空）才表示当前目录)</li>
<li><code>/usr/include</code> 表示在C编译器头文件目录下搜索。</li>
</ul>
<p>将<code>app/controllers/</code>添加到当前<code>path</code>选项。以下是操作步骤</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path+=app/controllers/</span><br></pre></td></tr></table></figure>

<p>现在您的路径已经更新，当您输入<code>:find u&lt;Tab&gt;</code>时，Vim将会在<code>app/controllers/</code>目录内搜索所有以”u”开头的文件。</p>
<p>如果您有一个嵌套的目录<code>controllers/</code>，比如<code>app/controllers/account/users_controller.rb</code>，Vim就找不到<code>users_controllers</code>了。您必须改为添加<code>:set path+=app/controllers/**</code></p>
<p>将整个项目文件夹添加到<code>path</code>中，这样当您按<code>&lt;Tab&gt;</code>，Vim将在所有文件夹内搜索您要找的文件，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path+=$PWD/**</span><br></pre></td></tr></table></figure>

<ul>
<li>建议仅仅将您最常访问的文件&#x2F;目录添加到<code>path</code></li>
<li>您可以将<code>set path+=&#123;您需要添加的目录&#125;</code>添加到您的vimrc文件中。更新<code>path</code>仅花费几秒钟，但可以为您的工作节省很多时间。</li>
</ul>
<h2 id="使用Grep命令在文件中搜索"><a href="#使用Grep命令在文件中搜索" class="headerlink" title="使用Grep命令在文件中搜索"></a>使用Grep命令在文件中搜索</h2><p>如果您想在文件内部查找（搜索文件中的词句），您可以使用grep。Vim有两个方法可以完成这个工作：</p>
<ul>
<li>内置grep （<code>:vim</code>。没错，就是<code>:vim</code>，它是<code>:vimgrep</code>的简写）。</li>
<li>外部grep (<code>:grep</code>)。</li>
</ul>
<h3 id="内置grep"><a href="#内置grep" class="headerlink" title="内置grep"></a>内置grep</h3><p><code>:vim</code>有以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vim /pattern/ file</span><br></pre></td></tr></table></figure>

<ul>
<li><code>/pattern/</code> 是您要搜索的内容的正则表达式。</li>
<li><code>file</code> 是文件参数。您可以传入多个参数。Vim将在文件中搜索所有匹配正则表达式的内容。类似于<code>:find</code>，您可以传入*和**通配符。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>比如，要在<code>app/controllers/</code>目录下所有ruby文件(<code>.rb</code>)中，查找所有的”breakfast”字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vim /breakfast/ app/controllers/**/*.rb</span><br></pre></td></tr></table></figure>

<p>输入上面的命令后，您将会被导航到第一个结果。Vim的<code>vim</code>搜索命令使用<code>quickfix</code>进行处理。要查看所有搜索结果，运行<code>:copen</code>会打开一个<code>quickfix</code>窗口。下面有一些有用的quickfix命令，可以让您提高效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:copen        打开quickfix窗口</span><br><span class="line">:cclose       关闭quickfix窗口</span><br><span class="line">:cnext        跳到下一个错误</span><br><span class="line">:cprevious    跳到前一个错误</span><br><span class="line">:colder       跳到旧的错误列表</span><br><span class="line">:cnewer       跳到新的错误列表</span><br></pre></td></tr></table></figure>

<p>缺点：慢，如果匹配结果数量较多时系统速度会变慢。这是因为Vim将每一个搜索结果读入内存。Vim加载每一个匹配的文件就像它们被编辑一样。如果Vim查到大量文件，它将消耗很多内存</p>
<h3 id="外置grep"><a href="#外置grep" class="headerlink" title="外置grep"></a>外置grep</h3><p>默认情况下，它使用终端命令<code>grep</code>。要想在<code>app/controllers/</code>目录中搜索字符串”lunch”，您可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:grep -R &quot;lunch&quot; app/controllers/</span><br></pre></td></tr></table></figure>

<p>注意这里不是使用<code>/pattern/</code>，它遵循的是终端grep的语法<code>&quot;pattern&quot;</code>，它同样使用’quickfix’来显示所有的匹配结果。</p>
<p>Vim使用<code>grepprg</code>变量来决定运行<code>:grep</code>时，应该使用哪个外部程序。所以您并不是非得使用终端的<code>grep</code>命令。稍后我将为您演示如何改变外部grep程序的默认值。</p>
<h2 id="用Netrw浏览文件"><a href="#用Netrw浏览文件" class="headerlink" title="用Netrw浏览文件"></a>用Netrw浏览文件</h2><p><a target="_blank" rel="noopener" href="https://github.com/preservim/nerdtree">NERDTree</a> 是一个很好的选择</p>
<h2 id="Fzf插件"><a href="#Fzf插件" class="headerlink" title="Fzf插件"></a>Fzf插件</h2><p>略</p>
<h1 id="第4章-Vim-语法"><a href="#第4章-Vim-语法" class="headerlink" title="第4章 Vim 语法"></a>第4章 Vim 语法</h1><p>刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用<code>gUfV</code>或<code>1GdG</code>，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。</p>
<p>这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vim语言时，我讨论并不是<br>Vimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。</p>
<h2 id="如何学习一门语言"><a href="#如何学习一门语言" class="headerlink" title="如何学习一门语言"></a>如何学习一门语言</h2><p>我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：</p>
<ol>
<li>学习语法规则</li>
<li>扩展我的词汇量</li>
<li>练习，练习，练习</li>
</ol>
<p>同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。</p>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun # 动词 + 名词</span><br></pre></td></tr></table></figure>

<p>这就类似与在英语中的祈使句：</p>
<ul>
<li>“Eat(verb) a donut(noun)”</li>
<li>“Kick(verb) a ball(noun)”</li>
<li>“Learn(verb) the Vim Editor(noun)”</li>
</ul>
<p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p>
<h2 id="名词-动作-Motion"><a href="#名词-动作-Motion" class="headerlink" title="名词(动作 Motion)"></a>名词(动作 Motion)</h2><p>我们这里将 <strong>动作 Motion</strong> 作为名词， <strong>动作Motion</strong>用来在Vim中到处移动。下面列出了一些常见的<strong>动作</strong>的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h	左</span><br><span class="line">j	下</span><br><span class="line">k	上</span><br><span class="line">l	右</span><br><span class="line">w	向前移动到下一个单词的开头</span><br><span class="line">&#125;	跳转到下一个段落</span><br><span class="line">$	跳转到当前行的末尾</span><br></pre></td></tr></table></figure>

<p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些<strong>动作</strong>也不必担心。</p>
<h2 id="动词-操作符-Operator"><a href="#动词-操作符-Operator" class="headerlink" title="动词(操作符 Operator)"></a>动词(操作符 Operator)</h2><p>根据<code>:h operator</code>，Vim共有16个<strong>操作符</strong>，然而根据我的经验，学习这3个<strong>操作符</strong>在80%的情况下就已经够用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y	yank(复制)</span><br><span class="line">d	delete(删除)</span><br><span class="line">c	change 删除文本，将删除的文本存到寄存器中，进入插入模式</span><br></pre></td></tr></table></figure>

<p>顺带说一句，当你yank一段文本后，您可以使用<code>p</code>将它粘贴到光标后，或使用<code>P</code>粘贴到光标前。</p>
<h2 id="动词（操作符-Operator）和名词（动作-motions）的结合"><a href="#动词（操作符-Operator）和名词（动作-motions）的结合" class="headerlink" title="动词（操作符 Operator）和名词（动作 motions）的结合"></a>动词（操作符 Operator）和名词（动作 motions）的结合</h2><p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则，动词和名词的结合！假设你有下面这段文本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> learn = <span class="string">&quot;Vim&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>复制当前位置到行尾的所有内容：<code>y$</code></li>
<li>删除当前位置到下一个单词的开头：<code>dw</code></li>
<li>修改当前位置到这个段落的结尾：<code>c&#125;</code></li>
</ul>
<p><strong>动作 motions</strong>也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用<code>3k</code>代替按3次<code>k</code>，数字可应用在Vim语法中。</p>
<ul>
<li>向左拷贝2个字符：<code>y2h</code></li>
<li>删除后两个单词：<code>d2w</code></li>
<li>修改后面两行：<code>c2j</code></li>
</ul>
<p>目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。唯一途径就是重复、重复再重复。</p>
<p>作为补充，行级的 <strong>操作符 operations</strong> (作用在整行中的操作符)在文本编辑中和其他的 <strong>操作符</strong> 一样，Vim允许你通过按两次 <strong>操作符</strong>使它执行行级的操作，例如<code>dd</code>，<code>yy</code>，<code>cc</code>来执行删除，复制或修改整个行。您可以使用其他operations试一下（比如<code>gUgU</code>）。</p>
<p>666!从这可以看出Vim命令的一种执行模式。但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)</p>
<h2 id="更多名词-文本对象-Text-Objects"><a href="#更多名词-文本对象-Text-Objects" class="headerlink" title="更多名词(文本对象 Text Objects)"></a>更多名词(文本对象 Text Objects)</h2><p>想象一下你现在正在某个被括号包围的文本中例如<code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？</p>
<p>答案是有的。文本通常是结构化的，特别是代码中，文本经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。</p>
<p>文本对象可以被 <strong>操作符 operations</strong> 使用，这里有两类文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i + object  内部文本对象</span><br><span class="line">a + object  外部文本对象</span><br></pre></td></tr></table></figure>

<p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多。如果你的光标位于一对括号内部，例如<code>(hello Vim)</code>中：</p>
<ul>
<li>删除括号内部的内容但保留括号：<code>di(</code></li>
<li>删除括号以及内部的内容：<code>da(</code></li>
</ul>
<p>让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在”Hello”中的”H”上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello Vim&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除整个”Hello Vim”：<code>di(</code></li>
<li>删除整个函数(被{}包含)：<code>di&#123;</code></li>
<li>删除”Hello”这个词：<code>diw</code></li>
</ul>
<p>文本对象很强大因为你可以在同一个位置指向不同的内容，可以删除一对小括号中的文本，也可以是当前大括号中的函数体，也可以是当前单词。这一点也很好记忆，当你看到<code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么：小括号，大括号，单词。</p>
<p>让我们来看最后一个例子。假设你有这样一些html的标签的文本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你的光标位于”Header1”文本上：</p>
<ul>
<li>删除”Header1”：<code>dit</code></li>
<li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：<code>dat</code></li>
</ul>
<p>如果你的光标在”div”文本上：</p>
<ul>
<li>删除<code>h1</code>和所有<code>p</code>标签的行：<code>dit</code></li>
<li>删除所有文本：<code>dat</code></li>
<li>删除”div”：<code>di&lt;</code></li>
</ul>
<p>下面列举的一些通常见到的文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w     一个单词</span><br><span class="line">p     一个段落</span><br><span class="line">s     一个句子</span><br><span class="line">(或)  一对()</span><br><span class="line">&#123;或&#125;  一对&#123;&#125;</span><br><span class="line">[或]  一对[]</span><br><span class="line">&lt;或&gt;  一对&lt;&gt;</span><br><span class="line">t     XML标签</span><br><span class="line">&quot;     一对&quot;&quot;</span><br><span class="line">&#x27;     一对&#x27;&#x27;</span><br><span class="line">`     一对``</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>:h text-objects</code>了解更多</p>
<h2 id="结合性和语法"><a href="#结合性和语法" class="headerlink" title="结合性和语法"></a>结合性和语法</h2><p>在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。</p>
<p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。</p>
<p>Vim的结合性最强大之处体现在它和外部程序结合时，Vim有一个 <strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id|Name|Cuteness</span><br><span class="line">01|Puppy|Very</span><br><span class="line">02|Kitten|Ok</span><br><span class="line">03|Bunny|Ok</span><br></pre></td></tr></table></figure>

<p>这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令<code>column</code>很快的完成它，当你的光标位于”Id”上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id  Name    Cuteness</span><br><span class="line">01  Puppy   Very</span><br><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>

<p>让我们分解一下上面那条命令，动词是<code>!</code>(<strong>过滤操作符</strong>)，名词是<code>&#125;</code>(到下一个段落)。<strong>过滤操作符</strong><code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本。</p>
<p>假设你不止想格式化你的文本，还想只展示<code>Ok</code>结尾的行，你知道<code>awk</code>命令可以做这件事情，那么你可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&#125;column -t -s &quot;|&quot; | awk &#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>
<p>666！管道竟然在Vim中也能起作用。</p>
<p>这就是Vim的结合性的强大之处。你知道的动词 <strong>操作符</strong>，名词 <strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长。</p>
<p>换句话说，假设你只知道四个<strong>动作</strong>：<code>w, $, &#125;, G</code>和删除操作符(<code>d</code>)，你可以做8件事：按四种方式移动(<code>w, $, &#125;, G</code>)和删除4种文本对象(<code>dw, d$, d&#125;, dG</code>)。如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的Vim工具箱中多的不是1种工具，而是4种：<code>gUw, gU$, gU&#125;, gUG</code>。现在你的Vim工具箱中就有12种工具了。如果你知道10个<strong>动作</strong>和5个<strong>操作符</strong>，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(<code>nG</code>)给你了<code>n</code>种<strong>动作</strong>，其中<code>n</code>是你文件中的行数(例如前往第5行，<code>5G</code>)。搜索动作(<code>/</code>)实际上给你带来无限数量的<strong>动作</strong>因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(<code>!</code>)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。</p>
<p>这种具有结合性的行为也正符合Unix的哲学：<em>一个命令做好一件事</em>。<strong>动作</strong>只需要做一件事：前往X。<strong>操作符</strong>只需要做一件事：完成Y。通过结合一个<strong>操作符</strong>和一个<strong>动作</strong>，你就获得了YX：在X上完成Y。</p>
<p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造<strong>动作</strong>和<strong>操作符</strong>去丰富你的Vim工具箱，<a target="_blank" rel="noopener" href="https://github.com/kana/vim-textobj-user"><code>Vim-textobj-user</code></a>插件允许你创建自己的文本对象，同时包含有<a target="_blank" rel="noopener" href="https://github.com/kana/vim-textobj-user/wiki">一系列定义好的文本对象</a>。</p>
<p>另外，如果你不知道我刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。</p>
<h2 id="聪明地学习语法"><a href="#聪明地学习语法" class="headerlink" title="聪明地学习语法"></a>聪明地学习语法</h2><p>你刚刚学完Vim唯一的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun</span><br></pre></td></tr></table></figure>
<p>我学Vim中最大的”AHA moment”之一是当我刚学完大写命令(<code>gU</code>)时，想要把一个单词变成大写，我本能的运行了<code>gUiW</code>，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的”AHA moment”，如果之前没有的话。</p>
<p>这一章的目标是向你展现Vim中的<code>verb+noun</code>模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。</p>
<p>学习这种模式并且理解其中的含义，这是聪明的学习方式。</p>
<h1 id="第5章-在文件中移动"><a href="#第5章-在文件中移动" class="headerlink" title="第5章 在文件中移动"></a>第5章 在文件中移动</h1><p>一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。</p>
<p>这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令(motions)，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>。</p>
<h2 id="字符导航"><a href="#字符导航" class="headerlink" title="字符导航"></a>字符导航</h2><p>最基本的移动单元是上下左右移动一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h   左</span><br><span class="line">j   下</span><br><span class="line">k   上</span><br><span class="line">l   右</span><br></pre></td></tr></table></figure>

<p>你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。</p>
<p>我更喜欢<code>hjkl</code>因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过<code>~/.vimrc</code>关闭了方向键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;Up&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Down&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Left&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Right&gt; &lt;NOP&gt;</span><br></pre></td></tr></table></figure>

<p>也有一些插件可以帮助改掉这个坏习惯，其中有一个叫<a target="_blank" rel="noopener" href="https://github.com/takac/vim-hardtime">vim-hardtime</a>。 让我感到惊讶的是，我只用了几天就习惯了使用<code>hjkl</code>。</p>
<p>另外，如果你想知道为什么Vim使用<code>hjkl</code>进行移动，<em>这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把<code>hjkl</code>当做方向键</em>。</p>
<p>如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用<code>h</code>和<code>l</code>。 如果我需要在可见的范围内上下移动几行，我会使用<code>j</code>和<code>k</code>。 如果我想去更远的地方，我倾向于使用其他移动命令。</p>
<h2 id="相对行号"><a href="#相对行号" class="headerlink" title="相对行号"></a>相对行号</h2><p>我觉得设置<code>number</code>和<code>relativenumber</code>非常有用，你可以在<code>~/.vimrc</code>中设置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set relativenumber number</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这将会展示当前行号和其他行相对当前行的行号&#x3D;&#x3D;。</p>
<p>为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用<code>12j</code>去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69&#x3D;12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。</p>
<p>这是一个100%的个人偏好，你可以尝试<code>relativenumber</code>&#x2F;<code>norelativenumber</code>，<code>number</code>&#x2F;<code>nonumber</code> 然后选择自己觉得最有用的。</p>
<h2 id="对移动计数"><a href="#对移动计数" class="headerlink" title="对移动计数"></a>对移动计数</h2><p>在继续之前，让我们讨论一下”计数”参数。 一个移动(motion)可以接受一个数字前缀作为参数，上面我提到的你可以通过<code>12j</code>向下移动12行，其中<code>12j</code>中的<code>12</code>就是计数数字。</p>
<p>你使用带计数的移动的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[计数] + 移动</span><br></pre></td></tr></table></figure>

<p>你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用<code>9l</code>来代替按9次<code>l</code>。 当你学到了更多的动作时，你都可以试试给定计数参数。</p>
<h2 id="单词导航"><a href="#单词导航" class="headerlink" title="单词导航"></a>单词导航</h2><p>我们现在移动一个更长的单元：单词(word)。 你可以通过<code>w</code>移动到下一个单词的开始，通过<code>e</code>移动到下一个单词的结尾，通过<code>b</code>移动到上一个单词的开始，通过<code>ge</code>移动到前一个单词的结尾。</p>
<p>另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过<code>W</code>移动到下一个词组的开始，通过<code>E</code>移动到下一个词组的结尾，通过<code>B</code>移动到前一个词组的开头，通过<code>gE</code>移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w		移动到下一个单词的开头</span><br><span class="line">W		移动到下一个词组的开头</span><br><span class="line">e		移动到下一个单词的结尾</span><br><span class="line">E		移动到下一个词组的结尾</span><br><span class="line">b		移动到前一个单词的开头</span><br><span class="line">B		移动到前一个词组的开头</span><br><span class="line">ge	移动到前一个单词的结尾</span><br><span class="line">gE	移动到前一个词组的结尾</span><br></pre></td></tr></table></figure>

<p>词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-zA-Z0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过<code>:h word</code>和<code>:h WORD</code>了解更多。</p>
<p>例如，假如你有下面这段内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>

<p>当你光标位于这行的开头时，你可以通过<code>l</code>走到行尾，但是你需要按21下，使用<code>w</code>，你需要6下，使用<code>W</code>只需要4下。 单词和词组都是短距离移动的很好的选择。</p>
<p>然而，之后你可以通过当前行导航只按一次从<code>c</code>移动到<code>;</code>。</p>
<h2 id="当前行导航"><a href="#当前行导航" class="headerlink" title="当前行导航"></a>当前行导航</h2><p>当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过<code>0</code>跳到本行第一个字符，通过<code>$</code>跳到本行最后一个字符。 另外，你可以使用<code>^</code>跳到本行第一个非空字符，通过<code>g_</code>跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用<code>n|</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0		跳到本行第一个字符</span><br><span class="line">^		跳到本行第一个非空字符</span><br><span class="line">g_      跳到本行最后一个非空字符</span><br><span class="line">$		跳到本行最后一个字符</span><br><span class="line">n|      跳到本行第n列</span><br></pre></td></tr></table></figure>

<p>你也可以在本行通过<code>f</code>和<code>t</code>进行行内搜索，<code>f</code>和<code>t</code>的区别在于<code>f</code>会停在第一个匹配的字母上，<code>t</code>会停在第一个匹配的字母前。 因此如果你想要搜索并停留在”h”上，使用<code>fh</code>。 如果你想搜索第一个”h”并停留在它的前一个字母上，可以使用<code>th</code>。 如果你想去下一个行内匹配的位置，使用<code>;</code>，如果你想去前一个行内匹配的位置，使用<code>,</code>。</p>
<p><code>F</code>和<code>T</code>是<code>f</code>和<code>t</code>对应的向后搜索版本。如果想向前搜索”h”，可以使用<code>Fh</code>，使用<code>;</code>，保持相同的搜索方向搜索下一个匹配的字母。 注意，<code>;</code>不是总是向后搜索，<code>;</code>表示的是上一次搜索的方向，因此如果你使用的<code>F</code>，那么使用<code>;</code>时将会向前搜索使用<code>,</code>时向后搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f   在同一行向后搜索第一个匹配</span><br><span class="line">F   在同一行向前搜索第一个匹配</span><br><span class="line">t   在同一行向后搜索第一个匹配，并停在匹配前</span><br><span class="line">T   在同一行向前搜索第一个匹配，并停在匹配前</span><br><span class="line">;   在同一行重复最近一次搜索</span><br><span class="line">,   在同一行向相反方向重复最近一次搜索</span><br></pre></td></tr></table></figure>

<p>回到上一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>

<p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符”;”。 如果想去往”world”中的”w”，你可以使用<code>fw</code>。 一个建议是，&#x3D;&#x3D;在行内目标附近通过寻找重复出现最少的字母例如”j”，”x”，”z”来前往行中的该位置更快&#x3D;&#x3D;。</p>
<h2 id="句子和段落导航"><a href="#句子和段落导航" class="headerlink" title="句子和段落导航"></a>句子和段落导航</h2><p>接下来两个移动的单元是句子和段落。</p>
<p>首先我们来聊聊句子。 一个句子的定义是以<code>.!?</code>和跟着的一个换行符或空格，tab结尾的。 你可以通过<code>)</code>和<code>(</code>跳到下一个和上一个句子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(   跳到前一个句子</span><br><span class="line">)   跳到下一个句子</span><br></pre></td></tr></table></figure>

<p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用<code>(</code>和<code>)</code>感受一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :</span><br><span class="line"></span><br><span class="line">There is an empty line above me.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，如果你的Vim中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于<code>compatible</code>的模式。 运行<code>:set nocompatible</code>可以修复。 在Vi中，一个句子是以<strong>两个</strong>空格结尾的，你应该总是保持的<code>nocompatible</code>的设置。</p>
<p>接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项(<code>paragraphs</code>)中”字符对”所指定的段落宏的每个集合开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;   跳转到上一个段落</span><br><span class="line">&#125;   跳转到下一个段落</span><br></pre></td></tr></table></figure>

<p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。</p>
<p>我们来看这个例子。 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>()</code>这样的句子导航。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello. How are you? I am great, thanks!</span><br><span class="line">Vim is awesome.</span><br><span class="line">It may not easy to learn it at first...- but we are in this together. Good luck!</span><br><span class="line"></span><br><span class="line">Hello again.</span><br><span class="line"></span><br><span class="line">Try to move around with ), (, &#125;, and &#123;. Feel how they work.</span><br><span class="line">You got this.</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多。</p>
<h2 id="匹配导航"><a href="#匹配导航" class="headerlink" title="匹配导航"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过<code>%</code>跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%    Navigate to another match, usually works for (), [], &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用<code>%</code>移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define (fib n)</span><br><span class="line">  (cond ((= n 0) 0)</span><br><span class="line">        ((= n 1) 1)</span><br><span class="line">        (else</span><br><span class="line">          (+ (fib (- n 1)) (fib (- n 2)))</span><br><span class="line">        )))</span><br></pre></td></tr></table></figure>

<p>我个人喜欢使用类似<a target="_blank" rel="noopener" href="https://github.com/frazrepo/vim-rainbow">vim-rainbow</a>这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多。</p>
<h2 id="行号导航"><a href="#行号导航" class="headerlink" title="行号导航"></a>行号导航</h2><p>你可以通过<code>nG</code>调到行号为<code>n</code>的行，例如如果你想跳到第7行，你可以使用<code>7G</code>，跳到第一行使用<code>gg</code>或<code>1G</code>，跳到最后一行使用<code>G</code>。</p>
<p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用<code>70%</code>跳过去，可以使用<code>50%</code>跳到文件的中间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gg      跳转到第一行</span><br><span class="line">G       跳转到最后一行</span><br><span class="line">nG      跳转到第n行</span><br><span class="line">n%      跳到文件的n%</span><br></pre></td></tr></table></figure>

<p>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看。</p>
<h2 id="窗格导航"><a href="#窗格导航" class="headerlink" title="窗格导航"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>。</p>
<p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀。 如果你输入<code>10H</code>你会跳转到窗格顶部往下数10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H   跳转到屏幕的顶部</span><br><span class="line">M   跳转到屏幕的中间</span><br><span class="line">L   跳转到屏幕的底部</span><br><span class="line">nH  跳转到距离顶部n行的位置</span><br><span class="line">nL  跳转到距离底部n行的位置</span><br></pre></td></tr></table></figure>

<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><p>在文件中滚动，你有三种速度可以选择： 滚动一整页(<code>CTRL-F</code>&#x2F;<code>CTRL-B</code>)，滚动半页(<code>CTRL-D</code>&#x2F;<code>CTRL-U</code>)，滚动一行<code>CTRL-E</code>&#x2F;<code>CTRL-Y</code>)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-e    向下滚动一行</span><br><span class="line">Ctrl-d    向下滚动半屏</span><br><span class="line">Ctrl-f    向下滚动一屏</span><br><span class="line">Ctrl-y    向上滚动一行</span><br><span class="line">Ctrl-u    向上滚动半屏</span><br><span class="line">Ctrl-b    向上滚动一屏</span><br></pre></td></tr></table></figure>

<p>你也可以相对当前行进行滚动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zt    将当前行置于屏幕顶部附近</span><br><span class="line">zz    将当前行置于屏幕中央</span><br><span class="line">zb    将当前行置于屏幕底部</span><br></pre></td></tr></table></figure>

<h2 id="搜索导航"><a href="#搜索导航" class="headerlink" title="搜索导航"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过<code>/</code>向下搜索，也可以通过<code>?</code>向上搜索一个字段。 你可以通过<code>n</code>重复最近一次搜索，<code>N</code>向反方向重复最近一次搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/   向后搜索一个匹配</span><br><span class="line">?   向前搜素一个匹配</span><br><span class="line">n   重复上一次搜索(和上一次方向相同)</span><br><span class="line">N   重复上一次搜索(和上一次方向相反)</span><br></pre></td></tr></table></figure>

<p>假设你有一下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">one = &quot;01&quot;;</span><br><span class="line">one = &quot;one&quot;;</span><br><span class="line">let onetwo = 12;</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>/let</code>搜索”let”，然后通过<code>n</code>快速的重复搜索下一个”let”，如果需要向相反方向搜索，可以使用<code>N</code>。 如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索”let”)。</p>
<p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段。 另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>。 因为我经常使用这个功能，所以我会设置一个映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;esc&gt;&lt;esc&gt; :noh&lt;return&gt;&lt;esc&gt;</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>*</code>快速的向前搜索光标下的文本，通过<code>#</code>快速向后搜索光标下的文本。 如果你的光标位于一个字符串”one”上，按下<code>*</code>相当于<code>/\&lt;one\&gt;</code>。<br><code>/\&lt;one\&gt;</code>中的<code>\&lt;</code>和<code>\&gt;</code>表示整词匹配，使得一个更长的包含”one”的单词不会被匹配上，也就是说它会匹配”one”，但不会匹配”onetwo”。 如果你的光标在”one”上并且你想向后搜索完全或部分匹配的单词，例如”one”和”onetwo”，你可以用<code>g*</code>替代<code>*</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   向后查找光标所在的完整单词</span><br><span class="line">#   向前查找光标所在的完整单词</span><br><span class="line">g*  向后搜索光标所在的单词</span><br><span class="line">g#  向前搜索光标所在的单词</span><br></pre></td></tr></table></figure>

<h2 id="位置标记"><a href="#位置标记" class="headerlink" title="位置标记"></a>位置标记</h2><p>你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过<code>mx</code>设置一个标记，其中<code>x</code>可以是<code>a-zA-Z</code>。 有两种办法能回到标记的位置： 用<code> `x</code>精确回到(行和列)，或者用<code>&#39;x</code>回到行级位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ma    用a标签标记一个位置</span><br><span class="line">`a    精确回到a标签的位置(行和列)</span><br><span class="line">&#x27;a    跳转到a标签的行</span><br></pre></td></tr></table></figure>

<p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。</p>
<p>我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记”a”(<code>ma</code>)，然后在另一个文件中设置另一个标记”a”(<code>ma</code>)。</p>
<p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在<code>myFile.txt</code>中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目中，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。</p>
<p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-zA-Z</code>以外还有别的标签，其中有一些例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;   在当前buffer中跳转回到上一次跳转前的最后一行</span><br><span class="line">``  在当前buffer中跳转回到上一次跳转前的最后一个位置</span><br><span class="line">`[  跳转到上一次修改或拷贝的文本的开头</span><br><span class="line">`]  跳转到上一次修改或拷贝的文本的结尾</span><br><span class="line">`&lt;  跳转到最近一次可视模式下选择的部分的开头</span><br><span class="line">`&gt;  跳转到最近一次可视模式下选择的部分的结尾</span><br><span class="line">`0  跳转到退出Vim前编辑的最后一个文件</span><br></pre></td></tr></table></figure>

<p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看。</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用<code>j</code>向下移动一行就不被看做一个跳转，即使你使用<code>10j</code>向下移动10行，也不是一个跳转。 但是你通过<code>10G</code>去往第10行被算作一个跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x27;   跳转到标记的行</span><br><span class="line">`   跳转到标记的位置(行和列)</span><br><span class="line">G   跳转到行</span><br><span class="line">/   向后搜索</span><br><span class="line">?   向前搜索</span><br><span class="line">n   重复上一次搜索，相同方向</span><br><span class="line">N   重复上一次搜索，相反方向</span><br><span class="line">%   查找匹配</span><br><span class="line">(   跳转上一个句子</span><br><span class="line">)   跳转下一个句子</span><br><span class="line">&#123;   跳转上一个段落</span><br><span class="line">&#125;   跳转下一个段落</span><br><span class="line">L   跳转到当前屏幕的最后一行</span><br><span class="line">M   跳转到当前屏幕的中间</span><br><span class="line">H   跳转到当前屏幕的第一行</span><br><span class="line">[[  跳转到上一个小节</span><br><span class="line">]]  跳转到下一个小节</span><br><span class="line">:s  替换</span><br><span class="line">:tag  跳转到tag定义</span><br></pre></td></tr></table></figure>
<p>我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>。</p>
<p>为什么跳转有用呢? 因为你可以在跳转列表中通过<code>Ctrl-o</code>和<code>Ctrl-i</code>在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。</p>
<h2 id="聪明地学习导航"><a href="#聪明地学习导航" class="headerlink" title="聪明地学习导航"></a>聪明地学习导航</h2><p>如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。</p>
<p>我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从<code>h,j,k,l,w,b,G,/,?,n</code>开始，不断地重复这10个移动知道形成肌肉记忆，这花不了多少时间。</p>
<p>为了让你更擅长导航，我有两个建议：</p>
<ol>
<li>注意重复的动作。 如果你发现你自己在重复的使用<code>l</code>，你可以去找一个方法让你前进的更快，然后你会发现你可以用<code>w</code>在单词间移动。 如果你发现你自己的重复的使用<code>w</code>，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用<code>$</code>。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。</li>
<li>当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。</li>
</ol>
<p>最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。</p>
<p>慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。</p>
<h1 id="第6章-输入模式"><a href="#第6章-输入模式" class="headerlink" title="第6章 输入模式"></a>第6章 输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。</p>
<p>尽管如此，这并不代表输入模式没什么好学的。Vim的输入模式包含许多有用功能。在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。</p>
<h2 id="进入输入模式的方法"><a href="#进入输入模式的方法" class="headerlink" title="进入输入模式的方法"></a>进入输入模式的方法</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i    从光标之前的位置开始输入文本</span><br><span class="line">I    从当前行第一个非空字符之前的位置之前开始输入文本</span><br><span class="line">a    在光标之后的位置追加文本</span><br><span class="line">A    在当前行的末尾追加文本</span><br><span class="line">o    在光标位置下方新起一行并开始输入文本</span><br><span class="line">O    在光标位置的上方新起一行并开始输入文本</span><br><span class="line">s    删除当前光标位置的字符并开始输入文本</span><br><span class="line">S    删除当前行并开始输入文本</span><br><span class="line">gi   从当前缓冲区上次结束输入模式的地方开始输入文本</span><br><span class="line">gI   在当前行的第一列的位置开始输入文本</span><br></pre></td></tr></table></figure>

<p>值得注意的是这些命令的小写&#x2F;大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。</p>
<h2 id="退出输入模式的方法"><a href="#退出输入模式的方法" class="headerlink" title="退出输入模式的方法"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;esc&gt;     退出输入模式进入普通模式</span><br><span class="line">Ctrl-[    退出输入模式进入普通模式</span><br><span class="line">Ctrl-c    与 Ctrl-[ 和 &lt;esc&gt;功能相同, 但是不检查缩写</span><br></pre></td></tr></table></figure>

<p>我发现<code> esc</code>键在键盘上太远了，很难够到，所以我在我的机器上将<code> caps lock</code> 映射成了<code>esc</code>键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现<code>esc</code>键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在<code>q</code>键的左边，所以我认为将<code>caps lock</code> 映射成<code>esc</code>键是合理的。</p>
<p>另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap jj &lt;esc&gt;</span><br><span class="line">inoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure>

<h2 id="重复输入模式"><a href="#重复输入模式" class="headerlink" title="重复输入模式"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10i</span><br></pre></td></tr></table></figure>

<p>如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p>
<h2 id="在输入模式中删除大块文本"><a href="#在输入模式中删除大块文本" class="headerlink" title="在输入模式中删除大块文本"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用<code>d</code>来删除错误。或者，你能用以下命令在&#x3D;&#x3D;输入模式下就删除一个或者多个字符&#x3D;&#x3D;：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure>

<p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）</p>
<h2 id="用寄存器进行输入"><a href="#用寄存器进行输入" class="headerlink" title="用寄存器进行输入"></a>用寄存器进行输入</h2><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键<code>Ctrl-r</code>加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。</p>
<p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ayiw</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a</li>
<li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。</li>
</ul>
<p>现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r a</span><br></pre></td></tr></table></figure>

<p>Vim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。</p>
<h2 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h2><p>你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键<code>Ctrl-x</code>进入<code>Ctrl-x</code>子模式，你可以进行一些额外操作，页面滚动正是其中之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-y    向上滚动页面</span><br><span class="line">Ctrl-x Ctrl-e    向下滚动页面</span><br></pre></td></tr></table></figure>

<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>Vim在进入<code>Ctrl-x</code>子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。</p>
<p>下面列出了一些适合入门时学习的自动补全命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-l	   补全一整行</span><br><span class="line">Ctrl-x Ctrl-n	   从当前文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-i	   从引用（include）的文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-f	   补全一个文件名</span><br></pre></td></tr></table></figure>

<p>当你触发自动补全时，Vim会显示一个选项弹窗，可以使用<code>Ctrl-n</code>和<code>Ctrl-p</code>来分别向上和向下浏览选项。</p>
<p>Vim也提供了两条不需要进入<code>Ctrl-x</code>模式就能使用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-n             使用下一个匹配的单词进行补全</span><br><span class="line">Ctrl-p             使用上一个匹配的单词进行补全</span><br></pre></td></tr></table></figure>

<p>通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是”Chocolate donuts are the best”：</p>
<ul>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-x Ctrl-l</code>， Vim会进行匹配并输出这一整行的文本。</li>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-p</code>，Vim会进行匹配并输出”Chocolate”这个单词。</li>
</ul>
<p>Vim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看。</p>
<h2 id="执行普通模式下的命令"><a href="#执行普通模式下的命令" class="headerlink" title="执行普通模式下的命令"></a>执行普通模式下的命令</h2><p>你知道Vim可以在输入模式下执行普通模式的命令吗？</p>
<p>在输入模式下， 如果你按下<code>Ctrl-o</code>，你就会进入到<code>insert-normal</code>（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下<code>Ctrl-o</code>后就会变为<code>-- (insert) --</code>。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：</p>
<p><strong>设置居中以及跳转</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o zz       居中窗口</span><br><span class="line">Ctrl-o H/M/L    跳转到窗口的顶部/中部/底部</span><br><span class="line">Ctrl-o &#x27;a       跳转到标志&#x27;a处</span><br></pre></td></tr></table></figure>

<p><strong>重复文本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o 100ihello    输入 &quot;hello&quot; 100 次</span><br></pre></td></tr></table></figure>

<p><strong>执行终端命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o !! curl https://google.com    运行curl命令</span><br><span class="line">Ctrl-o !! pwd                        运行pwd命令</span><br></pre></td></tr></table></figure>

<p><strong>快速删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o dtz    从当前位置开始删除文本，直到遇到字母&quot;z&quot;</span><br><span class="line">Ctrl-o D      从当前位置开始删除文本，直到行末</span><br></pre></td></tr></table></figure>

<h2 id="聪明地学习输入模式"><a href="#聪明地学习输入模式" class="headerlink" title="聪明地学习输入模式"></a>聪明地学习输入模式</h2><p>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。</p>
<p>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。</p>
<h1 id="第7章-点命令"><a href="#第7章-点命令" class="headerlink" title="第7章 点命令"></a>第7章 点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令。</p>
<p>比如，如果你想将下面文本中的所有”let“替换为”const”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用<code>/let</code>来进行匹配。</li>
<li>接着，使用<code>cwconst&lt;esc&gt;</code>来将”let”替换成”const”。</li>
<li>第三步，使用<code>n</code>来找到下一个匹配的位置。</li>
<li>最后，使用点命令(<code>.</code>)来重复之前的操作。</li>
<li>持续地使用<code>n . n .</code>直到每一个匹配的词都被替换。</li>
</ul>
<p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。</p>
<h2 id="什么才算是修改操作？"><a href="#什么才算是修改操作？" class="headerlink" title="什么才算是修改操作？"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？</p>
<p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作。</p>
<p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作。现在假设你有以下这么一个句子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>

<p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df,</code>来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除。</p>
<p>让我们再来试试另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>

<p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f,</code>来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用<code>.</code>来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？</p>
<p>在Vim里，修改操作是不包括移动（motions）的，因为移动(motions)不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df,</code>进行一下对比的话，你会发现<code>df,</code>中的<code>f,</code>告诉删除操作<code>d</code>哪里需要删除，是整个删除命令<code>df,</code>的一部分。</p>
<p>让我们想想办法完成这个任务。在你运行<code>f,</code>并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; . ; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.</code>。</p>
<p>再来试试下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancake</span><br><span class="line">potatoes</span><br><span class="line">fruit-juice</span><br></pre></td></tr></table></figure>

<p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j . j . </code>来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>。</p>
<p>从你按下输入命令（A）开始到你退出输入模式（<esc>）之间的所有输入都算作是一整个修改操作。</p>
<h2 id="重复多行修改操作"><a href="#重复多行修改操作" class="headerlink" title="重复多行修改操作"></a>重复多行修改操作</h2><p>假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">const foo = &quot;bar&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br><span class="line">let six = &quot;6&quot;;</span><br><span class="line">let seven = &quot;7&quot;;</span><br><span class="line">let eight = &quot;8&quot;;</span><br><span class="line">let nine = &quot;9&quot;;</span><br></pre></td></tr></table></figure>

<p>你的目标是删除除了含有”foo”那一行以外的所有行。首先，使用<code>d2j</code>删除前三行。之后跳过”foo”这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是<code>d2jj..</code>。</p>
<p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动(motion)操作，而是整个删除命令的一部分。</p>
<p>我们再来看看下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zlet zzone = &quot;1&quot;;</span><br><span class="line">zlet zztwo = &quot;2&quot;;</span><br><span class="line">zlet zzthree = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br></pre></td></tr></table></figure>

<p>我们的目标是删除所有的’z’。从第一行第一个字符开始，首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个’z’字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个’z’后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个z字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>。</p>
<p>你删除一列上的三个’z‘的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。</p>
<h2 id="在修改中包含移动操作"><a href="#在修改中包含移动操作" class="headerlink" title="在修改中包含移动操作"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n . n .</code>将下面的文本中的’let’都替换成了’const’。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>

<p>其实还有更快的方法来完成整个操作。当你使用<code>/let</code>搜索后，执行<code>cgnconst&lt;Esc&gt;</code>，然后<code>. . .</code>。</p>
<p><code>gn</code>是一个移动并选择的动作，它向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且 <strong>自动对匹配的文本进行可视化模式下的选取</strong>。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n . n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。</p>
<p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作。</p>
<blockquote>
<p>（译者在这里研究了一会，并做了不少实验，总结规律是：单独的motion(第4章中所说的名词)不算修改操作，而opeartor(动词)+motion(名词)时(请回顾第4章)，motion被视为一个完整的修改操作中的一部分。再看一个例子，看看<code>/</code>命令是如何被包含在一个修改操作中的：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">foo</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">foo</span><br><span class="line">e</span><br><span class="line">f</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设你的光标在第一行的a上，执行命令<code>d/foo&lt;Esc&gt;</code>，Vim会删除a,b。然后<code>.</code>，Vim会删除foo, c, d，再按<code>.</code>，Vim什么也不做，因为后面没有”foo”了。在这个例子中，<code>/foo</code>是一个motion（名词），是Vim语法(动词+名词：operator + motion)的一部分，前面的<code>d</code>则是动词。<code>d/foo&lt;Esc&gt;</code>这条命令的功能是：从当前光标所在位置开始删除，直到遇到”foo”为止。后面的点命令就重复这个功能，第二次按<code>.</code>之所以Vim什么也不做，是因为找不到下一个匹配了，所以这条命令就失效了。</p>
</blockquote>
<h2 id="聪明地学习点命令"><a href="#聪明地学习点命令" class="headerlink" title="聪明地学习点命令"></a>聪明地学习点命令</h2><p>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了。</p>
<p>在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念。</p>
<p>点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。</p>
<h1 id="第8章-寄存器"><a href="#第8章-寄存器" class="headerlink" title="第8章 寄存器"></a>第8章 寄存器</h1><p>学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。</p>
<p>你可能已经在复制或删除文本并用<code>p</code>或<code>P</code>粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？如果正确地使用Vim寄存器，将帮助您从重复的输入中解放出来。</p>
<p>在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。</p>
<h2 id="寄存器的10种类型"><a href="#寄存器的10种类型" class="headerlink" title="寄存器的10种类型"></a>寄存器的10种类型</h2><p>下面是Vim所拥有的10种寄存器类型：</p>
<ol>
<li>匿名寄存器（<code>&quot;&quot;</code>）.</li>
<li>编号寄存器(<code>&quot;0-9</code>).</li>
<li>小删除寄存器 (<code>&quot;-</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>只读寄存器 (<code>&quot;:</code>, <code>&quot;.</code>, and <code>&quot;%</code>).</li>
<li>Buffer交替文件寄存器 (<code>&quot;#</code>).</li>
<li>表达式寄存器 (<code>&quot;=</code>).</li>
<li>选取和拖放寄存器(<code>&quot;*</code> and <code>&quot;+</code>).</li>
<li>黑洞寄存器 (<code>&quot;_</code>).</li>
<li>搜索模式寄存器 (<code>&quot;/</code>).</li>
</ol>
<h2 id="寄存器命令"><a href="#寄存器命令" class="headerlink" title="寄存器命令"></a>寄存器命令</h2><p>要使用寄存器，您必须先使用命令将内容存储到寄存器，以下是一些存值到寄存器中的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y    复制</span><br><span class="line">c    删除文本并进入输入模式</span><br><span class="line">d    删除文本</span><br></pre></td></tr></table></figure>

<p>其实还有更多的寄存器写入操作（比如<code>s</code>或<code>x</code>），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。</p>
<p>想要从寄存器中取出（粘贴）文本，你可以用以下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p    在光标位置之后粘贴文本</span><br><span class="line">P    在光标位置之前粘贴文本</span><br></pre></td></tr></table></figure>

<p><code>p</code>和<code>P</code>都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用<code>10p</code>。想粘贴寄存器”a”中的文本，可以用<code>&quot;ap</code>。想将寄存器“a”中的文本粘贴10次的话，可以使用<code>10&quot;ap</code>。注意，从技术层面讲，命令<code>p</code>实际上表示的是”put”(放置)，而不是”paste”(粘贴)，使用粘贴只是因为它更符合传统习惯。</p>
<p>从某个特定寄存器中读取文本的通用语法是<code>&quot;x</code>，其中<code>x</code>是这个寄存器的标志。</p>
<h2 id="在输入模式中使用寄存器"><a href="#在输入模式中使用寄存器" class="headerlink" title="在输入模式中使用寄存器"></a>在输入模式中使用寄存器</h2><p>在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器”a”中的文本，通常可以使用<code>&quot;ap</code>来进行。不过当你在输入模式下时，你需要运行<code>Ctrl-r a</code>。在输入模式下使用寄存器的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r x</span><br></pre></td></tr></table></figure>

<p>其中<code>x</code>是寄存器标志。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。</p>
<h2 id="匿名寄存器"><a href="#匿名寄存器" class="headerlink" title="匿名寄存器(&quot;&quot;)"></a>匿名寄存器(<code>&quot;&quot;</code>)</h2><p>想从匿名寄存器中获取文本，可以使用<code>&quot;&quot;p</code>。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。</p>
<p>默认情况下，<code>p</code>(或者<code>P</code>)是和匿名寄存器相关联的（从现在起我将使用<code>p</code>而不是<code>&quot;&quot;p</code>来指代匿名寄存器）。</p>
<h2 id="编号寄存器-0-9"><a href="#编号寄存器-0-9" class="headerlink" title="编号寄存器(&quot;0-9)"></a>编号寄存器(<code>&quot;0-9</code>)</h2><p>编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(<code>0</code>)和其他编号寄存器(<code>1-9</code>)。让我们先来讨论复制寄存器。</p>
<h3 id="复制寄存器-0"><a href="#复制寄存器-0" class="headerlink" title="复制寄存器 (&quot;0)"></a>复制寄存器 (<code>&quot;0</code>)</h3><p>如果你使用<code>yy</code>来复制一整行文本，事实上Vim会将文本存放两个寄存器中：</p>
<ol>
<li>匿名寄存器 (<code>p</code>).</li>
<li>复制寄存器 (<code>&quot;0p</code>).</li>
</ol>
<p>在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器(<code>0</code>)中的内容。其他的任何操作都不会被存放在<code>0</code>号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。</p>
<p>比如，如果你：</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行(<code>dd</code>)</li>
<li>再删除另一行 (<code>dd</code>)</li>
</ol>
<p>复制寄存器中的文本仍然是第一步中复制的文本。</p>
<p>如果你:</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行 (<code>dd</code>)</li>
<li>复制另一行 (<code>yy</code>)</li>
</ol>
<p>复制寄存器中的内容则是第三步中复制的内容。</p>
<p>还有一个小技巧，在输入模式下，你可以使用<code>Ctrl-r 0</code>快速地粘贴你刚才复制的内容。</p>
<h3 id="编号寄存器-1-9"><a href="#编号寄存器-1-9" class="headerlink" title="编号寄存器 (&quot;1-9)"></a>编号寄存器 (<code>&quot;1-9</code>)</h3><p>当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（&#x3D;&#x3D;编号越小时间距离越近&#x3D;&#x3D;）</p>
<p>比如，你有以下这些文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line three</span><br><span class="line">line two</span><br><span class="line">line one</span><br></pre></td></tr></table></figure>

<p>当你的光标在文本“line three”上时,使用<code>dd</code>来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是”line one”（时间上最近的文本）， 2号寄存器则包含”line two”(时间上第二近的文本)，3号寄存器中则包含”line three”（最早删除的文本）。普通模式下可以使用<code>&quot;1p</code>来获取1号寄存器中的内容。</p>
<p>&#x3D;&#x3D;编号寄存器的编号在使用点命令时会自动增加&#x3D;&#x3D;。比如，如果你的1号编号寄存器（<code>&quot;1</code>）中的内容为”line one”， 2号寄存器（<code>&quot;2</code>）为”line two”, 三号寄存器（<code>&quot;3</code>）”line three”,你可以使用以下的技巧来连续地粘贴他们：</p>
<ul>
<li>使用<code>&quot;1p</code>来粘贴1号寄存器中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴2号寄存器（<code>&quot;2</code>）中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴3号寄存器（<code>&quot;3</code>）中的内容。</li>
</ul>
<p>在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(<code>&quot;5P</code>), 点命令<code>.</code>会执行<code>&quot;6P</code>,再次使用<code>.</code>则会执行<code>&quot;7P</code>,等等。</p>
<p>小型的删除比如单词删除（<code>dw</code>)或者单词修改(<code>cw</code>)不会被存储在编号寄存器中，它们被存储在小删除寄存器(<code>&quot;-</code>)中，我将在接下来的一小节讨论小删除寄存器。</p>
<h2 id="小删除寄存器"><a href="#小删除寄存器" class="headerlink" title="小删除寄存器(&quot;-)"></a>小删除寄存器(<code>&quot;-</code>)</h2><p>&#x3D;&#x3D;不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (<code>&quot;-</code>)中。&#x3D;&#x3D;</p>
<p>比如:</p>
<ol>
<li>删除一个单词 (<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给你第一步中删除的单词。</p>
<p>另一个例子:</p>
<ol>
<li>删除一个单词(<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一个单词 (<code>diw</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给出第三步中删除的单词。类似地, <code>&quot;1p</code> 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。</p>
<h2 id="命名寄存器-a-z"><a href="#命名寄存器-a-z" class="headerlink" title="命名寄存器 (&quot;a-z)"></a>命名寄存器 (<code>&quot;a-z</code>)</h2><p>命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。</p>
<p>为了复制一个单词到寄存器”a”中，你可以使用命令<code>&quot;ayiw</code>。</p>
<ul>
<li><code>&quot;a</code>告诉Vim下一个动作（删除&#x2F;修改&#x2F;复制）会被存储在寄存器”a”中</li>
<li><code>yiw</code>复制这个单词</li>
</ul>
<p>为了从寄存器”a”中获取文本，可以使用命令<code>&quot;ap</code>。你可以使用以26个字母命名的寄存器来存储26个不同的文本。</p>
<p>有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的”a”寄存器中已经存有文本”Hello”，如果你想继续添加”world”到寄存器”a”中，你可以先找到文本”world”然后使用<code>&quot;Aiw</code>来进行复制,即可完成追加。</p>
<h2 id="只读寄存器"><a href="#只读寄存器" class="headerlink" title="只读寄存器(&quot;:, &quot;., &quot;%)"></a>只读寄存器(<code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code>)</h2><p>Vim有三个只读寄存器：<code>.</code>,<code>:</code>和<code>%</code>，它们的用法非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.    存储上一个输入的文本</span><br><span class="line">:    存储上一次执行的命令</span><br><span class="line">%    存储当前文件的文件名</span><br></pre></td></tr></table></figure>

<p>如果你写入”Hello Vim”,之后再运行<code>&quot;.p</code>就会打印出文本”Hello Vim”。如果你想要获得当前文件的文件名，可以运行命令<code>&quot;%p</code>。如果你运行命令<code>:s/foo/bar/g</code>，再运行<code>&quot;:p</code>的话则会打印出文本”s&#x2F;foo&#x2F;bar&#x2F;g”。</p>
<h2 id="Buffer交替文件寄存器"><a href="#Buffer交替文件寄存器" class="headerlink" title="Buffer交替文件寄存器 (&quot;#)"></a>Buffer交替文件寄存器 (<code>&quot;#</code>)</h2><p>在Vim中，<code>#</code>通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令<code>&quot;#p</code>。</p>
<h2 id="表达式寄存器"><a href="#表达式寄存器" class="headerlink" title="表达式寄存器 (&quot;=)"></a>表达式寄存器 (<code>&quot;=</code>)</h2><p>Vim有一个表达式寄存器，<code>&quot;=</code>,用于计算表达式的结果。</p>
<p>你可以使用以下命令计算数学表达式<code>1+1</code>的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=1+1&lt;Enter&gt;p</span><br></pre></td></tr></table></figure>

<p>在这里，你在告诉Vim你正在使用表达式寄存器<code>&quot;=</code>，你的表达式是（<code>1+1</code>），你还需要输入<code>p</code>来得到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =1+1</span><br></pre></td></tr></table></figure>

<p>你可以使用<code>@</code>来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器”a”中获取文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=@a</span><br></pre></td></tr></table></figure>

<p>之后输入<code>&lt;enter&gt;</code>，再输入<code>p</code>。类似地，想在输入模式中得到寄存器”a”中的值可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =@a</span><br></pre></td></tr></table></figure>

<p>表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的VimScript章节中进一步讲解更多关于表达式的细节。</p>
<h2 id="选取和拖放寄存器"><a href="#选取和拖放寄存器" class="headerlink" title="选取和拖放寄存器 (&quot;*, &quot;+)"></a>选取和拖放寄存器 (<code>&quot;*</code>, <code>&quot;+</code>)</h2><p>你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：<code>quotestar</code> (<code>&quot;*</code>) 和 <code>quoteplus</code> (<code>&quot;+</code>)。你可以用它们来访问从外部程序中复制的文本。</p>
<p>如果你在运行一个外部程序（比如Chrome浏览器），然后你使用<code>Ctrl-c</code>(或者<code>Cmd-c</code>,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用<code>p</code>来粘贴这部分文本的。但是，Vim的两个寄存器<code>&quot;+</code>和<code>&quot;*</code>都是和你系统的粘贴板相连接的，所以你可以使用<code>&quot;+p</code>和<code>&quot;*p</code>来粘贴这些文本。反过来，如果你使用<code>&quot;+yiw</code>或者<code>&quot;*yiw</code>在Vim中复制了一些文本，你可以使用<code>Ctrl-v</code>（或者<code>Cmd-v</code>）。值得注意的是这个方法只在你的Vim开启了<code>+clipboard</code>选项时才有用，可以在命令行中运行<code>vim --version</code>查看这一选项。如果你看见<code>-clipboard</code>的话，则需要安装一下支持Vim粘贴板的配置。</p>
<p>你也许会想如果<code>&quot;*</code>和<code>&quot;+</code>能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是<code>quotestar</code> (<code>&quot;*</code>)寄存器作为X11的首选选项，并使用 <code>quoteplus</code> (<code>&quot;+</code>)作为粘贴板选项。这只在你的Vim配置里开启了<code>xterm_clipboard</code> 选项时才有效（<code>vim --version</code>中的<code>+xterm_clipboard</code>）。如果你的的Vim配置中没有 <code>xterm_clipboard</code>也不是什么大问题。这只是意味着<code>quotestar</code> 和<code>quoteplus</code>两个寄存器是可以互相替代的。</p>
<p>我发觉使用<code>=*p</code>或者<code>=+p</code>的话比较麻烦，为了使Vim仅使用<code>p</code>就能粘贴从外部程序复制的文本，你可以在你的<code>vimrc</code>配置文件中加入下面一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set clipboard=unnamed</span><br></pre></td></tr></table></figure>

<p>现在当我从外部程序中复制文本时，我可以使用匿名寄存器<code>p</code>来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用<code>Ctrl-v</code>来粘贴。如果你的Vim开启了 <code>+xterm_clipboard</code>设置，你或许会想同时也使用<code>unnamed</code>和<code>unnamedplus</code>的粘贴板选项。</p>
<h2 id="黑洞寄存器"><a href="#黑洞寄存器" class="headerlink" title="黑洞寄存器 (&quot;_)"></a>黑洞寄存器 (<code>&quot;_</code>)</h2><p>你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？</p>
<p>你可以使用黑洞寄存器（<code>&quot;_</code>）。想要删除一行并且不将其存储在任何寄存器中时，可以使用<code>&quot;_dd</code>命令.</p>
<p>它是和 <code>/dev/null</code> 类似的寄存器。</p>
<h2 id="搜索模式寄存器"><a href="#搜索模式寄存器" class="headerlink" title="搜索模式寄存器 (&quot;/)"></a>搜索模式寄存器 (<code>&quot;/</code>)</h2><p>为了粘贴你的上一个搜索询问（<code>/</code> 或 <code>?</code>），你可以使用搜索模式寄存器(<code>&quot;/</code>)。使用命令 <code>&quot;/p</code>就能粘贴上一个搜索的条目。</p>
<h2 id="查看所有的寄存器"><a href="#查看所有的寄存器" class="headerlink" title="查看所有的寄存器"></a>查看所有的寄存器</h2><p>你可以使用<code>:register</code>命令来查看你的所有寄存器。如果你只想查看”a”,”1”和”-“寄存器的内容的话则可以使用命令<code>:register a 1 -</code>。</p>
<p>有一个Vim的插件叫做 <a target="_blank" rel="noopener" href="https://github.com/junegunn/vim-peekaboo">vim-peekaboo</a> ,可以让你查看到寄存器的内容，在普通模式下输入<code>&quot;</code>或<code>@</code> 即可，或者在输入模式中输入<code>Ctrl-r</code>。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！</p>
<h2 id="执行寄存器"><a href="#执行寄存器" class="headerlink" title="执行寄存器"></a>执行寄存器</h2><p>命名寄存器不只可以用来存放文本，你还可以借助<code>@</code>来执行宏命令。我会在下一章节中介绍宏命令。</p>
<p>注意，因为宏命令时存储在Vim寄存器中的，使用宏时可能会覆盖存储的内容。如果你将文本”Hello Vim”存放在寄存器”a”中，并且之后你在同一个寄存器里记录了一个宏命令 (<code>qa&#123;macro-commands&#125;q</code>),那么这个宏命令将会覆盖之前存储的文本”Hello Vim”（你可以使用<code>@a</code>来执行寄存器中存储的宏命令）。</p>
<h2 id="清除寄存器"><a href="#清除寄存器" class="headerlink" title="清除寄存器"></a>清除寄存器</h2><p>从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行<code>qaq</code>，Vim就会在寄存器”a”中记录一个空的宏命令。</p>
<p>还有一种方法就是运行命令<code>:call setreg(&#39;a&#39;,&#39;hello register a&#39;)</code>,其中’a’代表的就是寄存器”a”。而”hello register a”就是你想存储的内容。</p>
<p>还有一种清除寄存器的方法就是使用表达式<code>:let @a = &#39;&#39;</code>来将寄存器”a 的值设为空的字符串。</p>
<h2 id="获取寄存器中的内容"><a href="#获取寄存器中的内容" class="headerlink" title="获取寄存器中的内容"></a>获取寄存器中的内容</h2><p>你可以使用<code>:put</code>命令来粘贴任何寄存器的内容。比如，如果你运行命令<code>:put a</code>,Vim就会打印出寄存器”a”的内容，这和<code>&quot;ap</code>非常像，唯一的区别在于在普通模式下命令<code>p</code>在当前光标位置之后打印寄存器的内容，而<code>:put</code>新起一行来打印寄存器的内容。</p>
<p>因为<code>:put</code>是一个命令行命令，您可以传一个地址给它。<code>:10put a</code>将会在当前光标下数10行，然后插入新行，内容为寄存器a中的内容。</p>
<p>一个很酷的技巧是将黑洞寄存器(<code>&quot;_</code>)传给<code>:put</code>命令。因为黑洞寄存器不保存任何值，<code>:put _</code>命令将插入一个新的空白行。您可将这个与全局命令联合起来，插入多个空行。比如，要在所有以文本”end”结尾的行下插入空行，使用<code>:g/end/put _</code>。在后面您将了解关于全局命令的知识。</p>
<h2 id="聪明地学习寄存器"><a href="#聪明地学习寄存器" class="headerlink" title="聪明地学习寄存器"></a>聪明地学习寄存器</h2><p>恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。</p>
<p>我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：</p>
<ol>
<li>匿名寄存器(<code>&quot;&quot;</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>编号寄存器 (<code>&quot;0-9</code>).</li>
</ol>
<p>既然匿名寄存器是默认和<code>p</code>或<code>P</code>，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。</p>
<p>普通人的短期记忆都是有极限的，大概每次只能记住5-7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器”a”开始用，之后用寄存器”b”,以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。</p>
<p>Vim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。</p>
<h1 id="第9章-宏命令"><a href="#第9章-宏命令" class="headerlink" title="第9章 宏命令"></a>第9章 宏命令</h1><p>在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。</p>
<p>在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。</p>
<h2 id="基本宏命令"><a href="#基本宏命令" class="headerlink" title="基本宏命令"></a>基本宏命令</h2><p>宏命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qa                     开始记录动作到寄存器 a</span><br><span class="line">q (while recording)    停止记录</span><br></pre></td></tr></table></figure>

<p>你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@a    Execute macro from register a</span><br><span class="line">@@    Execute the last executed macros</span><br></pre></td></tr></table></figure>

<p>假设你有如下的文本，你打算将每一行中的所有字母都变为大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">vim</span><br><span class="line">macros</span><br><span class="line">are</span><br><span class="line">awesome</span><br></pre></td></tr></table></figure>

<p>将你的光标移动到 “hello” 栏的行首，并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0gU$jq</span><br></pre></td></tr></table></figure>

<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>gU$</code> 将从光标到行尾的字母变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>调用 <code>@a</code> 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 <code>3@a</code> 去执行 <code>a</code> 命令3次。你也可以执行 <code>3@@</code> 去执行上一次执行过的宏命令3次。</p>
<h2 id="安全保护"><a href="#安全保护" class="headerlink" title="安全保护"></a>安全保护</h2><p>在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>

<p>你想将每一行的第一个词变为大写，你可以使用如下的宏命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0W~jq</span><br></pre></td></tr></table></figure>

<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 将光标选中的单词变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>我喜欢对宏命令进行超过所需次数的调用，所以我通常使用 <code>99@a</code> 命令去执行该宏命令99次。使用该命令，Vim并不会真正执行这个宏99次，当 Vim 到达最后一行执行<code>j</code>时，它会发现无法再向下了，然后会抛出一个错误，并终止宏命令的执行。</p>
<p>实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。</p>
<h2 id="命令行执行宏"><a href="#命令行执行宏" class="headerlink" title="命令行执行宏"></a>命令行执行宏</h2><p>在正常模式执行 <code>@a</code> 并不是宏命令调用的唯一方式。你也可以在命令行执行 <code>：normal @a</code> 。<code>：normal</code> 会将任何用户添加的参数作为命令去执行。例如添加 <code>@a</code>，和在 normal mode 执行 <code>@a</code> 的效果是一样的。</p>
<p><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。</p>
<h2 id="在多个文件中执行宏命令"><a href="#在多个文件中执行宏命令" class="headerlink" title="在多个文件中执行宏命令"></a>在多个文件中执行宏命令</h2><p>假如你有多个 <code>.txt</code> 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。假设，您的寄存器a中存储的内容是<code>0W~j</code>(就是前面例子中用到的宏命令),那么，您该如何快速完成这个操作呢？</p>
<p>第一个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## savory.txt</span><br><span class="line">a. cheddar jalapeno donut</span><br><span class="line">b. mac n cheese donut</span><br><span class="line">c. fried dumpling</span><br></pre></td></tr></table></figure>

<p>第二个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## sweet.txt</span><br><span class="line">a. chocolate donut</span><br><span class="line">b. chocolate pancake</span><br><span class="line">c. powdered sugar donut</span><br></pre></td></tr></table></figure>

<p>第三个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## plain.txt</span><br><span class="line">a. wheat bread</span><br><span class="line">b. plain donut</span><br></pre></td></tr></table></figure>

<p>你可以这么做:</p>
<ul>
<li><code>:args *.txt</code> 查找当前目录下的所有 <code>.txt</code> 文件。</li>
<li><code>:argdo g/donut/normal @a</code> 在 <code>:args</code> 中包含的每一个文件里执行一个全局命令 <code>g/donut/normal @a</code>。</li>
<li><code>:argdo update</code> 在 <code>:args</code> 中包含的每一个文件里执行 <code>update</code> 命令,保存修改后的内容。</li>
</ul>
<p>也许你对全局命令 <code>:g/donut/normal @a</code> 不是很了解，该命令会执行 <code>/donut/</code>搜索命令，然后在所有匹配的行中执行<code>normal @a</code> 命令。我会在后面的章节中介绍全局命令。</p>
<h2 id="递归执行宏命令"><a href="#递归执行宏命令" class="headerlink" title="递归执行宏命令"></a>递归执行宏命令</h2><p>你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏寄存器来实现。假如你有如下文本，你希望改变第一个单词的大小写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>

<p>如下命令会递归地执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qaqqa0W~j@aq</span><br></pre></td></tr></table></figure>

<p>上面命令的分解如下：</p>
<ul>
<li><code>qaq</code> 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。</li>
<li><code>qa</code> 开始录入宏命令到寄存器 “a”。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 改变光标选中的单词的大小写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>@a</code> 执行宏命令 “a”。当你记录该宏命令时，<code>@a</code> 应该是空白的，因为你刚刚调用了 <code>qaq</code>。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>现在，让我们调用 <code>@a</code> 来查看 Vim 如何递归的调用该宏命令。</p>
<p>宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 <code>j</code> 命令时，发现已经没有下一行了，就会停止执行。</p>
<h2 id="增添一个已知宏"><a href="#增添一个已知宏" class="headerlink" title="增添一个已知宏"></a>增添一个已知宏</h2><p>如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来想该寄存器中添加内容。同样的，为了在寄存器”a”中添加更多的操作，你也可以使用大写字母”A”。</p>
<p>假设寄存器a中已经存储了这个宏命令:<code>qa0W~q</code>(该宏命令将某行的第二个词组的头一个字母执行改变大小写操作)，假设你想在这个基础上添加一些操作命令序列，使得每一行末尾添加一个句点，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qAA.&lt;esc&gt;q</span><br></pre></td></tr></table></figure>

<p>分解如下:</p>
<ul>
<li><code>qA</code> 开始在寄存器 “A” 中记录宏命令。</li>
<li><code>A.&lt;esc&gt;</code> 在行的末尾加上一个句点(这里的<code>A</code>是进入插入模式，不要和宏A搞混淆)，然后退出插入模式。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，当你执行<code>@a</code>时，它不仅将第二个词组的首字母转变大小写，同时还在行尾添加一个句点。</p>
<h2 id="修改一个已知宏"><a href="#修改一个已知宏" class="headerlink" title="修改一个已知宏"></a>修改一个已知宏</h2><p>如果想在一个宏的中间添加新的操作该怎么办呢？</p>
<p>假设您在寄存器a中已经存有一个宏命令<code>0W~A.&lt;Esc&gt;</code>，即改变首字母大小写，并在行尾添加句号。如果您想在改变首字母大小写和行尾添加句号之间，在单词”dount”前面加入”deep fried”。（因为唯一比甜甜圈好的东西就是炸甜甜圈）。</p>
<p>我会重新使用上一节使用过的文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>

<p>首先，让我们通过 <code>:put a</code> 调用一个已经录制好的宏命令（假设你上一节中保存在寄存器a中的宏命令还在）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~A.^[</span><br></pre></td></tr></table></figure>

<p><code>^[</code> 是什么意思呢？不记得了吗，你之前执行过 <code>0W~A.&lt;esc&gt;</code>。 <code>^[</code> 是 Vim 的 <strong>内部指令</strong>，表示 <code>&lt;esc&gt;</code>。通过这些指定的特殊键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 <code>&lt;esc&gt;</code>，<code>&lt;backspace&gt;</code>，<code>&lt;enter&gt;</code>。还有一些其他的键值组合，但这不是本章的内容。</p>
<p>回到宏命令，在改变大小写之后的键后面（<code>~</code>），让我们添加（<code>$</code>）来移动光标到行末，回退一个单词（<code>b</code>），进入插入模式（<code>i</code>），输入”deep fried “ （别忽略”fried “后面的这个空格），之后退出插入模式（<code>&lt;esc&gt;</code>）。</p>
<p>完整的命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried &lt;esc&gt;A.^[</span><br></pre></td></tr></table></figure>

<p>这里有一个问题，Vim 不能理解 <code>&lt;esc&gt;</code>。您不能依葫芦画瓢输入”<Esc>“，所以你需要将<code>&lt;Esc&gt;</code>写成内部代码的形式。在插入模式，在按下<code>&lt;esc&gt;</code>后按下 <code>Ctrl-v</code>，Vim 会打印 <code>^[</code>。 &#x3D;&#x3D;<code>Ctrl-v</code> 是一个插入模式的操作符，可以逐字地插入一个非数字字符&#x3D;&#x3D;。你的宏命令应该如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried ^[A.^[</span><br></pre></td></tr></table></figure>

<p>为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知命名寄存器中添加一个新条目的方式来实现。在一行的行首，执行 <code>&quot;ay$</code>，使用寄存器 “a”来存储复制的文本。</p>
<p>现在，但你执行 <code>@a</code> 时，你的宏命令会自动改变第一个单词的大小写，在”donut”前面添加”deep fried “，之后在行末添加“.”。</p>
<p>另一个修改宏命令的方式是通过命令行表达式。执行 <code>:let @a=&quot;</code>，之后执行 <code>Ctrl-r Ctrl-r a</code>，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（<code>&quot;</code>）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 <code>Ctrl-v</code>。</p>
<h2 id="拷贝宏"><a href="#拷贝宏" class="headerlink" title="拷贝宏"></a>拷贝宏</h2><p>你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 <code>:let @z = @a</code> 将寄存器”a” 中的命令拷贝到寄存器”z”。 <code>@a</code> 表示寄存器“a”中存储的内容，你现在执行 <code>@z</code>，将会执行和 <code>@a</code> 一样的指令。</p>
<p>我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。</p>
<h2 id="串行宏和并行宏"><a href="#串行宏和并行宏" class="headerlink" title="串行宏和并行宏"></a>串行宏和并行宏</h2><p>Vim 可以连续和同时运行宏命令，假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>

<p>假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0f&#123;gui&#123;jq</span><br></pre></td></tr></table></figure>

<p>分解如下：</p>
<ul>
<li><code>qa</code> 开始记录宏命令到 “a” 寄存器。</li>
<li><code>0</code>移动到第一行。</li>
<li><code>f&#123;</code> 查找第一个 “{” 字符。</li>
<li><code>gui&#123;</code> 把括号内的文本（<code>i&#123;</code>）变为小写（<code>gu</code>）。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，执行 <code>99@a</code> 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import foo from &quot;bar&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>

<p>执行 <code>99@a</code>，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时<code>f&#123;</code>命令会遇到错误而停止，当宏串行执行时就会发生这样的情况。当然，你仍然可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？</p>
<p>你可以并行地执行宏命令。</p>
<p>如本章前面所说，可以使用 <code>:normal</code> 去执行宏命令，（例如： <code>:3,5 normal @a</code> 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 <code>:1,$ normal @a</code>，会在所有除了包含有 “foo” 的行执行，而且它不会出错。</p>
<p>尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（<code>1,$</code>）每一行执行 <code>@a</code> 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。</p>
<h2 id="聪明地学习宏命令"><a href="#聪明地学习宏命令" class="headerlink" title="聪明地学习宏命令"></a>聪明地学习宏命令</h2><p>你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。</p>
<p>刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。</p>
<p>使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它(<code>qf</code>)。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的(<code>qn</code>)。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令默认寄存器，因为执行 <code>qq</code> 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 <code>qa</code> 到 <code>qb</code> 再到 <code>qc</code>。</p>
<p>去寻找最适合你的方法吧。</p>
<h1 id="第10章-撤销"><a href="#第10章-撤销" class="headerlink" title="第10章 撤销"></a>第10章 撤销</h1><p>所有人都会犯各种各样的输入错误。因此对于任何一个现代的软件来说，撤销都是一个很基本的功能。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持存取不同的文本形态，让你能控制你输入的所有文本。在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。 </p>
<h2 id="撤销-undo-，重做和行撤销-UNDO"><a href="#撤销-undo-，重做和行撤销-UNDO" class="headerlink" title="撤销(undo)，重做和行撤销(UNDO)"></a>撤销(undo)，重做和行撤销(UNDO)</h2><p>对于一个基本的 undo 操作，你可以执行 <code>u</code> 或者 <code>:undo</code>。</p>
<p>假设你有如下文本(注意”one”下面有一个空行)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后添加另一个文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>如果你执行 <code>u</code>，Vim 会删除 “two”。</p>
<p>Vim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。</p>
<p>要取消上一次的撤销，可以执行 <code>Ctrl-r</code> 或者 <code>:redo</code>。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 <code>Ctrl-r</code> 来恢复被删除掉的文本。</p>
<p>Vim 也有另一个命令 <code>U</code> 可以实现 行撤销 (UNDO) 的功能，执行这个命令会撤销所有最新的修改。</p>
<p>那么，<code>U</code> 和 <code>u</code> 的区别是什么呢？首先，<code>U</code> 会删除 <em>最近修改的行中所有的</em> 的修改，而 <code>u</code> 一次仅删除一次修改。 其次，执行<code>u</code> 不会被算作一次修改操作，而执行 <code>U</code> 则会被算作一次修改。</p>
<p>让我们会的之前的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>修改第二行的内容为 “three” (<code>ciwthree&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>再次修改第二行的例子为 “four” (<code>ciwfour&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>

<p>此时，如果你按下 <code>u</code>，你会看到 “three”。如果你再次按下 <code>u</code>，你会看到 “two”。然而，在第二行仍为 “four” 的时候，如果你按下 <code>U</code>，你会看到 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行 <code>U</code> 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 <code>U</code> 后 再次执行 <code>U</code> 会撤销 自己。假如你连续执行 <code>U</code>，那么你将看到第二行的文本不停地出现和消失。</p>
<p>就我个人而言，我几乎不会使用 <code>U</code>，因为很难记住文本最初的样子。（我几乎不使用它）</p>
<p>Vim 可以通过变量 <code>undolevels</code> 来选择最多可执行 undo 的次数。你可以通过 <code>:echo &amp;undolevels</code> 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 <code>:set undolevels=1000</code>。不用担心，你可以设置它为任何一个你想设置的值。</p>
<h2 id="断点插入操作"><a href="#断点插入操作" class="headerlink" title="断点插入操作"></a>断点插入操作</h2><p>在上文中我提到，<code>u</code> 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。</p>
<p>如果你执行 <code>ione two three&lt;esc&gt;</code> 之后，按下 <code>u</code>，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 <code>u</code>，你会丢失上一次输入的所有内容。 因此，假设你按下 <code>u</code> 只删除你上一次输入的一部分文本岂不是会更好。</p>
<p>幸运的是，你可以拆分它。当你在插入模式时，按下 <code>Ctrl-G u</code> 会生成一个断点。例如，如果你执行 <code>ione &lt;Ctrl-G u&gt;two &lt;Ctrl-G u&gt;three&lt;esc&gt;</code>，之后你按下<code>u</code>，你仅会失去文本 “three”，再次执行 <code>u</code>，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。&#x3D;&#x3D;在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。&#x3D;&#x3D;</p>
<p>在插入模式中，执行删除操作时插入断点也非常有用。例如通过 <code>Ctrl-W</code> 删除光标前的单词时，以及 <code>Ctrl-U</code>删除光标前的所有文本时。一个朋友建议我使用如下的映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap &lt;c-u&gt; &lt;c-g&gt;u&lt;c-u&gt;</span><br><span class="line">inoremap &lt;c-w&gt; &lt;c-g&gt;u&lt;c-w&gt;</span><br></pre></td></tr></table></figure>

<p>通过上述命令，你可以很轻松地恢复被删除的文本。</p>
<h2 id="撤销树"><a href="#撤销树" class="headerlink" title="撤销树"></a>撤销树</h2><p>Vim 将每一次修改存储在一个撤销树中。你打开一个空白文件，然后添加一段新文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再插入一段新文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>undo一次:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入一段不同的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>再次 undo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次插入另一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>现在如果你执行 undo,您将丢失刚刚添加的文本 “four” :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你再次执行 undo 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 <code>g+</code>，你会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次执行 <code>g+</code> ，你将会看到一位老朋友:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>让我们继续执行 <code>g+</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>再一次执行 <code>g+</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>

<p>在 Vim 中，你每一次执行 <code>u</code> 去做一次修改时，Vim都会通过创建一个”撤销分支”来保存之前的文本内容。在本例中，你输入”two”后, 执行 <code>u</code>，然后输入”three”，你就创建了一个叶子分支,保存了含有”two”的文本状态。此时，撤销树已经包含了至少两个叶子节点，主节点包含文本”three”（最新），而另一undo分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了”four”，那么此时会生成三个节点，一个主节点包含文本”four”, 以及另外两个节点分别存储了”three”和”two”。</p>
<p>为了在几个不同的节点状态间进行切换，你可以执行 <code>g+</code> 去获取一个较新的状态，以及执行 <code>g-</code> 去获取一个教旧的状态。 <code>u</code>， <code>Ctrl-R</code>， <code>g+</code>， 和 <code>g-</code> 之间的区别是，<code>u</code> and <code>Ctrl-R</code> 只可以在 <em>main</em> 节点之间进行切换，而<code>g+</code> 和 <code>g-</code> 可以在 <em>所有</em> 节点之间进行切换。</p>
<p>Undo 树并不可以很轻松地可视化。我发现一个插件 <a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。 </p>
<h2 id="保存撤销记录"><a href="#保存撤销记录" class="headerlink" title="保存撤销记录"></a>保存撤销记录</h2><p>当你通过 Vim 打开一个文件，并且立即按下 <code>u</code>，Vim 很可能会显示 “<em>Already at oldest change</em>” 的警告。 </p>
<p>要想从最近的一次编辑工作中（在vim关闭文件再打开，算做一次新的编辑工作），在撤销历史中回滚，可以通过 <code>:wundo</code>命令使Vim 保存一份你的 undo 历史记录。</p>
<p>创建一个文件 <code>mynumbers.txt</code>. 输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>

<p>插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>插入新的一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>现在，创建你的撤销记录文件。 语法为 <code>:wundo myundofile</code>。 如果你需要覆盖一个已存在的文件，在 <code>wundo</code> 之后添加 <code>!</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wundo! mynumbers.undo</span><br></pre></td></tr></table></figure>

<p>退出 Vim。</p>
<p>此时，在目录下，应该有<code>mynumbers.txt</code> 和 <code>mynumbers.undo</code> 两个文件。再次打开 <code>mynumbers.txt</code> 文件并且按下 <code>u</code>，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 <code>:rundo</code> 来加载 undo 历史。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rundo mynumbers.undo</span><br></pre></td></tr></table></figure>

<p>此时，如果你按下 <code>u</code>，Vim 会删除 “three”。再次按下 <code>u</code>可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。</p>
<p>如果你想要自动加载 undo 历史文件，你可以通过在你的 <code>.vimrc</code> 文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set undodir=~/.vim/undo_dir</span><br><span class="line">set undofile</span><br></pre></td></tr></table></figure>

<p>我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 <code>~/.vim</code> 目录下。 <code>undo_dir</code> 是随意的。 <code>set undofile</code> 告诉 Vim 打开 <code>undofile</code> 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用<code>undo_dir</code>目录前，请确保你已经创建了它）。</p>
<h2 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h2><p>是谁说时间旅行不存在。 Vim 可以通过 <code>:earlier</code> 命令将文本恢复为之前的状态。</p>
<p>假如有如下文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后你输入了另一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>

<p>如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>:undolist</code> 去查看之前所做的修改。 <code>:earlier</code> 可以加上分钟 (<code>m</code>), 小时 (<code>h</code>), and 天 (<code>d</code>) 作为参数。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s    恢复到10秒前的状态</span><br><span class="line">:earlier 10m    恢复到10分钟前的状态</span><br><span class="line">:earlier 10h    恢复到10小时前的状态</span><br><span class="line">:earlier 10d    恢复到10天前的状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，它同样接受一个<code>计数</code>作为参数，告诉vim恢复到老状态的次数。比如，如果运行<code>:earlier 2</code>,Vim将恢复到2次修改前的状态。功能类似于执行<code>g-</code>两次。同样，你可以运行<code>:earlier 10f</code>命令告诉vim恢复到10次保存前的状态。</p>
<p>这些参数同样作用于<code>:earlier</code>命令的对应版本:<code>:later</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:later 10s    恢复到10秒后的状态</span><br><span class="line">:later 10m    恢复到10分钟后的状</span><br><span class="line">:later 10h    恢复到10小时后的状</span><br><span class="line">:later 10d    恢复到10天后的状态</span><br><span class="line">:later 10     恢复到新状态10次</span><br><span class="line">:later 10f    恢复到10次保存后的状态</span><br></pre></td></tr></table></figure>

<h2 id="聪明地学习撤销操作"><a href="#聪明地学习撤销操作" class="headerlink" title="聪明地学习撤销操作"></a>聪明地学习撤销操作</h2><p><code>u</code> 和 <code>Ctrl-R</code> 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用<code>:earlier</code> 和 <code>:later</code>，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 <a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。</p>
<p>在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。</p>
<h1 id="第11章-可视模式"><a href="#第11章-可视模式" class="headerlink" title="第11章 可视模式"></a>第11章 可视模式</h1><p>高亮显示文本块并对其进行更改，是很多文本编辑器中的常见功能。 Vim也可以使用可视模式实现这一功能。在本章中，您将学习如何使用可视模式来有效地处理文本块。</p>
<h2 id="三种可视模式"><a href="#三种可视模式" class="headerlink" title="三种可视模式"></a>三种可视模式</h2><p>Vim有三种可视模式，分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v         逐字符可视模式</span><br><span class="line">V         逐行可视模式</span><br><span class="line">Ctrl-v    逐块可视模式</span><br></pre></td></tr></table></figure>

<p>如果您有下列文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>逐字符可视模式用于选择单个字符。在第一行的第一个字符上按<code>v</code>。然后使用<code>j</code>跳转至下一行。它高亮显示从”one”到光标位置的所有文本。现在，如果您按<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐行可视模式适用于整行。按<code>V</code>并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按<code>Ctrl-V</code>，Vim像逐字符可视模式一样高亮显示光标下的字符，但向下移动时，除非光标已经在行尾，否则不会高亮显示光标上方的整行，它跳转至下一行时高亮显示尽可能少的字符。尝试用<code>h/j/k/l</code>移动，并观察光标的移动。</p>
<p>在Vim窗口的左下方，您会看到显示<code>-- VISUAL --</code>，<code>-- VISUAL LINE --</code>或<code>-- VISUAL BLOCK --</code>以提示您所处的可视模式。</p>
<p>当您处于可视模式时，可以通过按<code>v</code>，<code>V</code>或<code>Ctrl-V</code>键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行<code>Ctrl-V</code>。试试吧！</p>
<p>有三种退出可视模式的方法：<code>esc</code>，<code>Ctrl-C</code>和与当前可视模式相同的键。后者的意思是，如果您当前处于逐行可视模式(<code>V</code>)，则可以通过再次按<code>V</code>退出它。如果您处于字符可视模式，则可以通过按<code>v</code>退出它。如果您处于逐块可视模式，请按<code>Ctrl-V</code>。</p>
<p>实际上，还有另一种进入可视模式的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gv    转到上一个可视模式</span><br></pre></td></tr></table></figure>

<p>它将在与上次相同的高亮显示的文本块上启动相同的可视模式。</p>
<h2 id="可视模式导航"><a href="#可视模式导航" class="headerlink" title="可视模式导航"></a>可视模式导航</h2><p>在可视模式下，您可以使用Vim动作(motion)扩展高亮显示的文本块。</p>
<p>让我们使用之前使用的相同文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>这次让我们从”two”行开始。按<code>v</code>进入字符可视模式(这里的方括号<code>[]</code>表示高亮显示的字符)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>按<code>j</code>，Vim将高亮显示从”two”行到”three”行的第一个字符的所有文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>

<p>假设您刚刚意识到还需要高亮显示”one”行，因此按<code>k</code>。令您沮丧的是，它现在排除了”three”高亮。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？</p>
<p>答案是肯定的。让我们先恢复光标到高亮显示”two”和”three”行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree    &lt;-- 光标</span><br></pre></td></tr></table></figure>

<p>高亮区域跟随光标移动。如果要将其向上扩展到行”one”，则需要将光标移动到”two”，现在您的光标在”three”行上。这时可以用<code>o</code>或<code>O</code>切换光标位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two     &lt;-- 光标</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>

<p>现在，当您按<code>k</code>时，它不再缩小选择，而是向上扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>

<p>在可视模式中使用<code>o</code>或<code>O</code>，光标会在高亮选择区域的开头和结尾跳转，以便与您扩展高亮区域。</p>
<h2 id="可视模式语法"><a href="#可视模式语法" class="headerlink" title="可视模式语法"></a>可视模式语法</h2><p>可视模式与普通模式使用相同的操作符(operations)。</p>
<p>例如，如果您有以下文字，然后您想在可视模式中删除前两行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>用逐行可视模式(<code>V</code>)高亮显示”one”和”two”行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>按下<code>d</code>键将删除选择，类似于普通模式。请注意，与普通模式的语法规则有所不同，动词+名词不适用可视模式。虽然存在相同的动词(<code>d</code>)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词(反过来了)，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。</p>
<p>在普通模式下，有一些命令不需要名词(motion)，例如<code>x</code>删除光标下方的单个字符，还有<code>r</code>替换光标下方的字符(<code>rx</code>将当前光标下的字符替换为<code>x</code>)。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。回到高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>

<p>运行<code>x</code>会删除所有高亮显示的文本。</p>
<p>您可以使用此行为在markdown文本中快速创建标题。假设您需要快速下面的文本转换为一级markdown标题(“&#x3D;&#x3D;&#x3D;”):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br></pre></td></tr></table></figure>

<p>首先，您使用<code>yy</code>复制文本，然后使用<code>p</code>粘贴文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">Chapter One</span><br></pre></td></tr></table></figure>

<p>现在转到第二行，以逐行可视模式选择它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">[Chapter One]</span><br></pre></td></tr></table></figure>

<p>在markdown中，您可以通过在文本下方添加一系列<code>=</code>来创建标题，因此您可以通过运行<code>r=</code>来替换整个高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">===========</span><br></pre></td></tr></table></figure>

<p>要了解有关可视模式下的运算符的更多信息，请查看<code>:h visual-operators</code>。</p>
<h2 id="可视模式和Ex命令"><a href="#可视模式和Ex命令" class="headerlink" title="可视模式和Ex命令"></a>可视模式和Ex命令</h2><p>您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式,并想将前两行的”const”替换为”let”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;;</span><br><span class="line">const two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>

<p>用 <em>任意</em> 可视模式高亮显示前两行，然后运行替换命令<code>:s/const/let/g</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;one&quot;;</span><br><span class="line">let two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>

<p>请注意，我说过您可以使用 <em>任何</em> 可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。&#x3D;&#x3D;只要您在每行上至少选择一个字符，就会应用Ex命令。&#x3D;&#x3D;</p>
<h2 id="跨多行编辑"><a href="#跨多行编辑" class="headerlink" title="跨多行编辑"></a>跨多行编辑</h2><p>您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;</span><br><span class="line">const two = &quot;two&quot;</span><br><span class="line">const three = &quot;three&quot;</span><br></pre></td></tr></table></figure>

<p>将光标放在第一行上：</p>
<ul>
<li>进入逐块可视模式，并向下两行(<code>Ctrl-V jj</code>)。</li>
<li>高亮显示到行尾(<code>$</code>)。</li>
<li>按(<code>A</code>) ，然后键入”;”。</li>
<li>退出可视模式(<code>esc</code>)。</li>
</ul>
<p>您应该看到在每一行后面附加的 “;”。666! 有两种方法可以从逐块可视模式进入输入模式：可以使用<code>A</code>在光标后输入文本，也可以使用<code>I</code>在光标前输入文本。请勿将它们与普通模式下的<code>A</code>和<code>I</code>混淆。(普通模式中，<code>A</code>表示在行尾添加内容，<code>I</code>表示在行首非空字符前插入内容)。</p>
<p>另外，您也可以使用<code>:normal</code>命令在多行添加内容：<br>-高亮显示所有3行(<code>vjj</code>)。<br>-输入<code>:normal! A;</code>。</p>
<p>记住，<code>:normal</code>命令执行普通模式命令。您可以指示它运行<code>A;</code>在该行的末尾添加文本”;”。</p>
<h2 id="递增数字"><a href="#递增数字" class="headerlink" title="递增数字"></a>递增数字</h2><p>&#x3D;&#x3D;Vim有<code>Ctrl-X</code>和<code>Ctrl-A</code>命令来减少和增加数字&#x3D;&#x3D;。与可视模式一起使用时，可以跨多行递增数字。</p>
<p>如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：</p>
<ul>
<li>将光标移动到 <strong>第二行</strong>的 “1”。</li>
<li>启动逐块可视模式，并向下移动3行(<code>Ctrl-V 3j</code>)。这高亮显示剩余的”1”，现在除了第一行，所有的”1”应该已经高亮。</li>
<li>运行<code>g Ctrl-A</code>。</li>
</ul>
<p>您应该看到以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-5&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>g Ctrl-A</code>在多行上递增数字。 <code>Ctrl-X/Ctrl-A</code>也可以增加字母。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set nrformats+=alpha</span><br></pre></td></tr></table></figure>

<p><code>nrformats</code>选项指示Vim将哪个基数视为<code>Ctrl-A</code>和<code>Ctrl-X</code>递增和递减的“数字”。通过添加<code>alpha</code>，现在将字母字符视为数字。如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>将光标放在第二个”app-a”上。使用与上述相同的技术(<code>Ctrl-V 3j</code> 然后 <code>g Ctrl-A</code>)增加ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-b&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-c&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-d&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-e&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="选择最后一个可视模式区域"><a href="#选择最后一个可视模式区域" class="headerlink" title="选择最后一个可视模式区域"></a>选择最后一个可视模式区域</h2><p>前面章节中我提到了<code>gv</code>可以快速高亮显示上一个可视模式选择的内容。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&lt;    转到上一个可视模式高亮显示的第一个位置（行）(译者注，英文原版中&#x27;&lt;&#x27;前面的符号是`，但这应该是一个错误，应该是单引号&#x27;)</span><br><span class="line">&#x27;&gt;    转到上一个可视模式高亮显示的最后位置（行）</span><br></pre></td></tr></table></figure>

<p>之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：<code>:s/const/let/g</code>。当您这样做时，您应该看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#x27;&lt;,&#x27;&gt;s/const/let/g</span><br></pre></td></tr></table></figure>

<p>您实际上是在使用(<code>&#39;&lt;, &#39;&gt;</code>) 标记作为范围来执行 <code>s/const/let/g</code>命令。这太有趣了！</p>
<p>您随时可以随时编辑这些标记。比如，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#x27;&lt;,$s/const/let/g</span><br></pre></td></tr></table></figure>

<h2 id="从插入模式进入可视模式"><a href="#从插入模式进入可视模式" class="headerlink" title="从插入模式进入可视模式"></a>从插入模式进入可视模式</h2><p>您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-O v</span><br></pre></td></tr></table></figure>

<p>回想一下，在插入模式下运行<code>Ctrl-O</code>可以使您执行普通模式命令。在普通模式命令挂起模式下，运行<code>v</code>进入逐字可视模式。请注意，在屏幕的左下方，它显示为<code>--(insert) VISUAL--</code>。该技巧适用于任何可视模式运算符：<code>v</code>，<code>V</code>，和<code>Ctrl-V</code>。</p>
<h2 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h2><p>Vim具有类似于可视模式的模式，称为<em>选择模式</em>。与可视模式一样，它也具有三种不同的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gh         逐字符选择模式</span><br><span class="line">gH         逐行选择模式</span><br><span class="line">gCtrl-h    逐块选择模式</span><br></pre></td></tr></table></figure>

<p>选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。</p>
<p>在常规编辑器中，高亮显示文本块并键入字母（例如字母”y”）后，它将删除高亮显示的文本并插入字母”y”。如果您使用逐行选择模式(<code>gH</code>)高亮显示一行文本并键入”y”，它将删除高亮显示的文本并插入字母”y”，这与常规文本编辑器非常相似。</p>
<p>将此行为与可视模式进行对比：如果您使用逐行可视模式(<code>V</code>)高亮显示一行文本并键入”y”，则高亮显示的文本不会被删除且被字母”y”代替，而是仅将其复制(yank)。在选择模式中，你不能执行对高亮文本执行普通模式的命令。</p>
<p>我个人从未使用过选择模式，但是很高兴知道它的存在。</p>
<h2 id="以聪明的方式学习可视模式"><a href="#以聪明的方式学习可视模式" class="headerlink" title="以聪明的方式学习可视模式"></a>以聪明的方式学习可视模式</h2><p>可视模式是Vim高亮显示文本的过程。</p>
<p>如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。&#x3D;&#x3D;我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。&#x3D;&#x3D;假设您需要删除一个内部单词(inner word，请回顾前面的文本对象)，如果可以只用三个按键(<code>diw</code>)，为什么要使用四个按键<code>viwd</code>（先<code>v</code>进入可视模式，然后<code>iw</code>高亮一个内部单词，最后<code>d</code>删除）呢？前者更为直接和简洁。当然，有时使用可视模式是合适的，但总的来说，更倾向于直接的方法。</p>
<h1 id="第12章-搜索和替换"><a href="#第12章-搜索和替换" class="headerlink" title="第12章 搜索和替换"></a>第12章 搜索和替换</h1><p>本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您得基于文本的共同模式搜索大量的内容。通过学习如何在搜索和替换中使用正则表达式而不是字面字符串，您将能够快速定位任何文本。</p>
<p>附带说明一下，在本章中，当谈论搜索时，我将主要使用<code>/</code>。您使用<code>/</code>进行的所有操作也可以使用<code>?</code>完成。</p>
<h2 id="智能区分大小写"><a href="#智能区分大小写" class="headerlink" title="智能区分大小写"></a>智能区分大小写</h2><p>尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本”Learn Vim”，则很容易把字母的大小写输错，从而得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项<code>ignorecase</code>闪亮的地方。只需在 vimrc 中添加<code>set ignorecase</code>，所有搜索词就不区分大小写。现在，您不必再执行<code>/Learn Vim</code>了。 <code>/learn vim</code>将起作用。</p>
<p>但是，有时您需要搜索特定大小写的短语。一种方法是用 <code>set noignorecase</code> 关闭<code>ignorecase</code>选项，但是每次需要搜索区分大小写的短语时，都得反复地打开和关闭这个选项。</p>
<p>为避免反复开关<code>ignorecase</code>选项，Vim 有一个<code>smartcase</code>选项。您可以将<code>ignorecase</code>和<code>smartcase</code>选项结合起来，当您输入的搜索词全部是小写时，进行大小写不敏感搜索；而当搜索词 <strong>至少有1个大写字母时</strong>，进行大小写敏感搜索。</p>
<p>在您的 vimrc 中，添加:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set ignorecase smartcase</span><br></pre></td></tr></table></figure>

<p>如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">HELLO</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<ul>
<li><code>/hello</code> 匹配”hello”，”HELLO”和”Hello”。</li>
<li><code>/HELLO</code> 仅匹配”HELLO”。</li>
<li><code>/Hello</code> 仅匹配”Hello”。</li>
</ul>
<p>有一个缺点。因为现在当您执行<code>/hello</code>时，Vim 将进行大小写不敏感搜索,那如果只需要搜索小写字符串怎么办？您可以在搜索词前使用<code>\C</code>模式来告诉 Vim，后续搜索词将区分大小写。如果执行<code>/\Chello</code>，它将严格匹配”hello”，而不是”HELLO”或”Hello”。</p>
<h2 id="一行中的第一个和最后一个字符"><a href="#一行中的第一个和最后一个字符" class="headerlink" title="一行中的第一个和最后一个字符"></a>一行中的第一个和最后一个字符</h2><p>您可以使用<code>^</code>匹配行中的第一个字符，并使用<code>$</code>匹配行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>/^hello</code>来定位第一个”hello”。 ‘^’后面的字符必须是一行中的第一个字符。 要定位最后一个”hello”，请运行<code>/hello$</code>。 ‘$‘ 之前的字符必须是一行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello friend</span><br></pre></td></tr></table></figure>

<p>运行<code>/hello$</code>将匹配不到任何内容，因为”friend”是该行的最后一项，而不是”hello”。</p>
<h2 id="重复搜索"><a href="#重复搜索" class="headerlink" title="重复搜索"></a>重复搜索</h2><p>您可以使用<code>//</code>重复上一个搜索。如果您只是搜索<code>/hello</code>，则运行<code>//</code>等同于运行<code>/hello</code>。此快捷键可以为您节省一些按键操作，尤其是在您刚搜索了一个很长的字符串的情况下。另外，回想一下前面的章节，您还可以使用<code>n</code>和<code>N</code>分别以相同方向和相反方向重复上一次搜索。</p>
<p>如果您想快速回忆起 第<em>n</em>个最近使用的搜索字怎么办？您可以先按<code>/</code>，然后按<code>up</code>&#x2F;<code>down</code>方向键（或<code>Ctrl-N</code>&#x2F;<code>Ctrl-P</code>），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行<code>:history /</code>。</p>
<p>在搜索过程中到达文件末尾时，Vim 会抛出一个错误:<code>&quot;搜索到达底部,未找到匹配项:&#123;your-search&#125;&quot;</code>(<code>&quot;Search hit the BOTTOM without match for: &#123;your-search&#125;&quot;</code>)。有时这个特性能成为一个安全守卫，可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用<code>set wrapscan</code>选项使 Vim 在到达文件末尾时回到文件顶部进行搜索。要关闭此功能，请执行<code>set nowrapscan</code>。</p>
<h2 id="使用候选词搜索"><a href="#使用候选词搜索" class="headerlink" title="使用候选词搜索"></a>使用候选词搜索</h2><p>一次搜索多个单词属于日常操作。 如果您需要搜索”hello vim”或”hola vim”，而不是”salve vim”或”bonjour vim”，则可以使用<code>|</code>或运算符。</p>
<p>给予这样一段文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>

<p>要同时匹配”hello”和”hola”，可以执行<code>/hello\|hola</code>。 您必须使用（<code>\</code>）转义（<code>|</code>）或运算符，否则 Vim 将按字面意义搜索字符串”|”。</p>
<p>如果您不想每次都输入<code>\|</code>，则可以在搜索开始时使用<code>magic</code>语法（<code>\v</code>）:<code>/\vhello|hola</code>。 我不会在本章中详细介绍<code>magic</code>，但是有了<code>\v</code>，您就不必再转义特殊字符了。 要了解有关<code>\v</code>的更多信息，请随时查看<code>:h \v</code>。</p>
<h2 id="设置模式匹配的开始位置和结束位置"><a href="#设置模式匹配的开始位置和结束位置" class="headerlink" title="设置模式匹配的开始位置和结束位置"></a>设置模式匹配的开始位置和结束位置</h2><p>也许您需要搜索的文本是复合词的一部分。如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11vim22</span><br><span class="line">vim22</span><br><span class="line">11vim</span><br><span class="line">vim</span><br></pre></td></tr></table></figure>

<p>如果您仅需要选择以”11”开始、以”22”结束的”vim”，您可以使用<code>\zs</code>（开始匹配）和<code>\ze</code>（结束匹配）运算符。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/11\zsvim\ze22</span><br></pre></td></tr></table></figure>

<p>Vim仍然会匹配整个模式”11vim22”，但是仅高亮显示介于<code>\zs</code>和<code>\ze</code>之间的内容。 另一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foobar</span><br><span class="line">foobaz</span><br></pre></td></tr></table></figure>

<p>如果需要在”foobaz”中搜索”foo”，而不是在”foobar”中搜索，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo\zebaz</span><br></pre></td></tr></table></figure>

<h2 id="搜索字符组"><a href="#搜索字符组" class="headerlink" title="搜索字符组"></a>搜索字符组</h2><p>到目前为止，您所有的搜索字都是字面内容。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符组<code>[ ]</code>。</p>
<p>如果您需要搜索任何数字，则可能不想每一次都输入<code>/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0</code>。相反，请使用<code>/[0-9]</code>来匹配一位数字。 <code>0-9</code>表达式表示 Vim 尝试匹配的数字范围是 0-9，因此，如果要查找 1 到 5 之间的数字，请使用<code>/[1-5]</code>。</p>
<p>数字不是 Vim 可以查找的唯一数据类型。您也可以执行<code>/[a-z]</code>来搜索小写字母，而<code>/[A-Z]</code>来搜索大写字母。</p>
<p>您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行<code>/[0-9a-fA-F]</code>。</p>
<p>要进行否定搜索，可以在字符范围括号内添加<code>^</code>。要搜索非数字，请运行<code>/[^0-9]</code>，Vim会匹配任何字符，只要它不是数字即可。请注意，范&#x3D;&#x3D;围括号内的脱符号（<code>^</code>）与行首位置符号（例如:<code>/^hello</code>）不同&#x3D;&#x3D;。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示”一行中的第一个字符”。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 <code>/^abc</code>匹配行中的第一个”abc”，而<code>/[^abc]</code>匹配除”a”，”b”或”c”以外的任何字符。</p>
<h2 id="搜索重复字符"><a href="#搜索重复字符" class="headerlink" title="搜索重复字符"></a>搜索重复字符</h2><p>如果需要在此文本中搜索两位数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1aa</span><br><span class="line">11a</span><br><span class="line">111</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>/[0-9][0-9]</code>来匹配两位数字字符，但是该方法难以扩展。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个<code>count</code>参数。</p>
<p>您可以将<code>count</code>传递给您的搜索。 它具有以下语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;n,m&#125;</span><br></pre></td></tr></table></figure>

<p>顺便说一句，当在 Vim 中使用它们时，这些<code>count</code>周围的花括号需要被转义。 <code>count</code> 运算符放在您要递增的单个字符之后。</p>
<p>这是<code>count</code>语法的四种不同变体: </p>
<ul>
<li><code>&#123;n&#125;</code>是精确匹配。 <code>/[0-9]\&#123;2\&#125;</code>匹配两个数字:”11”，以及”111”中的”11”。</li>
<li><code>&#123;n,m&#125;</code>是范围匹配。 <code>/[0-9]\&#123;2,3\&#125;</code>匹配 2 到 3 位数字:”11”和”111”。 </li>
<li><code>&#123;,m&#125;</code>是上限匹配。 <code>/[0-9]\&#123;,3\&#125;</code>匹配最多 3 个数字:”1”，”11”和”111”。</li>
<li><code>&#123;n,&#125;</code>是下限匹配。 <code>/[0-9]\&#123;2,\&#125;</code>匹配最少 2 个或多个数字:”11”和”111”。</li>
</ul>
<p>计数参数<code>\&#123;0,\&#125;</code>（零或多个）和<code>\&#123;1,\&#125;</code>（一个或多个）是最常见的搜索模式，Vim 为它们提供了特殊的操作符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）。 如果执行<code>/[0-9]*</code>，功能与<code>/[0-9]\&#123;0,\&#125;</code>相同。 它搜索零个或多个数字，会匹配””，”1”，”123”。 顺便说一句，它也将匹配非数字，例如”a”，因为在技术上，字母”a”中的数字个数为零。 在使用”*“之前，请仔细考虑。 如果执行<code>/[0-9]\+</code>，则与<code>/[0-9]\&#123;1,\&#125;</code>相同。 它搜索一个或多个数字，将匹配”1”和”12”。</p>
<h2 id="预定义的字符组"><a href="#预定义的字符组" class="headerlink" title="预定义的字符组"></a>预定义的字符组</h2><p>Vim 为常见字符组（例如数字和字母）提供了简写。 我不会在这里逐一介绍，但可以在<code>:h /character-classes</code>中找到完整列表。 下面是有用的部分:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d    数字[0-9]</span><br><span class="line">\D    非数字[^ 0-9]</span><br><span class="line">\s    空格字符（空格和制表符）</span><br><span class="line">\S    非空白字符（除空格和制表符外的所有字符）</span><br><span class="line">\w    单词字符[0-9A-Za-z_]</span><br><span class="line">\l    小写字母[a-z]</span><br><span class="line">\u    大写字符[A-Z]</span><br></pre></td></tr></table></figure>

<p>您可以像使用普通字符组一样使用它们。 要搜索任何一位数字，可以使用<code>/\d</code>以获得更简洁的语法，而不使用<code>/[0-9]</code>。</p>
<h2 id="搜索示例：在一对相似字符之间捕获文本"><a href="#搜索示例：在一对相似字符之间捕获文本" class="headerlink" title="搜索示例：在一对相似字符之间捕获文本"></a>搜索示例：在一对相似字符之间捕获文本</h2><p>如果要搜索由双引号引起来的短语:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Vim is awesome!&quot;</span><br></pre></td></tr></table></figure>

<p>运行这个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`/&quot;[^&quot;]\+&quot;`</span><br></pre></td></tr></table></figure>

<p>让我们分解一下:</p>
<ul>
<li><code>&quot;</code> 是字面双引号。它匹配第一个双引号。</li>
<li><code>[^&quot;]</code> 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。</li>
<li><code>\+</code>表示一个或多个。因为它的前面是<code>[^&quot;]</code>，因此 Vim 查找一个或多个不是双引号的字符。</li>
<li><code>&quot;</code> 是字面双引号。它与右双引号匹配。</li>
</ul>
<p>当看到第一个<code>&quot;</code>时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个<code>&quot;</code>模式并停止模式捕获。同时，两个双引号之间的所有非双引号字符都被<code>[^&quot;]\+</code> 模式捕获，在这个例子中是短语”Vim is awesome!”。这是一个通用模式（其实就是正则表达式）用于捕获 <strong>由一对类似的定界符包围的短语</strong>。</p>
<ul>
<li>要捕获被单引号包围的短语，你可以使用<code>/&#39;[^&#39;]\+&#39;</code></li>
<li>要捕获为0包围的短语，你可以使用<code>/0[^0]\+0</code></li>
</ul>
<h2 id="搜索示例：捕获电话号码"><a href="#搜索示例：捕获电话号码" class="headerlink" title="搜索示例：捕获电话号码"></a>搜索示例：捕获电话号码</h2><p>如果要匹配以连字符(<code>-</code>)分隔的美国电话号码，例如<code>123-456-7890</code>，则可以使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\d\&#123;3\&#125;-\d\&#123;3\&#125;-\d\&#123;4\&#125;</span><br></pre></td></tr></table></figure>

<p>美国电话号码的组成是：首先是三位数字，其后是另外三位数字，最后是另外四位数字。 让我们分解一下:</p>
<ul>
<li><code>\d\&#123;3\&#125;</code>与精确重复三次的数字匹配</li>
<li><code>-</code>是字面的连字符</li>
</ul>
<p>为&#x3D;&#x3D;避免转义，可使用<code>\v</code>&#x3D;&#x3D;:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;</span><br></pre></td></tr></table></figure>

<p>此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。</p>
<p>这涵盖了本章的搜索部分。 现在开始讲替换。</p>
<h2 id="基本替换"><a href="#基本替换" class="headerlink" title="基本替换"></a>基本替换</h2><p>Vim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/&#123;old-pattern&#125;/&#123;new-pattern&#125;/</span><br></pre></td></tr></table></figure>

<p>让我们从一个基本用法开始。 如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is good</span><br></pre></td></tr></table></figure>

<p>让我们用”awesome”代替”good”，因为 Vim 很棒。 运行<code>:s/good/awesome/.</code>您应该看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br></pre></td></tr></table></figure>

<h2 id="重复最后一次替换"><a href="#重复最后一次替换" class="headerlink" title="重复最后一次替换"></a>重复最后一次替换</h2><p>您可以使用普通模式命令<code>&amp;</code>或运行<code>:s</code>来重复最后一个替代命令。 如果您刚刚运行<code>:s/good/awesome/</code>，则运行<code>&amp;</code>或<code>:s</code>将会重复执行。</p>
<p>另外，在本章前面，我提到您可以使用<code>//</code>来重复先前的搜索模式。 此技巧可用于替代命令。 如果<code>/good</code>是最近被替换的单词，那么将第一个替换模式参数留为空白，例如在<code>:s//awesome/</code>中，则与运行<code>:s/good/awesome/</code>相同。</p>
<h2 id="替换范围"><a href="#替换范围" class="headerlink" title="替换范围"></a>替换范围</h2><p>就像许多 Ex 命令一样，您可以将范围参数传递给替换命令。 语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]s/old/new/</span><br></pre></td></tr></table></figure>

<p>如果您有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>

<p>要将第3行到第5行中的”let”替换为”const”，您可以执行以下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3,5s/let/const/</span><br></pre></td></tr></table></figure>

<p>下面是一些你可以使用的范围参数的变体:</p>
<ul>
<li><code>:,3s/let/const/</code> - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换到第 3 行。</li>
<li><code>:1,s/let/const/</code> - 如果逗号后没有给出任何内容，它也代表当前行。 从第 1 行替换到当前行。</li>
<li><code>:3s/let/const/</code> - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。</li>
</ul>
<p>在 Vim 中，<code>%</code>通常表示整个文件。 如果运行<code>:%s/let/const/</code>，它将在所有行上进行替换。请记住这个范围参数语法，在后面章节中很多命令行命令都遵循这个语法。</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>接下来的几节将介绍基本的正则表达式。 丰富的模式知识对于掌握替换命令至关重要。</p>
<p>如果您具有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>

<p>要在数字周围添加一对双引号:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\d/&quot;\0&quot;/</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>让我们分解一下命令:</p>
<ul>
<li><code>:%s</code> 定位整个文件以执行替换。</li>
<li><code>\d</code> 是 Vim 的预定义数字范围简写(类似使用<code>[0-9]</code>)。</li>
<li><code>&quot;\0&quot;</code> 双引号是双引号的字面值。 <code>\0</code>是一个特殊字符，代表”整个匹配的模式”。 此处匹配的模式是单个数字<code>\d</code>。</li>
</ul>
<p>另外，<code>&amp;</code>也同样代表”整个匹配的模式”，就像<code>\0</code>一样。 <code>:s/\d/&quot;&amp;&quot;/</code>也可以。</p>
<p>让我们考虑另一个例子。 给出以下表达式，您需要将所有的”let”和变量名交换位置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one let = &quot;1&quot;;</span><br><span class="line">two let = &quot;2&quot;;</span><br><span class="line">three let = &quot;3&quot;;</span><br><span class="line">four let = &quot;4&quot;;</span><br><span class="line">five let = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>为此，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\(\w\+\) \(\w\+\)/\2 \1/</span><br></pre></td></tr></table></figure>

<p>上面的命令包含太多的反斜杠，很难阅读。 使用<code>\v</code>运算符更方便:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\w+) (\w+)/\2 \1/</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>太好了！ 让我们分解该命令:</p>
<ul>
<li><code>:%s</code> 定位文件中的所有行以执行替换操作</li>
<li><code>(\w+) (\w+)</code>对模式进行分组。<code>\w</code>是 Vim 预定义的单词字符范围简写(<code>[0-9A-Za-z_]</code>)之一。 包围<code>\w</code>的<code>()</code>将匹配的单词字符进行分组。 请注意两个分组之间的空间。 <code>(\w+) (\w+)</code> 捕获两个分组。 在第一行上，第一组捕获”let”，第二组捕获”one”。(英文版中，作者写成了：第一组捕获”one”，第二组捕获”two”，可能是作者不小心的错误)。</li>
<li><code>\2 \1</code> 以相反的顺序返回捕获的组。 <code>\2</code>包含捕获的字符串”let”，而<code>\1</code>包含字符串”one”。 使<code>\2 \1</code>返回字符串”let one”。</li>
</ul>
<p>回想一下，<code>\0</code>代表整个匹配的模式。 您可以&#x3D;&#x3D;使用<code>( )</code>将匹配的字符串分成较小的组&#x3D;&#x3D;。 每个组都由<code>\1</code>, <code>\2</code>, <code>\3</code>等表示。</p>
<p>让我们再举一个例子来巩固这一匹配分组的概念。 如果您有以下数字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure>

<p>要颠倒顺序，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d)(\d)(\d)/\3\2\1/</span><br></pre></td></tr></table></figure>

<p>结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">321</span><br><span class="line">654</span><br><span class="line">987</span><br></pre></td></tr></table></figure>

<p>每个<code>(\d)</code>都匹配一个数字并创建一个分组。 在第一行上，第一个<code>(\d)</code>的值为”1”，第二个<code>(\d)</code>的值为”2”，第三个<code>(\d)</code>的值为”3”。 它们存储在变量<code>\1</code>，<code>\2</code>和<code>\3</code>中。 在替换的后半部分，新模式<code>\3\2\1</code>在第一行上产生”321”值。</p>
<p>相反，如果您运行下面的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d\d)(\d)/\2\1/</span><br></pre></td></tr></table></figure>
<p>您将获得不同的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">312</span><br><span class="line">645</span><br><span class="line">978</span><br></pre></td></tr></table></figure>

<p>这是因为您现在只有两个组。 被<code>(\d\d)</code>捕获的第一组存储在<code>\1</code>内，其值为”12”。 由<code>(\d)</code>捕获的第二组存储在<code>\2</code>内部，其值为”3”。 然后，<code>\2\1</code>返回”312”。</p>
<h2 id="替换标志"><a href="#替换标志" class="headerlink" title="替换标志"></a>替换标志</h2><p>如果您有以下句子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>

<p>要将所有 pancakes 替换为 donut，您不能只运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut</span><br></pre></td></tr></table></figure>

<p>上面的命令将仅替换第一个匹配项，返回的结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate donut, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>

<p>有两种解决方法。 一，您可以再运行两次替代命令。 二，您可以向其传递全局(<code>g</code>)标志来替换一行中的所有匹配项。</p>
<p>让我们谈谈全局标志。 运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut/g</span><br></pre></td></tr></table></figure>

<p>Vim 迅速将所有”pancake”替换为”donut”。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;    重用上一个替代命令中的标志。 必须作为第一个标志传递。</span><br><span class="line">g    替换行中的所有匹配项。</span><br><span class="line">c    要求替代确认。</span><br><span class="line">e    防止替换失败时显示错误消息。</span><br><span class="line">i    执行不区分大小写的替换</span><br><span class="line">I    执行区分大小写的替换</span><br></pre></td></tr></table></figure>

<p>我上面没有列出更多标志。 要了解所有标志，请查看<code>:h s_flags</code>。</p>
<p>顺便说一句，重复替换命令（<code>&amp;</code>和<code>:s</code>）不保留标志。 运行<code>&amp;</code>只会重复<code>:s/pancake/donut/</code>而没有<code>g</code>。 要使用所有标志快速重复最后一个替代命令，请运行<code>:&amp;&amp;</code>。</p>
<h2 id="更改定界符"><a href="#更改定界符" class="headerlink" title="更改定界符"></a>更改定界符</h2><p>如果您需要用长路径替换 URL:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mysite.com/a/b/c/d/e</span><br></pre></td></tr></table></figure>

<p>要用单词”hello”代替它，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/</span><br></pre></td></tr></table></figure>

<p>但是，很难说出哪些正斜杠（<code>/</code>）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或<code>&quot;</code>，<code>|</code>和<code>\</code>之外的字符）来更改定界符。让我们将它们替换为<code>+</code>。上面的替换命令可以重写为 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+</span><br></pre></td></tr></table></figure>

<p>现在，更容易看到分隔符在哪里。</p>
<h2 id="特殊替换"><a href="#特殊替换" class="headerlink" title="特殊替换"></a>特殊替换</h2><p>您还可以修改要替换的文本的大小写。 给出以下表达式，您的任务是将所有变量名比如 “one”, “two”, “three”等，改成大写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/\v(\w+) (\w+)/\1 \U\2/</span><br></pre></td></tr></table></figure>

<p>你会得到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ONE = &quot;1&quot;;</span><br><span class="line">let TWO = &quot;2&quot;;</span><br><span class="line">let THREE = &quot;3&quot;;</span><br><span class="line">let FOUR = &quot;4&quot;;</span><br><span class="line">let FIVE = &quot;5&quot;;</span><br></pre></td></tr></table></figure>

<p>这是该命令的细分:</p>
<ul>
<li><code>(\w+) (\w+)</code>捕获前两个匹配的分组，例如”let”和”one”。</li>
<li><code>\1</code>返回第一个组的值”let”</li>
<li><code>\U\2</code>大写(<code>\U</code>)第二组(<code>\2</code>)。</li>
</ul>
<p>该命令的窍门是表达式<code>\U\2</code>。<code>\U</code>将后面跟着的字符变为大写。</p>
<p>让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is the greatest text editor in the whole galaxy</span><br></pre></td></tr></table></figure>

<p>您可以运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/\&lt;./\U&amp;/g</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vim Is The Greatest Text Editor In The Whole Galaxy</span><br></pre></td></tr></table></figure>

<p>细目如下:</p>
<ul>
<li><code>:s</code> 替换当前行</li>
<li><code>\&lt;.</code> 由两部分组成:<code>\&lt;</code>匹配单词的开头，<code>.</code>匹配任何字符。 <code>\&lt;</code>运算符使后面跟着的字符表示单词的第一个字符。 由于<code>.</code>是下一个字符，因此它将匹配任意单词的第一个字符。</li>
<li><code>\U&amp;</code> 将后续符号子序列<code>&amp;</code>大写。 回想一下，<code>&amp;</code>（或<code>\0</code>）代表整个匹配。 这里它匹配单词的第一个字符。</li>
<li><code>g</code>全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。</li>
</ul>
<p>要了解替换的特殊替换符号（如<code>\u</code>和<code>\U</code>）的更多信息，请查看<code>:h sub-replace-special</code>。</p>
<h2 id="候选模式"><a href="#候选模式" class="headerlink" title="候选模式"></a>候选模式</h2><p>有时您需要同时匹配多个模式。 如果您有以下问候:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>

<p>您仅需在包含单词”hello”或”hola”的行上用”friend”代替”vim”。回想一想本章前面的知识点，你可以使用<code>|</code> 来分隔可选的模式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(hello|hola) vim)/\1 friend/g</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello friend</span><br><span class="line">hola friend</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>

<p>这是细分:</p>
<ul>
<li><code>%s</code> 在文件的每一行上运行替代命令。</li>
<li><code>(hello|hola)</code> 匹配*“hello”或”hola”，并将其视为一个组。</li>
<li><code>vim</code> 是字面意思”vim”。</li>
<li><code>\1</code> 是第一个匹配组，它是文本”hello”或”hola”。</li>
<li><code>friend</code> 是字面的“朋友”。</li>
</ul>
<h2 id="指定替换模式的开始位置和结束位置"><a href="#指定替换模式的开始位置和结束位置" class="headerlink" title="指定替换模式的开始位置和结束位置"></a>指定替换模式的开始位置和结束位置</h2><p>回想一下，您可以使用<code>\zs</code>和<code>\ze</code>来指定一个匹配的开始位置和结束位置。这个技术在替换操作中同样有效，如果你有以下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake</span><br><span class="line">strawberry sweetcake</span><br><span class="line">blueberry hotcake</span><br></pre></td></tr></table></figure>

<p>要想将”hotcake”中的”cake”替换为”dog”，得到”hotdog”:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/hot\zscake/dog/g</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake</span><br><span class="line">strawberry sweetcake</span><br><span class="line">blueberry hotdog</span><br></pre></td></tr></table></figure>

<h2 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h2><p>您可以使用下面技巧，在某行中替换第n个匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.</span><br></pre></td></tr></table></figure>

<p>要想将第3个”Mississippi”替换为 “Arkansas”，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/\v(.&#123;-&#125;\zsMississippi)&#123;3&#125;/Arkansas/g</span><br></pre></td></tr></table></figure>

<p>命令分解：</p>
<ul>
<li><code>:s/</code> 替换命令。</li>
<li><code>\v</code> 魔术关键字，使您不必转义特殊字符。</li>
<li><code>.</code> 匹配任意单个字符。</li>
<li><code>&#123;-&#125;</code> 表示使用非贪婪模式匹配前面的0个或多个字符。</li>
<li><code>\zsMississippi</code> 使得从”Mississippi”开始捕获匹配。</li>
<li><code>(...)&#123;3&#125;</code> 查找第3个匹配</li>
</ul>
<p>在本章前面的内容中，你已经看到过<code>&#123;3&#125;</code>这样的语法。在本例中，&#x3D;&#x3D;<code>&#123;3&#125;</code>将精确匹配第3个匹配&#x3D;&#x3D;。这里的新技巧是<code>&#123;-&#125;</code>。它表示进行非贪婪匹配。它会找到符合给定模式的&#x3D;&#x3D;最短的匹配&#x3D;&#x3D;。在本例中，<code>(.&#123;-&#125;Mississippi)</code>匹配以任意字符开始、数量最少的”Mississippi”。对比<code>(.*Mississippi)</code>，后者会找到符合给定模式的最长匹配。</p>
<p>如果您使用<code>(.&#123;-&#125;Mississippi)</code>，你会得到5个匹配：”One Mississippi”, “Two Mississippi”,等。如果您使用<code>(.*Mississippi)</code>，您只会得到1个匹配：最后一个 “Mississippi”。<code>*</code>表示贪婪匹配，而<code>&#123;-&#125;</code>表示非贪婪匹配。要想了解更多，可以查看 <code>:h /\&#123;-</code> 和 <code>:h non-greedy</code>。</p>
<p>让我们看一个简单的例子。如果您有以下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc1de1</span><br></pre></td></tr></table></figure>

<p>用贪婪模式匹配 “abc1de1” ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a.*1</span><br></pre></td></tr></table></figure>

<p>用非贪婪模式匹配 “abc1”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a.\&#123;-&#125;1</span><br></pre></td></tr></table></figure>

<p>因此，如果您需要将最长的匹配转为大写（贪婪模式），运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/a.*1/\U&amp;/g</span><br></pre></td></tr></table></figure>

<p>会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC1DE1</span><br></pre></td></tr></table></figure>

<p>如果您需要将最短的匹配转为大写（非贪婪模式），运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/a.\&#123;-&#125;1/\U&amp;/g</span><br></pre></td></tr></table></figure>

<p>会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC1de1</span><br></pre></td></tr></table></figure>

<p>如果您是第一次接触贪婪模式与非贪婪模式这两个概念，可能会把你绕晕。围绕不同的组合去实验，知道您明白这两个概念。</p>
<h2 id="跨多个文件替换"><a href="#跨多个文件替换" class="headerlink" title="跨多个文件替换"></a>跨多个文件替换</h2><p>最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: <code>food.txt</code> 和 <code>animal.txt</code>.</p>
<p><code>food.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">corn dog</span><br><span class="line">hot dog</span><br><span class="line">chili dog</span><br></pre></td></tr></table></figure>

<p><code>animal.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">large dog</span><br><span class="line">medium dog</span><br><span class="line">small dog</span><br></pre></td></tr></table></figure>

<p>假设您的目录结构如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├ food.txt</span><br><span class="line">├ animal.txt</span><br></pre></td></tr></table></figure>

<p>首先，用<code>:args</code>同时捕获”food.txt”和”animal.txt”到参数列表中。回顾前面的章节，<code>:args</code>可用于创建文件名列表。在 Vim 中有几种方法可以做到这一点，其中一种方法是在Vim内部运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:args *.txt                  捕获当前位置的所有txt文件</span><br></pre></td></tr></table></figure>

<p>测试一下，当您运行<code>:args</code>时，您应该会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[food.txt] animal.txt</span><br></pre></td></tr></table></figure>

<p>现在，所有的相关文件都已经存储在参数列表中，您可以用 <code>:argdo</code> 命令跨多文件替换，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo %s/dog/chicken/</span><br></pre></td></tr></table></figure>

<p>这条命令对所有<code>:args</code>列表中的文件执行替换操作。最终，存储修改的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo update</span><br></pre></td></tr></table></figure>

<p><code>:args</code> 和 <code>:argdo</code> 是两个有用的工具，用于跨多文件执行命令行命令。可以用其他命令结合尝试一下！</p>
<h2 id="用宏跨多个文件替换"><a href="#用宏跨多个文件替换" class="headerlink" title="用宏跨多个文件替换"></a>用宏跨多个文件替换</h2><p>另外，您也可以用宏跨多个文件运行替代命令。执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:args *.txt</span><br><span class="line">qq</span><br><span class="line">:%s/dog/chicken/g</span><br><span class="line">:wnext</span><br><span class="line">q</span><br><span class="line">99@q</span><br></pre></td></tr></table></figure>

<p>以下是步骤的细分:</p>
<ul>
<li><code>:args *.txt</code> 会将相关文件列出到<code>:args</code>列表中。</li>
<li><code>qq</code> 启动”q”寄存器中的宏。</li>
<li><code>:%s/dog/chicken/g</code>在当前文件的所有行上用”chicken”替换”dog”。</li>
<li><code>:wnext</code> 写入（保存）文件，然后转到<code>args</code>列表中的下一个文件。就像同时运行<code>:w</code>和<code>:next</code>一样。</li>
<li><code>q</code> 停止宏录制。</li>
<li><code>99@q</code> 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。</li>
</ul>
<h2 id="以聪明的方式学习搜索和替换"><a href="#以聪明的方式学习搜索和替换" class="headerlink" title="以聪明的方式学习搜索和替换"></a>以聪明的方式学习搜索和替换</h2><p>良好的搜索能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。要想掌握正则表达式，您必须在实践中去不断地使用它。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。</p>
<p>一种提高模式匹配技能的好方法是，每当您需要搜索一个模式串时（例如”hello 123”），不要直接查询文字的字面值(<code>/hello 123</code>)，去尝试使用模式串来搜索它(比如<code>/\v(\l+) (\d+)</code>)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。</p>
<p>既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><ul>
<li>使用候选词搜索</li>
<li><code>&#123;n,m&#125;</code></li>
<li>特殊的操作符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）</li>
</ul>
<h3 id="和-g"><a href="#和-g" class="headerlink" title="% 和 g"></a>% 和 g</h3><ul>
<li><p>将文档每行&#x3D;&#x3D;第一个匹配&#x3D;&#x3D;上的 <code>&lt;old string&gt;</code> 替换为 <code>&lt;new string&gt;</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/&lt;old string&gt;/&lt;new string&gt;/</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文档中&#x3D;&#x3D;所有&#x3D;&#x3D;的 <code>&lt;old string&gt;</code> 替换为 <code>&lt;new string&gt;</code></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/&lt;old string&gt;/&lt;new string&gt;/g</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="设置tab位4个空格"><a href="#设置tab位4个空格" class="headerlink" title="设置tab位4个空格"></a>设置tab位4个空格</h1><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>如果要修改全局Vim的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vim/vimrc1</span><br></pre></td></tr></table></figure>

<p>但是不建议这么做，可以只修改当前用户的Vim配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc1</span><br></pre></td></tr></table></figure>

<p>在配置文件中添加以下参数</p>
<ol>
<li><p>第一种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set sw=412</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set expandtab</span><br><span class="line">set autoindent123</span><br></pre></td></tr></table></figure></li>
</ol>
<p>建议使用第二种，具有兼容性</p>
<h2 id="修改已保存文件"><a href="#修改已保存文件" class="headerlink" title="修改已保存文件"></a>修改已保存文件</h2><h3 id="Tab替换为空格"><a href="#Tab替换为空格" class="headerlink" title="Tab替换为空格"></a>Tab替换为空格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set expandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>

<h3 id="空格替换为Tab"><a href="#空格替换为Tab" class="headerlink" title="空格替换为Tab"></a>空格替换为Tab</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set noexpandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>

<p>加感叹号<code>!</code>是用于处理非空白字符之后的Tab，即所有的Tab</p>
<p>若不加感叹号<code>!</code>，则只处理行首的Tab修改配置</p>
<hr>
<p>如果要修改全局Vim的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vim/vimrc1</span><br></pre></td></tr></table></figure>

<p>但是不建议这么做，可以只修改当前用户的Vim配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc1</span><br></pre></td></tr></table></figure>

<p>在配置文件中添加以下参数</p>
<ol>
<li><p>第一种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set sw=412</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set ts=4</span><br><span class="line">set expandtab</span><br><span class="line">set autoindent123</span><br></pre></td></tr></table></figure></li>
</ol>
<p>建议使用第二种，具有兼容性</p>
<h2 id="修改已保存文件-1"><a href="#修改已保存文件-1" class="headerlink" title="修改已保存文件"></a>修改已保存文件</h2><h3 id="Tab替换为空格-1"><a href="#Tab替换为空格-1" class="headerlink" title="Tab替换为空格"></a>Tab替换为空格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set expandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>



<h3 id="空格替换为Tab-1"><a href="#空格替换为Tab-1" class="headerlink" title="空格替换为Tab"></a>空格替换为Tab</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set ts=4</span><br><span class="line">:set noexpandtab</span><br><span class="line">:%retab!123</span><br></pre></td></tr></table></figure>

<p>加感叹号<code>!</code>是用于处理非空白字符之后的Tab，即所有的Tab</p>
<p>若不加感叹号<code>!</code>，则只处理行首的Tab</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/03/152/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/03/152/" class="post-title-link" itemprop="url">152. LaTeX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-03 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-03T00:00:00+08:00">2023-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/latex/" itemprop="url" rel="index"><span itemprop="name">latex</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="认识-Latex"><a href="#认识-Latex" class="headerlink" title="认识 Latex"></a>认识 Latex</h2><h3 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h3><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>反斜杠加上命令名称,再加上花括号内的参数</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br></pre></td></tr></table></figure>



<h3 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h3><table>
<thead>
<tr>
<th align="center">符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>#</code></td>
<td>自定义命令时,用于标明参数序号。</td>
</tr>
<tr>
<td align="center"><code>$</code></td>
<td>数学环境命令符。</td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td>注释符,其后的该行命令都会视为注释。如果在行末添加这个命令,可以防止 LaTeX 在行末插入一些奇怪的空白符。</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td>数学环境中的上标命令符。</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td>表格环境中的跳列符。</td>
</tr>
<tr>
<td align="center"><code>_</code></td>
<td>数学环境中的下标命令符。</td>
</tr>
<tr>
<td align="center">{ 与 }</td>
<td>用于标记命令的必选参数,或者标记某一部分命令使其成为一个整体。</td>
</tr>
<tr>
<td align="center"><code>\</code></td>
<td>用于开始 LaTeX 命令。</td>
</tr>
</tbody></table>
<h3 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[option]&#123;doc-class&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>在语句 <code>\begin&#123;document&#125;</code> 之前的内容称为&#x3D;&#x3D;导言区&#x3D;&#x3D;，导言区即模板定义</p>
<h4 id="doc-class"><a href="#doc-class" class="headerlink" title="doc-class"></a>doc-class</h4><table>
<thead>
<tr>
<th>doc-class(文档类)</th>
<th>类别</th>
</tr>
</thead>
<tbody><tr>
<td>article</td>
<td>科学期刊、演示文稿、短报告、邀请函</td>
</tr>
<tr>
<td>proc</td>
<td>基于 article 的会议论文集</td>
</tr>
<tr>
<td>report</td>
<td>多章节的长报告、博士论文、短篇书</td>
</tr>
<tr>
<td>book</td>
<td>书籍</td>
</tr>
<tr>
<td>slides</td>
<td>幻灯片,使用了大号 Scans Serif 字体</td>
</tr>
</tbody></table>
<blockquote>
<p>此外还有 beamer 宏包定义的 beamer 文档类,其常用于创建幻灯片。</p>
</blockquote>
<h4 id="options-可选项"><a href="#options-可选项" class="headerlink" title="options (可选项)"></a>options (可选项)</h4><table>
<thead>
<tr>
<th>options</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>字体</td>
<td>默认 10 pt,可选 11 pt 和 12 pt</td>
</tr>
<tr>
<td>页面方向</td>
<td>默认 portrait (竖向),可选 landscape (横向)</td>
</tr>
<tr>
<td>纸张尺寸</td>
<td>默认 letterpaper ,可选 a4paper 、b5paper 等</td>
</tr>
<tr>
<td>分栏</td>
<td>默认 onecolumn ,可选 twocolumn</td>
</tr>
<tr>
<td>双面打印</td>
<td>有 oneside&#x2F;twoside 两个选项,用于排版奇偶页, article&#x2F;report 默认单面</td>
</tr>
<tr>
<td>章节分页</td>
<td>有 openright&#x2F;openany 两个选项,决定在奇数页或任意页开启新页。注意,article 是没有 chapter (章)命令的,默认任意页</td>
</tr>
<tr>
<td>公式对齐</td>
<td>默认居中;可改为左对齐 fleqn ;默认编号居右,可改为左对齐leqno</td>
</tr>
<tr>
<td>草稿选项</td>
<td>默认 final ,可改为 draft ,使行溢出的部分显示为黑块</td>
</tr>
</tbody></table>
<h4 id="宏包"><a href="#宏包" class="headerlink" title="宏包"></a>宏包</h4><p>导言区最常见的是宏包的加载工作，命令形如：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;package&#125;</span><br></pre></td></tr></table></figure>

<p>宏包是指一系列已经制作好的功能“模块”，在你需要使用一些非原生 LaTeX 功能时,只需调用这些宏包就可以了</p>
<p><strong>学习宏包</strong></p>
<p>按 Win+R 组合键调出运行对话框,输入 <code>texdoc</code> 加上宏包名称即可打开宏包 pdf 帮助文档,例如:<code>texdoc xeCJK</code> 。</p>
<h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><p>pdf</p>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.sty</code></td>
<td>宏包文件。</td>
</tr>
<tr>
<td align="center"><code>.cls</code></td>
<td>文档类文件。</td>
</tr>
<tr>
<td align="center"><code>.aux</code></td>
<td>用于存储交叉引用信息的文件,因此,在更新交叉引用(公式编号、大纲级别)后,需要编译两次才能正常显示。</td>
</tr>
<tr>
<td align="center"><code>.log</code></td>
<td>日志,记录上次编译的信息。</td>
</tr>
<tr>
<td align="center"><code>.toc</code></td>
<td>目录文件。</td>
</tr>
<tr>
<td align="center"><code>.lof</code></td>
<td>图形目录。</td>
</tr>
<tr>
<td align="center"><code>.lot</code></td>
<td>表格目录。</td>
</tr>
<tr>
<td align="center"><code>.idx</code></td>
<td>如果文档中包含索引,该文件用于存储索引信息。</td>
</tr>
<tr>
<td align="center"><code>.ind</code></td>
<td>索引记录文件。</td>
</tr>
<tr>
<td align="center"><code>.ilg</code></td>
<td>索引日志文件。</td>
</tr>
<tr>
<td align="center"><code>.bib</code></td>
<td>参考文献数据文件。</td>
</tr>
<tr>
<td align="center"><code>.bbl</code></td>
<td>生成的参考文献记录。</td>
</tr>
<tr>
<td align="center"><code>.bst</code></td>
<td>模板。</td>
</tr>
<tr>
<td align="center"><code>.blg</code></td>
<td>日志。</td>
</tr>
<tr>
<td align="center"><code>.out</code></td>
<td>hyperref 宏包生成的 pdf 书签记录。</td>
</tr>
</tbody></table>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>删除文件夹下除了 tex 以外的文件再编译</p>
<p><strong>注意</strong></p>
<p>在某些独占程序打开了以上的文件时(比如用Acrobat 打开了 pdf 文件),编译也可能出现错误。请在编译时确保关闭这些独占程序。</p>
<h3 id="标点与强调"><a href="#标点与强调" class="headerlink" title="标点与强调"></a>标点与强调</h3><p>英文符号 <code>|、&lt;、&gt;、+、=</code> 一般用于数学环境</p>
<ul>
<li>在文本中使用,请在它们两侧加上 <code>$</code></li>
<li>大于小于号：你应该使用 <code>\textgreater</code> 、<code>\textless</code> 命令</li>
</ul>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><ul>
<li>左单引号是重音符 `</li>
<li>右单引号是常用的引号符</li>
<li>左双引号就是连续两个重音符</li>
<li>英文下的引号嵌套需要借助 <code>\thinspace</code> 命令分隔</li>
</ul>
<h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h3><p>英文的省略号使用  <code>\ldots</code> 这个命令</p>
<h3 id="强调-粗与斜"><a href="#强调-粗与斜" class="headerlink" title="强调:粗与斜"></a>强调:粗与斜</h3><p><code>\emph&#123;text&#125;</code></p>
<ul>
<li>中文：强调文本</li>
<li>细纹：斜体</li>
</ul>
<h3 id="下划线与删除线"><a href="#下划线与删除线" class="headerlink" title="下划线与删除线"></a>下划线与删除线</h3><ul>
<li>LaTeX 原生提供的 <del>\underline</del> 命令简直烂得可以</li>
<li>&#x3D;&#x3D;建议&#x3D;&#x3D;你使用 ulem 宏包下的 uline 命令,它还支持换行文本</li>
</ul>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\uline&#123;&#125;</code></td>
<td>下划线</td>
</tr>
<tr>
<td align="left"><code>\uuline&#123;&#125;</code></td>
<td>双下划线</td>
</tr>
<tr>
<td align="left"><code>\dashuline&#123;&#125;</code></td>
<td>虚下划线</td>
</tr>
<tr>
<td align="left"><code>\dotuline&#123;&#125;</code></td>
<td>点下划线</td>
</tr>
<tr>
<td align="left"><code>\uwave&#123;&#125;</code></td>
<td>波浪线</td>
</tr>
<tr>
<td align="left"><code>\sout&#123;&#125;</code></td>
<td>删除线</td>
</tr>
<tr>
<td align="left"><code>\xout&#123;&#125;</code></td>
<td>斜删除线</td>
</tr>
</tbody></table>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>ulem 宏包重定义了 <code>\emph</code> 命令：</p>
<ul>
<li><p>强调命令会对内容加下划线</p>
</li>
<li><p>嵌套使用两次强调命令则会对内容加双下划线</p>
</li>
</ul>
<p>通过宏包的 normalem 选项可以取消这个更改:<code>\usepackage[normalem]&#123;ulem&#125;</code></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>角度符号或者温度符号</li>
<li>欧元符号可能需要用到 textcomp 宏包支持的 \texteuro 命令</li>
<li>千位分隔位<ul>
<li>不想它在中间断行,就在外侧再加上一个 \mbox 命令</li>
</ul>
</li>
<li>注音符号</li>
<li>音标：<ul>
<li>tipa 宏包</li>
<li>numprint 宏包</li>
<li>siunitx 宏包</li>
</ul>
</li>
<li>hologo 宏包可以输出许多TEX 家族标志</li>
</ul>
<h2 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h2><h3 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h3><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pt</td>
<td>point,磅。</td>
</tr>
<tr>
<td>pc</td>
<td>pica,1 pc &#x3D; 12 pt,四号字。</td>
</tr>
<tr>
<td>in</td>
<td>inch,英寸,1 in &#x3D; 72.27 pt。</td>
</tr>
<tr>
<td>bp</td>
<td>bigpoint,大点,1 bp &#x3D;  in。</td>
</tr>
<tr>
<td>cm</td>
<td>centimeter,厘米,1 cm &#x3D;  in。</td>
</tr>
<tr>
<td>mm</td>
<td>millimeter,毫米,1 mm &#x3D;  cm。</td>
</tr>
<tr>
<td>sp</td>
<td>scaled point,TEX 的基本长度单位,1 sp &#x3D;  pt。</td>
</tr>
<tr>
<td>em</td>
<td>当前字号下,大写字母M的宽度。</td>
</tr>
<tr>
<td>ex</td>
<td>当前字号下,小写字母x的高度。</td>
</tr>
</tbody></table>
<h3 id="长度宏"><a href="#长度宏" class="headerlink" title="长度宏"></a>长度宏</h3><table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\textwidth</code></td>
<td>页面上文字的总宽度，即叶宽减去两侧边距</td>
</tr>
<tr>
<td><code>\linewidth</code></td>
<td>当前行允许的行宽</td>
</tr>
</tbody></table>
<h4 id="可变长度"><a href="#可变长度" class="headerlink" title="可变长度"></a>可变长度</h4><ul>
<li><code>5 pt plus 3 pt minus 2 pt</code>：表示一个能收缩到 3 pt 也能伸长到 8 pt 的长度</li>
<li>直接使用倍数：<code>1.5\parindent</code></li>
</ul>
<h4 id="特殊空格"><a href="#特殊空格" class="headerlink" title="特殊空格"></a>特殊空格</h4><p><code>\hspace</code> 和 <code>\vspace</code></p>
<h3 id="空格与换行"><a href="#空格与换行" class="headerlink" title="空格与换行"></a>空格与换行</h3><ul>
<li>多个空格、换行会被视为一个</li>
<li>禁止 LaTeX 在某个空格处的换行,将空格用 <code>˜</code> 命令替代即可,比如: <code>Fig.˜ 8</code></li>
</ul>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><ul>
<li>会自动换行</li>
<li>分段：两个回车 （用于正文换行）</li>
<li>空白段落（空白行）<ul>
<li>两个回车 + <code>\mbox&#123;&#125;</code> + 两个回车</li>
<li><code>\par</code>： 生成一个带缩进的新段</li>
</ul>
</li>
<li>强制换行： <code>\\</code><ul>
<li>缺点：下一行段首缩进会消失</li>
</ul>
</li>
</ul>
<h4 id="段落间距离"><a href="#段落间距离" class="headerlink" title="段落间距离"></a>段落间距离</h4><ul>
<li>默认： <code>0pt plus 1pt</code></li>
<li>控制命令 <code>\parskip</code>： <code>\setlength&#123;\parskip&#125;&#123;0pt plus 1pt&#125;</code></li>
<li>首字下沉：lettrine 宏包</li>
</ul>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ul>
<li><code>\newpage</code> 命令开始新的一页</li>
<li>用 <code>\clearpage</code> 命令清空浮动体队列，并开始新的一页</li>
<li>用  <code>\cleardoublepage</code> 命令清空浮动体队列,并在偶数页开始新的一页</li>
<li>连续新开两页：在 <code>\newpage </code>中间加上一个空的箱子(<code>\mbox&#123;&#125;</code>)，<code>\newpage\mbox&#123;&#125;\newpage</code></li>
</ul>
<h3 id="缩进、对齐与行距"><a href="#缩进、对齐与行距" class="headerlink" title="缩进、对齐与行距"></a>缩进、对齐与行距</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><ul>
<li>宏包：借助 indentfirst 宏包</li>
<li>设置距离：使用 <code>\setlength\parindent&#123;2em&#125;</code> 这样的命令来设置缩进距离</li>
<li>段首强制取消缩进：在段首使用 <code>\noindent</code> 命令</li>
</ul>
<p><strong>注</strong></p>
<p>英文的每节第一段的段首&#x3D;&#x3D;允许没有缩进&#x3D;&#x3D;</p>
<h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><p>默认使用两端对齐的排版方式</p>
<p><strong>设置</strong></p>
<p>可以使用 flushleft 、flushright 、center 这三种环境来构造居左、居中、居右三种效果。</p>
<p>特殊的 \centering 命令常常用在环境内部(或者一对花括号内部),以实现居中的效果。</p>
<p>尽量用 center 环境代替这个老旧的命令。类似地还有 \raggedleft 实现居右, \raggedright 实现居左</p>
<h2 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h2><h3 id="中西文“斜体”"><a href="#中西文“斜体”" class="headerlink" title="中西文“斜体”"></a>中西文“斜体”</h3><h4 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h4><p>汉字没有加斜体</p>
<p>汉字字体里面也不一定有加粗体的设计</p>
<p><strong>英文</strong></p>
<ul>
<li>加斜是指某种字族的 Italy 字系</li>
<li>斜体,是指 Slant 字族</li>
</ul>
<p><strong>使用</strong></p>
<ul>
<li>行文中表强调时使用的是前者;</li>
<li>在 MS Word 等软件中看到的倾斜字母 I ,也代表前者。</li>
</ul>
<h3 id="原生字体命令"><a href="#原生字体命令" class="headerlink" title="原生字体命令"></a>原生字体命令</h3><h4 id="字族"><a href="#字族" class="headerlink" title="字族"></a>字族</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\rmfamily</code></td>
<td>把字体设置为 Roman 罗马字族</td>
</tr>
<tr>
<td><code>\sffamily</code></td>
<td>把字体设置为 Sans Serif 无衬线字族</td>
</tr>
<tr>
<td><code>\ttfamily</code></td>
<td>把字体设置为 Typewritter 等宽字族</td>
</tr>
</tbody></table>
<h4 id="字系"><a href="#字系" class="headerlink" title="字系"></a>字系</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\bfseries</code></td>
<td>粗体 BoldSeries 字系属性</td>
</tr>
<tr>
<td><code>\mdseries</code></td>
<td>中粗体 MiddleSerie 字系属性</td>
</tr>
</tbody></table>
<h4 id="字形"><a href="#字形" class="headerlink" title="字形"></a>字形</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\upshape</code></td>
<td>竖直字形</td>
</tr>
<tr>
<td><code>\slshape</code></td>
<td>斜体字形</td>
</tr>
<tr>
<td><code>\itshape</code></td>
<td>强调体字形</td>
</tr>
<tr>
<td><code>\scshape</code></td>
<td>小号大写字形</td>
</tr>
</tbody></table>
<h4 id="临时改变字体"><a href="#临时改变字体" class="headerlink" title="临时改变字体"></a>临时改变字体</h4><p>临时改变字体,使用 <code>\textrm</code> 、<code>\textbf</code> 这类命令</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul>
<li><p>字族、字系、字形三种命令是互相独立的,可以任意组合使用</p>
</li>
<li><p>这种复合字体的效果有时候无法达到(因为没有对应的设计)</p>
<p> LaTeX 会针对这种情况给出警告,但仍可以编译,只是效果达不到预期。</p>
</li>
</ul>
<h4 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h4><p>在文中多次使用某种字体变换,可以将其自定义成一个命令</p>
<h4 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h4><p><strong>默认的“标准”字号</strong></p>
<ul>
<li>在documentclass 的选项中设置的 12 pt(如果你设置了的话)</li>
</ul>
<p><strong>相对字号命令</strong></p>
<img data-src="/2023/06/03/152/image-20230603113331305.png" class="" title="image-20230603113331305">



<p><strong>ctex 宏包</strong></p>
<p>ctex 宏包的 <code>\zihao</code> 命令的参数 0<del>8 以及 -0</del>-8 表示初号到八号、小初号到小八号</p>
<blockquote>
<p>日常使用的小四号为 12 pt,五号为 10.5 pt</p>
</blockquote>
<p><strong>设置特殊的字号</strong></p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\fontsize</span>&#123;font-size&#125;&#123;line-height&#125;&#123;<span class="keyword">\selectfont</span> &lt;text&gt;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>font-size: 填数字，单位pt</li>
<li>line-height: 填 <code>\baselineskip</code>，表示行与行之间的基线间距(即行距),默认是 1.2 倍文字高。</li>
</ul>
<h4 id="默认字体"><a href="#默认字体" class="headerlink" title="默认字体"></a>默认字体</h4><p>全文的默认字体使用 <code>\rmfamily</code> 族的字体</p>
<p>通过重定义的方式更改它,使 <code>\rmfamily</code> 、<code>\textrm</code> 命令都指向新的字体,甚至把默认字体改为 <code>sf/tt</code> 字族</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\rmdefault</span>&#125;&#123;font-name&#125;</span><br><span class="line"><span class="comment">% 默认字体改为sf字族，也可以用 \ttdefault</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\familydefault</span>&#125;&#123;<span class="keyword">\sfdefault</span>&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\sfdefault</span>&#125;&#123;font-name&#125;</span><br><span class="line"><span class="comment">% 如果你排版 CJK文档，还需要更改CJK的默认字体</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\CJKfamilydefault</span>&#125;&#123;<span class="keyword">\CJKsfdefault</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="西文字体"><a href="#西文字体" class="headerlink" title="西文字体"></a>西文字体</h3><h4 id="预包含西文字体"><a href="#预包含西文字体" class="headerlink" title="预包含西文字体"></a>预包含西文字体</h4><img data-src="/2023/06/03/152/image-20230603113310227.png" class="" title="image-20230603113310227">

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>引言区定义</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\myfont</span>&#125;[2]&#123;&#123;<span class="keyword">\fontfamily</span>&#123;<span class="params">#1</span>&#125;<span class="keyword">\selectfont</span> <span class="params">#2</span>&#125;&#125;</span><br><span class="line"><span class="comment">% 可更改默认字体，同理可改 sfdefault</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\rmdefault</span>&#125;&#123;ptm&#125;</span><br></pre></td></tr></table></figure>



<p><strong>正文中</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Let&#x27;s change font to <span class="keyword">\myfont</span>&#123;ppl&#125;&#123;Palatino&#125;!</span><br></pre></td></tr></table></figure>



<h3 id="本地安装字体"><a href="#本地安装字体" class="headerlink" title="本地安装字体"></a>本地安装字体</h3><h4 id="使用-fontspec-宏包"><a href="#使用-fontspec-宏包" class="headerlink" title="使用 fontspec 宏包"></a>使用 fontspec 宏包</h4><p>一般使用 fontspec 宏包来选择本地安装 的字体。注意,该宏包可能会明显增加编译时间</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;fontspec&#125;</span><br><span class="line">	<span class="keyword">\newfontfamily</span>&#123;<span class="keyword">\lucida</span>&#125;&#123;Lucida Calligraphy&#125;</span><br><span class="line">	<span class="keyword">\lucida</span>&#123;This is Lucida Calligraphy&#125;</span><br></pre></td></tr></table></figure>

<p>该宏包的 <code>\setmathrm/sf/tt</code> 与 <code>\setboldmathrm</code> 命令可以更改数学环境中调用的字体。</p>
<h4 id="简单加载-txtfont-宏包"><a href="#简单加载-txtfont-宏包" class="headerlink" title="简单加载 txtfont 宏包"></a>简单加载 txtfont 宏包</h4><p>将西文字体设置为Roman 体,同时设置好数学字体。</p>
<p>简单字体宏包还有cmbright ,以及提供 Palatino 字体的 pxfonts ,前者提供的 CM Bright 与 TeX 默认字体 Computer Modern 协调得不错</p>
<h3 id="中文支持与CJK字体"><a href="#中文支持与CJK字体" class="headerlink" title="中文支持与CJK字体"></a>中文支持与CJK字体</h3><h4 id="ctex-宏包"><a href="#ctex-宏包" class="headerlink" title="ctex 宏包"></a>ctex 宏包</h4><p>直接定义了新的中文文档类 ctexart 、ctexrep 与 ctexbook ,以及 ctexbeamer 幻灯文档类。</p>
<h4 id="xeCJK-宏包"><a href="#xeCJK-宏包" class="headerlink" title="xeCJK 宏包"></a>xeCJK 宏包</h4><p>在使用 时,如果你使用 ctex 文档类,它会在底层调用 xeCJK 宏包,所以你无须再显式地加载它。当然你也可以使用原生文档类,然后逐一汉化参数内容。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在引言区</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackege</span>[slantfont,boldfont]&#123;xeCJK&#125;</span><br><span class="line">	<span class="keyword">\xeCJKsetup</span>&#123;CJKMath=true&#125;</span><br><span class="line">	<span class="keyword">\setCJKmainfont</span>[BoldFont=SimHei]&#123;Simsun&#125;</span><br></pre></td></tr></table></figure>



<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>使用 xcolor 宏包</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;</span><br><span class="line">	<span class="keyword">\definecolor</span>&#123;keywordcolor&#125;&#123;RGB&#125;&#123;34,34,250&#125;</span><br></pre></td></tr></table></figure>



<h4 id="指定颜色的text"><a href="#指定颜色的text" class="headerlink" title="指定颜色的text"></a>指定颜色的text</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">\color</span>&#123;color-name&#125;&#123;text&#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 70%红色</span></span><br><span class="line">&#123;<span class="keyword">\textcolor</span>&#123;red!70&#125;&#125;</span><br><span class="line"><span class="comment">% 50蓝，20黑，30白</span></span><br><span class="line">&#123;<span class="keyword">\textcolor</span>&#123;blue!50!black!20!white!30!&#125;&#123;50蓝，20黑，30白&#125;&#125;</span><br><span class="line"><span class="comment">% 黄色互补色</span></span><br><span class="line">&#123;<span class="keyword">\textcolor</span>&#123;-yellow&#125;&#123;黄色互补色&#125;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用与注释"><a href="#引用与注释" class="headerlink" title="引用与注释"></a>引用与注释</h2><h3 id="标签与引用"><a href="#标签与引用" class="headerlink" title="标签与引用"></a>标签与引用</h3><p>没看懂</p>
<h3 id="脚注、边注和尾注"><a href="#脚注、边注和尾注" class="headerlink" title="脚注、边注和尾注"></a>脚注、边注和尾注</h3><p>没看懂</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>没看懂</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>natbib 宏包</p>
<h2 id="正式排版-封面、大纲与目录"><a href="#正式排版-封面、大纲与目录" class="headerlink" title="正式排版:封面、大纲与目录"></a>正式排版:封面、大纲与目录</h2><h3 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h3><p>封面的内容在导言区进行定义,&#x3D;&#x3D;一般写在所有宏包、自定义命令之后&#x3D;&#x3D;</p>
<p>命令如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;Learning Latex&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Qeuroal</span><br><span class="line"><span class="keyword">\date</span>&#123;text&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用封面"><a href="#使用封面" class="headerlink" title="使用封面"></a>使用封面</h4><p>document 环境内的第一行写上 \maketitle ,这样就能产生一个简易的封面。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>标题页的脚注用 <code>\thanks</code> 命令完成。</p>
<p><strong>注意</strong></p>
<ul>
<li>\title 和 \author &#x3D;&#x3D;是必须定义的&#x3D;&#x3D;</li>
<li>date<ul>
<li>\date 如果省略：会自动以编译当天的日期为准,格式形如: January 1, 1970。</li>
<li>不想显示日期,可以写 \date{}</li>
</ul>
</li>
</ul>
<h3 id="大纲与章节"><a href="#大纲与章节" class="headerlink" title="大纲与章节"></a>大纲与章节</h3><table>
<thead>
<tr>
<th>命令</th>
<th>大纲级别</th>
</tr>
</thead>
<tbody><tr>
<td><code>\part</code></td>
<td>部分,这个大纲不会打断 chapter 的编号。</td>
</tr>
<tr>
<td><code>\chapter</code></td>
<td>章,article 的文档类不包含本大纲级别。</td>
</tr>
<tr>
<td><code>\section</code></td>
<td>节。</td>
</tr>
<tr>
<td><code>\subsection</code></td>
<td>次节,默认 report&#x2F;book 文档类中本级别及以下的大纲不进行编号,也不纳入目录。</td>
</tr>
<tr>
<td><code>\subsubsection</code></td>
<td>小节,默认 article 文档类中本级别及以下的大纲不进行编号,也不纳入目录。</td>
</tr>
<tr>
<td><code>\paragraph</code></td>
<td>段,极少使用。</td>
</tr>
<tr>
<td><code>\subparagraph</code></td>
<td>次段,极少使用。</td>
</tr>
</tbody></table>
<h2 id="计数器与列表"><a href="#计数器与列表" class="headerlink" title="计数器与列表"></a>计数器与列表</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>LaTeX 中的自动编号都借助内部的计数器来完成，计数器包括下面几种：</p>
<ul>
<li>章节 :part、chapter、section、subsection、subsubsection、paragraph 与 subparagraph。</li>
<li>编号列表 :enumi、enumii、enumiii 与 enumiv。</li>
<li>公式和图表 :equation、figure 与 table。</li>
<li>其他 :page、footnote 与 mpfootnote</li>
</ul>
<p><strong>注</strong></p>
<ul>
<li>mpfootnote 命令用于实现 minipage 环境的脚注</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>通过 \the 接上计数器名称来调用计数器,比如 \thechapter</p>
<p>如果只是输出计数器的数值,可以指定数值的形式,如阿拉伯数字、大小写英文字母,或大小写罗马数字。</p>
<p>常用的命令：</p>
<ul>
<li>\arabic{counter-name}</li>
<li>\Alph</li>
<li>\alph</li>
<li>\Roman</li>
<li>\roman</li>
<li>% ctex文档类还支持\chinese</li>
</ul>
<h2 id="图、表格"><a href="#图、表格" class="headerlink" title="图、表格"></a>图、表格</h2><p>没看懂</p>
<h2 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h2><p>借助 geometry 宏包</p>
<img data-src="/2023/06/03/152/image-20230603153439184.png" class="" title="image-20230603153439184">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/06/02/151/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/02/151/" class="post-title-link" itemprop="url">151. Java relative</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-02T00:00:00+08:00">2023-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="优秀的讲解"><a href="#优秀的讲解" class="headerlink" title="优秀的讲解"></a>优秀的讲解</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="表述"><a href="#表述" class="headerlink" title="表述"></a>表述</h3><p>类描述了一系列具有相同特征(即数据元素)和行为(即功能方法)的对象<br>一个上佳的方法是将对象想象成“服务提供者” 。你的程序本身也是为用户提供服务的,它通过使用其他对象提供的服务来做到这一点。所以,你的任务是创建(更好的情况是,从已有的库中找到)一些提供对应服务以解决问题的对象。</p>
<h3 id="内存方面"><a href="#内存方面" class="headerlink" title="内存方面"></a>内存方面</h3><p>创建一个类即描述了其对象的外观和行为。直到使用 new 关键字时,你才会真正创建一个对象,以及为该对象分配内存,并使得其方法可以被调用。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>调用方法的行为被描述为 “&#x3D;&#x3D;向一个对象发送一条消息&#x3D;&#x3D;”，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.f();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>f()</code> 代表消息</p>
</li>
<li><p><code>a</code> 代表对象</p>
</li>
</ul>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>面向对象编程描述为“&#x3D;&#x3D;向对象发送消息&#x3D;&#x3D;”</p>
<h1 id="接口与类的关系"><a href="#接口与类的关系" class="headerlink" title="接口与类的关系"></a>接口与类的关系</h1><p>是抽象与更抽象的关系。</p>
<p>比如，定义人这个类，但是在人之外还有各种动物，或者说，人就是高级动物。但是有一个问题是，人有学历之类的属性，而其他动物一定要有学历这一属性吗？答案是否。人有自己的行为动作，那么其他动物是否也有相同或者类似的行为动作呢？答案是是的。那么我们是不是就可以设计一个动物类，而不添加任何属性呢？那么这个类就可以称作接口了。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用的作用是关联对象。</p>
<p>引用未必会关联某个对象，如：<code>String s</code></p>
<h2 id="引用的个人理解"><a href="#引用的个人理解" class="headerlink" title="引用的个人理解"></a>引用的个人理解</h2><p>引用就是一个地址或者指针，通过地址来操作相关对象</p>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>使用 <code>new</code> 关键字来创建对象: 我要一个这种类型的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String9</span>(<span class="string">&quot;asdf&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>放置对象的数组：初始化为 <code>null</code></li>
<li>放置基本类型的数组：初始化为 <code>0</code></li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><table>
<thead>
<tr>
<th>基本类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>\u0000(null)</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>引用</td>
<td>null<br/>调用引用的方法会&#x3D;&#x3D;得到异常&#x3D;&#x3D;，但仍然可以打印一个 null 引用而不会抛出异常</td>
</tr>
</tbody></table>
<h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><ol>
<li>自动初始化</li>
<li>构造初始化</li>
</ol>
<h2 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h2><ul>
<li>字段是基本类型：基本类型的标准初始值</li>
<li>字段是对象引用：默认初始值为 null</li>
</ul>
<h2 id="初始化引用"><a href="#初始化引用" class="headerlink" title="初始化引用"></a>初始化引用</h2><ol>
<li>在定义对象时。这意味着它们将始终在调用构造器之前被初始化。</li>
<li>在该类的构造器中。</li>
<li>在对象实际使用之前。这通常称为延迟初始化(lazy initialization) 。在对象创建成本高昂且不需要每次都创建的情况下,它可以减少开销。</li>
<li>使用实例初始化</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reuse/Bath.java</span></span><br><span class="line"><span class="comment">// 使用组合进行构造器初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    Soap() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Soap()&quot;</span>);</span><br><span class="line">        s = <span class="string">&quot;Constructed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bath</span> &#123;</span><br><span class="line">    <span class="comment">// 在定义时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Happy&quot;</span>, s2 = <span class="string">&quot;Happy&quot;</span>, s3, s4;</span><br><span class="line">    <span class="keyword">private</span> Soap castile;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> toy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bath</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Bath()&quot;</span>);</span><br><span class="line">        <span class="comment">// 构造初始化</span></span><br><span class="line">        s3 = <span class="string">&quot;Joy&quot;</span>;</span><br><span class="line">        toy = <span class="number">3.14f</span>;</span><br><span class="line">        castile = <span class="keyword">new</span> <span class="title class_">Soap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例初始化 </span></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 延迟初始化</span></span><br><span class="line">        <span class="keyword">if</span> (s4 == <span class="literal">null</span>)</span><br><span class="line">            s4 = <span class="string">&quot;Joy&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;s1 = &quot;</span> + s1 + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;s2 = &quot;</span> + s2 + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;s3 = &quot;</span> + s3 + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;s4 = &quot;</span> + s4 + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;\n&quot;</span></span><br><span class="line">                + <span class="string">&quot;toy = &quot;</span> + toy + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;castile = &quot;</span> + castile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bath</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bath</span>();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="与C不同点"><a href="#与C不同点" class="headerlink" title="与C不同点"></a>与C不同点</h1><h2 id="同名变量"><a href="#同名变量" class="headerlink" title="同名变量"></a>同名变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">96</span>; <span class="comment">// 语法错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 编译器会提示说,变量 x 已经定义过了。</p>
<p>&#x3D;&#x3D;类似 C 和 C++ 那样在外围的作用域中“隐藏”变量的方式在 Java 中是不被允许的&#x3D;&#x3D;</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>文件中必须存在一个与该文件同名的类(如果你没有这么做,则编译器会报错)</li>
</ul>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>如果你需要创建一个能够独立运行的程序,那么与文件同名的类中还必须包含一个程序启动的入口方法。这个特殊的方法叫作 main(),具有以下的格式和返回值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure>



<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol>
<li><code>javac &lt;filename&gt;.java</code></li>
<li><code>java &lt;filename&gt;</code></li>
</ol>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>基本类型存储了实际的值，而非只想一个对象的引用，所以在为其赋值的时候，你直接将一个地方的&#x3D;&#x3D;内容复制到了另一个地方&#x3D;&#x3D;。</p>
<h3 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>当操作一个对象的时候，我们&#x3D;&#x3D;真正操作的是这个对象的引用&#x3D;&#x3D;。当“将一个对象赋值给另一个对象”时，你是将这个引用从一个地方复制到了另一个地方。这意味着对对对象而言，将两个变量同时指向同一个对象。</p>
<h3 id="方法调用中的别名"><a href="#方法调用中的别名" class="headerlink" title="方法调用中的别名"></a>方法调用中的别名</h3><p>将一个对象作为参数传递给方法时,也会产生别名</p>
<h2 id="格式化处理"><a href="#格式化处理" class="headerlink" title="格式化处理"></a>格式化处理</h2><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>%n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>表示以科学记数法显示结果</td>
</tr>
</tbody></table>
<h2 id="整数值对象"><a href="#整数值对象" class="headerlink" title="整数值对象"></a>整数值对象</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><ul>
<li><p>自动转化为 <code>Integer</code></p>
<p> 通过对 <code>Integer.valueOf()</code> 的&#x3D;&#x3D;自动调用&#x3D;&#x3D;来完成的</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> value;</span><br></pre></td></tr></table></figure>

</li>
<li><p>使用标准的对象创建语法 <code>new</code>。 这是以前创建 “包装&#x2F;装箱” Integer 对象的首选方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(value);</span><br></pre></td></tr></table></figure>

</li>
<li><p>从 Java 9 开始,valueOf() 优于 [2]。如果尝试在 Java 9 中使用方式 [2],你将收到警告,并被建议使用 [3] 代替。很难确定 [3] 是否的确优于 [1],不过 [1] 看起来更简洁</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> Integer.valueOf(value);</span><br></pre></td></tr></table></figure>

</li>
<li><p>基本类型 int 也可以当作整数值对象使用</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="equal"><a href="#equal" class="headerlink" title="equal()"></a>equal()</h2><ul>
<li><code>equals()</code> 方法的默认行为是比较引用。</li>
<li>如果只想比较内容,你必须重写 <code>equals()</code> 方法</li>
<li>大多数标准库会重写 <code>equals()</code> 方法来比较对象的内容而不是它们的引用</li>
</ul>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><ul>
<li>把 int 类型当作 boolean 类型并&#x3D;&#x3D;不合法&#x3D;&#x3D;</li>
<li>如果在应该使用字符串的地方使用了布尔值,布尔值会自动转换成合适的文本格式</li>
<li>boolean 类型是有限制的：<ul>
<li>我们只能赋予它 true 和 false 值,并测试它是真还是假</li>
<li>不能将 boolean 值相加,或对 boolean 值执行其他任何运算</li>
</ul>
</li>
</ul>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><ul>
<li><p>大写(或小写)的字符 L 表示 long 类型(不过使用小写的 l 容易让人迷惑,因为它看起来就像数字 1) </p>
</li>
<li><p>大写(或小写)的字符 F 表示 float 类型</p>
</li>
<li><p>大写(或小写)的字符 D 表示 double 类型</p>
</li>
<li><p>Java 7 引入了&#x3D;&#x3D;二进制字面量&#x3D;&#x3D;,通过前缀 <code>0b</code> 或 <code>0B</code> 来表示,它适用于所有整数类型。</p>
</li>
<li><p>可以在数字字面量里使用下划线,这样更易于阅读</p>
<p> 如：<code>341_435_936.445_667</code></p>
<p> 规则:</p>
<ul>
<li>只能使用单个下划线,不能连续使用多个; </li>
<li>数字的开头或结尾不能有下划线; </li>
<li>像 <code>F</code>、<code>D</code> 或 <code>L</code> 这样的后缀周围不能有下划线; </li>
<li>在二进制或十六进制标识符 <code>b</code> 和 <code>x</code> 的周围不能有下划线。</li>
</ul>
</li>
<li><p><code>e</code> 表示 “10 的幂次”</p>
<p> <code>e</code> 大小写都可以,含义相同</p>
</li>
<li><p>编译器一般会将指数作为 double 类型处理,所以如果没有尾部的 f, 我们会收到一条出错提示, 告诉我们必须将 double 类型转换成 float 类型</p>
</li>
</ul>
<h2 id="布尔类型位运算"><a href="#布尔类型位运算" class="headerlink" title="布尔类型位运算"></a>布尔类型位运算</h2><ul>
<li>可以对它执行按位“与” 、按位“或”和按位“异或”运算,但&#x3D;&#x3D;不能执行按位“非”&#x3D;&#x3D;</li>
<li>对于布尔值,按位操作符和逻辑操作符具有相同的效果,但它们&#x3D;&#x3D;不会“短路”&#x3D;&#x3D;</li>
<li>针对布尔值的按位运算还比逻辑操作符多了一个“异或”运算</li>
</ul>
<h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><ul>
<li>移位操作符也操纵二进制位,它们&#x3D;&#x3D;只能用来处理基本类型里的整数类型&#x3D;&#x3D;。</li>
<li>左移位操作符(&#x3D;&#x3D;&lt;&lt;&#x3D;&#x3D;)会将操作符左侧的操作数向左移动,移动的位数在操作符右侧指定(&#x3D;&#x3D;低位补 0&#x3D;&#x3D;)</li>
<li>“有符号”的右移位操作符(&#x3D;&#x3D;&gt;&gt;&#x3D;&#x3D;)则按照操作符右侧指定的位数将操作符左侧的操作数向右移动。“有符号”的右移位操作符使用了“符号扩展” :<ul>
<li>如果符号为正,则在&#x3D;&#x3D;高位插入 0&#x3D;&#x3D;</li>
<li>否则在&#x3D;&#x3D;高位插入 1&#x3D;&#x3D;</li>
</ul>
</li>
<li>种“无符号”的右移位操作符(&#x3D;&#x3D;&gt;&gt;&gt;&#x3D;&#x3D;) ,它使用“零扩展”: 无论符号为正还是为负,都在&#x3D;&#x3D;高位插入 0&#x3D;&#x3D;</li>
<li>无符号”右移位操作符结合赋值操作符可能会遇到一个问题:如果对 byte 或 short 值进行移位运算,得到的可能不是正确的结果。它们会先被提升为 int 类型,进行右移操作,然后在被赋回给原来的变量时&#x3D;&#x3D;被截断&#x3D;&#x3D;, 这时得到&#x3D;&#x3D;结果是 -1&#x3D;&#x3D;</li>
</ul>
<h2 id="字符串操作符-和"><a href="#字符串操作符-和" class="headerlink" title="字符串操作符 + 和 +&#x3D;"></a>字符串操作符 + 和 +&#x3D;</h2><p>如果表达式以一个字符串开头,则其后的所有操作数都必须是字符串类型的(编译器会自动把双引号里的字符序列转换成字符串)</p>
<p>字符串转换并不取决于先后顺序</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>Java 中无法自动将 int 类型转为 boolean 类型</p>
<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>既可以对数值进行类型转换, 也可以对变量进行类型转换</p>
<blockquote>
<p>窄化转型</p>
</blockquote>
<p>有可能面临信息丢失的危险。窄化转型就是说,将能容纳更多信息的数据类型&#x3D;&#x3D;转换成无法容纳那么多信息的数据类型&#x3D;&#x3D;。此时,编译器会要求我们进行强制类型转换,意在提醒我们: “这可能是一个危险的操作,如果的确要这么做,你必须显式地进行类型转换。”</p>
<blockquote>
<p>宽化转型</p>
</blockquote>
<p>不必显式地进行类型转换, 因为新类型可以容纳比原来的类型更多的信息, 而不会造成任何信息的丢失</p>
<blockquote>
<p>截尾与舍入</p>
</blockquote>
<p>在执行窄化转型时，会出现截尾与舍入</p>
<p><strong>处理</strong></p>
<ul>
<li><p>float 或 double 转型为整型值时: 截尾</p>
<p> java.lang.Math 中的 <code>round()</code>: 舍入</p>
</li>
</ul>
<blockquote>
<p>提升</p>
</blockquote>
<ul>
<li>如果对小于 int 类型的基本数据类型(即 char、byte 或者 short)执行算术运算或按位运算,运算执行前这些值就会被自动提升为 int,结果也是 int 类型。</li>
<li>如果要把结果赋值给较小的类型,就&#x3D;&#x3D;必须使用强制类型转换&#x3D;&#x3D;(由于把值赋给了较小的类型,可能会出现信息丢失) 。</li>
<li>表达式里出现的最大的数据类型决定了表达式最终结果的数据类型</li>
</ul>
<h3 id="不允许转换"><a href="#不允许转换" class="headerlink" title="不允许转换"></a>不允许转换</h3><ul>
<li><p>boolean</p>
<p> Java 可以把任何基本类型转换成别的基本类型,但 boolean 除外,它不允许进行任何类型的转换处理。</p>
</li>
<li><p>“类”类型(class type)也不允许进行类型转换</p>
<p> 将一种类型转换成另一种类型需要采用特殊的方法：对象可以在它的类型所属族群里进行类型转换，但不能把它转换成外部的类型。</p>
</li>
</ul>
<h2 id="Java-没有-sizeof"><a href="#Java-没有-sizeof" class="headerlink" title="Java 没有 sizeof()"></a>Java 没有 sizeof()</h2><p>略</p>
<h2 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h2><p>逗号操作符不是 &#x3D;&#x3D;逗号分隔符&#x3D;&#x3D;</p>
<ul>
<li><p>逗号分隔符：分割生命和函数的不同参数</p>
</li>
<li><p>逗号操作符：Java 里&#x3D;&#x3D;唯一&#x3D;&#x3D;用到逗号操作符的地方就是 for 循环的控制表达式。</p>
<ul>
<li>使用地方：初始化和步进部分，这些语句会按先后顺序执行</li>
<li>注意：可以在for语句里定义多个变量，但它们必须是 &#x3D;&#x3D;相同的类型&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>用于数组和容器，也叫做 foreach 语法或 for-in 语法</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>for-in 会&#x3D;&#x3D;自动为你生成每一项元素&#x3D;&#x3D;，这样你就不需要创建 int 变量来对这个元素构成的序列进行计数。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>任何反悔了数组的方法都可以使用 for-in</p>
<h4 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h4><p>range() 方法可以让我们在更多的地方使用 for-in 语法，从而提高了可读性</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不仅方便代码的编写,更重要的是让代码更容易阅读,它表明了你打算做什么(获取数组中的每一个元素) , 作者更提倡使用 for-in 语法</p>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><ul>
<li><code>for(;;)</code></li>
<li><code>while(true)</code></li>
</ul>
<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>Java中没有goto</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>与goto使用了相同的机制</p>
<h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>标签是以冒号结尾的标识符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br></pre></td></tr></table></figure>



<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>在 Java 中,放置标签的&#x3D;&#x3D;唯一地方&#x3D;&#x3D;是正好在迭代语句之前。 “正好”的意思就是,&#x3D;&#x3D;不要在标签和迭代之间插入任何语句&#x3D;&#x3D;</p>
<p>break 和 continue 通常只会中断当前循环,但和标签一起用时,它们可以中断这个嵌套的循环,直接跳转到标签所在的位置</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>使用标签的&#x3D;&#x3D;唯一理由&#x3D;&#x3D;就是你用到了嵌套循环，而且你需要使用 break 或 continue 来跳出多层的嵌套。</li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector) &#123;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value2 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value3 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value4 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value5 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>整数选择器(integral-selector)是一个能生成整数值的表达式</p>
<ul>
<li><p>int</p>
</li>
<li><p>char</p>
</li>
<li><p>字符串</p>
</li>
<li><p>enum</p>
</li>
</ul>
</li>
</ul>
<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><h3 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h3><p>Java 允许在一个类里将多个静态初始化语句放在一个特殊的“静态子句”里(有时称为静态块)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只执行一次:第一次创建该类的对象时,或第一次访问该类的静态成员时(即使从未创建过该类的对象) 。</p>
<h3 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h3><p>Java 提供了一种称为实例初始化(instance initialization)的类似语法,&#x3D;&#x3D;用于初始化每个对象的非静态变量&#x3D;&#x3D;。</p>
<p>可以用来保证无论调用哪个显式的构造器,某些操作都会发生</p>
<p>实例初始化子句在&#x3D;&#x3D;构造器之前执行&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mugs</span> &#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        mug1 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mugs(<span class="type">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>方法1</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1[];</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>编译器不允许指定数组的大小</p>
</li>
<li><p>所拥有的只是对数组的引用(你已经为该引用分配了足够的存储空间) ,并没有为数组对象本身分配任何空间</p>
</li>
<li><p>创建了一个非基本类型数组,其实就是创建了一个引用数组</p>
<p> 即便使用了 new 来创建数组之后，它还只是一个引用数组,直到通过自动装箱为数组里的每个引用本身初始化了一个Integer 对象之后,这个数组的初始化才真正结束</p>
</li>
</ul>
<h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><p><strong>特殊的初始化方式</strong></p>
<p>只能在创建数组的地方出现，编译器负责存储的分配(相当于使用 new)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>默认</strong></p>
<p>自动初始化为空值(对于数值类型和 char 是 0, 对于 boolean 则是 false)</p>
<p><strong>花括号包围列表</strong></p>
<p>使用花括号保卫列表来初始化对象数组</p>
<ul>
<li><p>方法1：局限性更大,它只能用在定义数组的时候</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>,  <span class="number">2</span>, <span class="number">3</span>, &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2: 在任何地方使用第二种形式(定义了 b) ,甚至在方法调用中也可以</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] b = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123; <span class="number">1</span>,  <span class="number">2</span>, <span class="number">3</span>,  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>初始值列表的最后一个逗号都是可选的(此功能可以让维护长列表更容易)</li>
</ul>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p><strong>赋值</strong></p>
<p>可以将一个数组赋值给另一个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2 = a1</span><br></pre></td></tr></table></figure>

<p>其实真正做的知识复制了一个引用</p>
<p><strong>查询数组有多少个元素</strong></p>
<p>成员变量: <code>length</code></p>
<h2 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h2><p>如果列表中没有任何内容,则它会转变成一个大小为零的数组</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="printBinaryInt-和-printBinaryLong"><a href="#printBinaryInt-和-printBinaryLong" class="headerlink" title="printBinaryInt() 和 printBinaryLong()"></a>printBinaryInt() 和 printBinaryLong()</h2><p>分别接受 int 类型和 long 类型的参数,然后输出其二进制格式</p>
<h2 id="n"><a href="#n" class="headerlink" title="%n"></a>%n</h2><p>Java 用 <code>%n</code> 来实现的功能,它会根据程序运行的平台生成合适的换行符,不过这仅会在使用 <code>System.out.printf()</code> 或 <code>System.out.format()</code> 时起作用。对于 <code>System.out.println()</code>,你仍然必须使用 <code>\n</code>;如果使用了 <code>%n</code>, <code>println()</code> 只会输出 <code>%n</code> 而不是将其当作换行符。</p>
<h2 id="toBinaryString"><a href="#toBinaryString" class="headerlink" title="toBinaryString()"></a>toBinaryString()</h2><p>使用 Integer 和 Long 类的静态方法 toBinaryString() 可以很容易实现获取二进制</p>
<p>如果将比较小的类型传递给Integer.toBinaryString() 方法,则该类型会自动被转换为 int 类型</p>
<h2 id="Integer-toString"><a href="#Integer-toString" class="headerlink" title="Integer.toString()"></a>Integer.toString()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer.toString() 的简化版:</span></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + x);</span><br></pre></td></tr></table></figure>



<h2 id="Array-toString-a"><a href="#Array-toString-a" class="headerlink" title="Array.toString(a)"></a>Array.toString(a)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(Array.toString(a));</span><br></pre></td></tr></table></figure>



<h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h2><p>生成一个对象的类,当打印这个类时,你会看到一个表示该类类型的编码字符串</p>
<p><code>[</code> 表示这是后面紧随的类型的数组</p>
<h2 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h2><p>表示特定 enum 常量的声明顺序</p>
<h2 id="一个静态的values-方法"><a href="#一个静态的values-方法" class="headerlink" title="一个静态的values() 方法"></a>一个静态的values() 方法</h2><p>它按照声明顺序生成一个 enum 常量值的数组</p>
<h2 id="自动类型推断"><a href="#自动类型推断" class="headerlink" title="自动类型推断"></a>自动类型推断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// housekeeping/TypeInference.java </span></span><br><span class="line"><span class="comment">// &#123;NewFeature&#125; 从 JDK 11 开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plumbus</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeInference</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 显式类型:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hello1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 类型推断:</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">        <span class="comment">// 用户定义的类型也起作用:</span></span><br><span class="line">        <span class="type">Plumbus</span> <span class="variable">pb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Plumbus</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">pb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Plumbus</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法里也可以启用:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">        <span class="type">var</span> <span class="variable">pb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Plumbus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoInference</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">field1</span> <span class="operator">=</span> <span class="string">&quot;Field initialization&quot;</span>;</span><br><span class="line">    <span class="comment">// var field2 = &quot;Can&#x27;t do this&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void method() &#123;</span></span><br><span class="line">    <span class="comment">//     var noInitializer; // No inference data</span></span><br><span class="line">    <span class="comment">//     var aNull = null; // No inference data //</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// var inferReturnType() &#123;</span></span><br><span class="line">    <span class="comment">//     return &quot;Can&#x27;t infer return type&quot;; //</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p><code>static</code> 修饰的字段或方法（也称“类数据 class data” 和 “类方法class method”），只服务于类，而非特定的对象。这些数据或方法只会占用同一块内存空间，即会被由该类创建所有的对象所共享。</p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>调用 static 方法并不依赖于是否提前创建对象。正因为如此,我们也&#x3D;&#x3D;不能在没有具体对象的情况下, 使用 static 方法直接调用非 static 成员或方法&#x3D;&#x3D;(因为非 static 成员和方法必须基于特定的对象才能 运行) 。</p>
<h2 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h2><ul>
<li><p>通过对象调用: <code>&lt;对象&gt;.&lt;static 成员&gt;</code></p>
</li>
<li><p>通过类名调用: <code>&lt;类名&gt;.&lt;static 成员&gt;</code> （&#x3D;&#x3D;推荐使用该方法&#x3D;&#x3D;）</p>
<p> <strong>注意</strong>：&#x3D;&#x3D;非 static 成员则不能这样使用&#x3D;&#x3D;</p>
</li>
</ul>
<h2 id="生成方式"><a href="#生成方式" class="headerlink" title="生成方式"></a>生成方式</h2><ul>
<li><p>static 字段</p>
<ul>
<li>是基于类创建的</li>
<li>即便你没有创建对象,也可以调用该方法</li>
</ul>
</li>
<li><p>非 static 字段</p>
<ul>
<li>是基于对象创建的</li>
</ul>
</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>见下</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul>
<li>每个编译单元(文件)都只能有一个public类，但可以根据需要拥有任意数量的包访问权限的类<ul>
<li>public 类的名称必须与包含编译单元的文件名完全匹配,包括大小写</li>
<li>编译单元里可以没有 public 类。这时你可以随意命名文件</li>
</ul>
</li>
<li>类访问权限, 只有两种选择: 包访问权限和 public<ul>
<li>若防止对该类的访问,可以将其所有的构造器都设为 private</li>
</ul>
</li>
</ul>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>random()</code></td>
<td>生成一个范围为0~1(包括 0,但不包括 1)的 double 值</td>
</tr>
</tbody></table>
<h2 id="java-lang-Character-包装器类"><a href="#java-lang-Character-包装器类" class="headerlink" title="java.lang.Character 包装器类"></a>java.lang.Character 包装器类</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>isLowerCase()</code></td>
<td>检测出相关字符是否为小写字母</td>
</tr>
</tbody></table>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="包与库的关系"><a href="#包与库的关系" class="headerlink" title="包与库的关系"></a>包与库的关系</h2><p>不清楚</p>
<p>​	</p>
<h1 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h1><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>每个非基本类型的对象都有一个 toString() 方法</p>
<p>它会在一些特殊情况下被调用,比如当编译器需要一个字符串,但有的是一个对象时。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解 <code>@Override</code> 用在 toString() 方法上</p>
<p><code>@Override</code> 是可选的</p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="final-数据"><a href="#final-数据" class="headerlink" title="final 数据"></a>final 数据</h2><ul>
<li>定义常量</li>
</ul>
<h3 id="空白-final"><a href="#空白-final" class="headerlink" title="空白 final"></a>空白 final</h3><p>final 执行赋值的操作只能发生在两个地方</p>
<ul>
<li>在字段定义处使用表达式进行赋值</li>
<li>在每个构造器中</li>
</ul>
<h3 id="final-参数"><a href="#final-参数" class="headerlink" title="final 参数"></a>final 参数</h3><p>在方法内部不能更改参数引用指向的内容</p>
<p>可以读取这个参数, 但不能修改它</p>
<h2 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>在方法上放置一个“锁” ,这样就可以防止继承类通过重写来改变该方法的含义</li>
<li>效率：编译器可以将任何对该方法的调用转换为内联调用 （现在可以不用考虑这个因素了，主要考虑 “锁” 的因素）</li>
</ul>
<h3 id="final-和-private"><a href="#final-和-private" class="headerlink" title="final 和 private"></a>final 和 private</h3><p>类中的任何 private 方法都是隐式的 final</p>
<h2 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h2><p>将整个类定义为 final 时(通过在其定义前加上 final 关键字) ,就阻止了该类的所有继承</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2023/05/13/150/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/13/150/" class="post-title-link" itemprop="url">150. 文献管理与信息分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-13T00:00:00+08:00">2023-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-08 14:36:58" itemprop="dateModified" datetime="2025-12-08T14:36:58+08:00">2025-12-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h2 id="提升学习能力"><a href="#提升学习能力" class="headerlink" title="提升学习能力"></a>提升学习能力</h2><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><img data-src="/2023/05/13/150/image-20230519125918166.png" class="" title="image-20230519125918166">

<p> 社会的进步是一部信息存储和传播方式变革的历史</p>
<h3 id="时间不变信息爆炸的应对策略"><a href="#时间不变信息爆炸的应对策略" class="headerlink" title="时间不变信息爆炸的应对策略"></a>时间不变信息爆炸的应对策略</h3><ul>
<li><del>放弃治疗</del></li>
<li>加大投入</li>
<li>&#x3D;&#x3D;提升效率&#x3D;&#x3D;</li>
</ul>
<h3 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h3>  <img data-src="/2023/05/13/150/image-20230519131639285.png" class="" title="image-20230519131639285">



<h2 id="提升科研能力"><a href="#提升科研能力" class="headerlink" title="提升科研能力"></a>提升科研能力</h2><h3 id="什么是科研"><a href="#什么是科研" class="headerlink" title="什么是科研"></a>什么是科研</h3><ul>
<li>解决未知的问题</li>
<li>发现新事物或新规律</li>
<li>创造新事物</li>
</ul>
<h3 id="科研特性"><a href="#科研特性" class="headerlink" title="科研特性"></a>科研特性</h3><ul>
<li>只认第一，不认第二</li>
<li>科学研究需要探索未知，面对新事物（恐惧感）</li>
<li>需要解决新问题</li>
<li>科研需要大量的重复</li>
<li>科研会经历很多次失败</li>
</ul>
<h3 id="读研意义"><a href="#读研意义" class="headerlink" title="读研意义"></a>读研意义</h3><ul>
<li>全球视野，以及发现需求的眼光</li>
<li>面对未知事务的勇气，以及愈挫愈勇的韧性</li>
<li>解决问题的English</li>
<li>在持续努力和练习的过程中形成习惯</li>
<li>任何成功的人，都是优秀的研究者</li>
</ul>
<h3 id="好的选题从哪里来"><a href="#好的选题从哪里来" class="headerlink" title="好的选题从哪里来"></a>好的选题从哪里来</h3><ul>
<li>知己知彼：你对一个领域的了解程度会直接影响你的选题</li>
<li>现实需求：真正来自现实生活的需求最有生命力（洞察力）</li>
<li>长期思考：有的问题需要多年的斯奎</li>
<li>宽广胸怀：一个人的出发点直接决定了选题可能得高度</li>
<li>好的选题非一日之功</li>
</ul>
<h2 id="提升创新能力"><a href="#提升创新能力" class="headerlink" title="提升创新能力"></a>提升创新能力</h2><p>&#x3D;&#x3D;新？&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;创新？&#x3D;&#x3D;： 省时省钱爽</p>
<h2 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h2><h3 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h3><p>不可能什么都去学</p>
<p>要“偏科”</p>
<h3 id="向“牛人”学习"><a href="#向“牛人”学习" class="headerlink" title="向“牛人”学习"></a>向“牛人”学习</h3><ul>
<li>人</li>
<li>思维方式</li>
<li>一本好书</li>
<li>一门好课</li>
<li>一个好资源</li>
</ul>
<p>思考什么方式学习最高效</p>
<h3 id="善假于物"><a href="#善假于物" class="headerlink" title="善假于物"></a>善假于物</h3><img data-src="/2023/05/13/150/image-20230519140328979.png" class="" title="image-20230519140328979">



<h3 id="投资时间"><a href="#投资时间" class="headerlink" title="投资时间"></a>投资时间</h3><ul>
<li>花一定的时间去学习去提高我们的效率，从而节省我们的时间</li>
<li>辛苦很可能是因为无知，要减少自己的无效时间(这就是&#x3D;&#x3D;低效&#x3D;&#x3D;)</li>
<li>最怕还不是低效的行为，而是认为这就是世界的运转方式，而意识不到自己的低效，因此，要有&#x3D;&#x3D;刀刃向内的勇气&#x3D;&#x3D;，多问问自己，多查查资料，看看有没有更好更快的方法</li>
<li>两类不知道知识<ul>
<li>我知道自己不知道某个知识<ul>
<li>查</li>
<li>学</li>
</ul>
</li>
<li>我根本不知道自己不知道某个知识<ul>
<li>见常人所不能见</li>
<li>多看，多了解</li>
<li>被动</li>
<li>做一个复杂、耗时的事情，要思考有没有方法能够变得更简单（尤其是重复的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<p>流程化+工具+投资时间</p>
<h3 id="建立分享意识"><a href="#建立分享意识" class="headerlink" title="建立分享意识"></a>建立分享意识</h3><ul>
<li>分享是高效、积极、主动的学习</li>
<li>分享是学习的动力所在（输出带动输入）</li>
<li>分享可以为自己带来更多的机会（怀才不遇）</li>
<li>分享可以建立自己的品牌，扩大人脉资源</li>
<li>分享是对知识的主动传播</li>
<li>分享可以检验需求！身边每个牛叉的人都是积极的分享者</li>
</ul>
<p>费曼学习法：把别人讲明白</p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><ul>
<li>有所学，有所不学的&#x3D;&#x3D;专注意识&#x3D;&#x3D;</li>
<li>学习精华内容的&#x3D;&#x3D;(牛人)意识&#x3D;&#x3D;</li>
<li>善假于物的&#x3D;&#x3D;工具意识&#x3D;&#x3D;</li>
<li>提升效率的&#x3D;&#x3D;时间投资&#x3D;&#x3D;意识</li>
<li>传播知识共同成长的&#x3D;&#x3D;分享意识&#x3D;&#x3D;</li>
</ul>
<h2 id="当一项技能不能形成习惯，就无法给我们的生命带来改变"><a href="#当一项技能不能形成习惯，就无法给我们的生命带来改变" class="headerlink" title="当一项技能不能形成习惯，就无法给我们的生命带来改变"></a>当一项技能不能形成习惯，就无法给我们的生命带来改变</h2><h1 id="学习与搜索"><a href="#学习与搜索" class="headerlink" title="学习与搜索"></a>学习与搜索</h1><h2 id="学习与搜索-1"><a href="#学习与搜索-1" class="headerlink" title="学习与搜索"></a>学习与搜索</h2><h3 id="课堂三问"><a href="#课堂三问" class="headerlink" title="课堂三问"></a>课堂三问</h3><ul>
<li>&#x3D;&#x3D;[过去]&#x3D;&#x3D;这个工具出现的背景是什么？这个工具是怎么发展的？</li>
<li>&#x3D;&#x3D;[现在]&#x3D;&#x3D;如何使用这个工具？对我有何价值？</li>
<li>&#x3D;&#x3D;[未来]&#x3D;&#x3D;未来这个工具还会怎样发展？有没有更好的解决方案？</li>
</ul>
<h3 id="什么是学习"><a href="#什么是学习" class="headerlink" title="什么是学习"></a>什么是学习</h3><p>把别人的变成自己的</p>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><h3 id="什么是需求"><a href="#什么是需求" class="headerlink" title="什么是需求"></a>什么是需求</h3><ul>
<li>需求就是客服种种不便，消灭抱怨</li>
<li>每一个抱怨的背后都隐藏着一个未被满足的需求，每一个需求的背后必然隐藏着一个不可忽视的市场</li>
</ul>
<p>为什么你愿意花钱</p>
<h1 id="快速学习"><a href="#快速学习" class="headerlink" title="快速学习"></a>快速学习</h1><h2 id="读论文方法推荐"><a href="#读论文方法推荐" class="headerlink" title="读论文方法推荐"></a>读论文方法推荐</h2><ul>
<li>思维导图梳理</li>
</ul>
<h2 id="流程化"><a href="#流程化" class="headerlink" title="流程化"></a>流程化</h2><ul>
<li>减少流程间的切换次数</li>
<li>专注在一件事情上：在相对一定的时间中，保持专注</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li><p>信息检索</p>
<p>思考如何准确检索到与主题密切相关的信息；注意检索式，信息来源，时效性等等</p>
</li>
<li><p>信息收集</p>
<p>可以通过为知笔记快速收集信息，（信息同步速度会受网络状态影响）</p>
</li>
<li><p>信息筛选</p>
<p>通过星标阅读来整理信息</p>
</li>
<li><p>信息整理</p>
<p>结合星标、笔记和思维导图来整理信息</p>
</li>
<li><p>信息输出</p>
<p>总结成文字，提交作业</p>
</li>
</ol>
<h1 id="科研入门及十大信息源"><a href="#科研入门及十大信息源" class="headerlink" title="科研入门及十大信息源"></a>科研入门及十大信息源</h1><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><h3 id="什么是科研-1"><a href="#什么是科研-1" class="headerlink" title="什么是科研"></a>什么是科研</h3><p>略（上有）</p>
<h3 id="科研目的"><a href="#科研目的" class="headerlink" title="科研目的"></a>科研目的</h3><p>更加爽</p>
<h3 id="科研从哪里开始"><a href="#科研从哪里开始" class="headerlink" title="科研从哪里开始"></a>科研从哪里开始</h3><p>科研从需求开始，需求在哪里？</p>
<p>掌握信息，要对领域有一个比较深的了解</p>
<h2 id="十大信息源"><a href="#十大信息源" class="headerlink" title="十大信息源"></a>十大信息源</h2><ol>
<li>专利</li>
<li>会议文献</li>
<li>期刊</li>
<li>科技报告</li>
<li>学位论文</li>
<li>科技档案</li>
<li>图书</li>
<li>产品资料</li>
<li>标准</li>
<li>政府出版物</li>
</ol>
<blockquote>
<p>注</p>
</blockquote>
<ul>
<li>来自产品的方法往往比文献中的方法更加可靠</li>
<li>时间出现顺序从上至下</li>
</ul>
<h2 id="快速调研"><a href="#快速调研" class="headerlink" title="快速调研"></a>快速调研</h2><h3 id="处于不同段位检索的方法"><a href="#处于不同段位检索的方法" class="headerlink" title="处于不同段位检索的方法"></a>处于不同段位检索的方法</h3><ul>
<li>检索与目标要紧密结合</li>
<li>入门阶段：快 （体现快速学习能力）</li>
<li>解决问题阶段：广 和 准 （快速解决问题、广阔思路）</li>
<li>选题阶段要： 广 深 新 （要求高）</li>
</ul>
<h3 id="如何快速了解导师（实验室）的研究方向？"><a href="#如何快速了解导师（实验室）的研究方向？" class="headerlink" title="如何快速了解导师（实验室）的研究方向？"></a>如何快速了解导师（实验室）的研究方向？</h3><ul>
<li>导师的在研课题的基金申请书</li>
<li>自然基金系统，主动查询摘要</li>
<li>实验室网页</li>
<li>实验室的毕业论文</li>
<li>实验室近年发表的论文</li>
<li>师兄师姐</li>
<li>直接和导师沟通</li>
</ul>
<h1 id="文献数据库及其利用"><a href="#文献数据库及其利用" class="headerlink" title="文献数据库及其利用"></a>文献数据库及其利用</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>去哪里查</p>
<p>如何检索</p>
<p>如何管理</p>
<p>如何阅读</p>
<h2 id="WOS-数据库"><a href="#WOS-数据库" class="headerlink" title="WOS 数据库"></a>WOS 数据库</h2><h3 id="新文章-or-学科发展相对较慢的论文的重要性"><a href="#新文章-or-学科发展相对较慢的论文的重要性" class="headerlink" title="新文章 or 学科发展相对较慢的论文的重要性"></a>新文章 or 学科发展相对较慢的论文的重要性</h3><ul>
<li>看使用次数</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>文献检索的前中后阶段</p>
</blockquote>
<ul>
<li>检索前；检索目的、数据库选择、检索策略</li>
<li>检索中：结果的浏览、分析鱼信息输出</li>
<li>检索后：管理、阅读、整理</li>
</ul>
<h1 id="论文管理工具"><a href="#论文管理工具" class="headerlink" title="论文管理工具"></a>论文管理工具</h1><p>&#x3D;&#x3D;需求&#x3D;&#x3D;就是做某件事觉得不爽</p>
<p>&#x3D;&#x3D;创新&#x3D;&#x3D;就是解决遇到的不爽</p>
<h1 id="快速定位关键文献"><a href="#快速定位关键文献" class="headerlink" title="快速定位关键文献"></a>快速定位关键文献</h1><h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><h3 id="文献很多"><a href="#文献很多" class="headerlink" title="文献很多"></a>文献很多</h3><p>选择重要文献研读之</p>
<h3 id="文献帅选的策略鱼调研目的相关"><a href="#文献帅选的策略鱼调研目的相关" class="headerlink" title="文献帅选的策略鱼调研目的相关"></a>文献帅选的策略鱼调研目的相关</h3><ul>
<li>跟踪进展：</li>
<li>特定参考</li>
<li>全面调研<ul>
<li>综述</li>
<li>专著</li>
<li>教材 or 教科书 （宽泛）</li>
<li>专家</li>
</ul>
</li>
</ul>
<h3 id="获取重要资料"><a href="#获取重要资料" class="headerlink" title="获取重要资料"></a>获取重要资料</h3><ul>
<li>专家推荐</li>
<li>文献检索</li>
<li>文献分析</li>
</ul>
<h2 id="引文分析软件"><a href="#引文分析软件" class="headerlink" title="引文分析软件"></a>引文分析软件</h2><p>下载的数据，文献之间没有关联，那么说明检索是不太合适的。如果检索是合适的，那么这些文献之间会相互引用</p>
<h1 id="高效调研"><a href="#高效调研" class="headerlink" title="高效调研"></a>高效调研</h1><h2 id="信息检索"><a href="#信息检索" class="headerlink" title="信息检索"></a>信息检索</h2><ol>
<li><p>我在哪里可以检索到信息，如何选择关键词</p>
<ul>
<li><p>信息源</p>
<ul>
<li><p>十大信息源</p>
<ul>
<li>会议文献</li>
<li>期刊</li>
<li>科技报告</li>
<li>学位论文</li>
<li>图书</li>
</ul>
</li>
<li><p>网站搜索</p>
</li>
<li><p>科学新闻：简洁易懂</p>
</li>
<li><p>课题申请指南 （新的前沿）</p>
</li>
<li><p>社群</p>
</li>
<li><p>微信公众号</p>
</li>
<li><p>科研项目数据库</p>
</li>
<li><p>博客</p>
</li>
<li><p>面对面交流</p>
</li>
<li><p>实地考察</p>
</li>
<li><p>内部档案</p>
</li>
</ul>
</li>
<li><p>选词</p>
<ul>
<li>宽泛检索，逐步凝练；通过网页介绍发现关键词<ul>
<li>网页</li>
<li>知网</li>
<li>知网指数分析功能</li>
<li>百度学术</li>
</ul>
</li>
<li>关键词分析<ul>
<li>endnote</li>
</ul>
</li>
<li>histcite分析（作图+cited reference）</li>
</ul>
</li>
<li><p>判断关键词是否宽泛</p>
<ul>
<li>根据cited references来判断</li>
<li>根据histcite作图中的关联情况来判断</li>
</ul>
</li>
</ul>
</li>
<li><p>如何利用数据库和其他信息源</p>
</li>
</ol>
<h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>标题 -&gt; 摘要 -&gt; 全文</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p>zetero</p>
</li>
<li><p>histcite</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20902898">链接</a></p>
</li>
<li><p>web of science</p>
<ul>
<li>&#x3D;&#x3D;登录时不要使用科学上网&#x3D;&#x3D;</li>
<li>数据库：&#x3D;&#x3D;Web of Science 核心合集&#x3D;&#x3D;</li>
<li>记录内容：&#x3D;&#x3D;全纪录与引用的参考文献&#x3D;&#x3D;</li>
</ul>
</li>
<li><p>endnote</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Qeuroal</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Qeuroal" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
