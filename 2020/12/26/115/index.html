<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qeuroal.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="面向对象基础例子   1234class Person &#123;    public String name;    public int age;&#125;    一个 class 可以包含多个字段（field），字段用来描述一个类的特征。上面的 Person 类，我们定义了两个字段，一个是 String 类型的字段，命名为 name，一个是 int 类型的字段，命名为 age。因此，通过">
<meta property="og:type" content="article">
<meta property="og:title" content="115. Java 面向对象">
<meta property="og:url" content="http://qeuroal.top/2020/12/26/115/index.html">
<meta property="og:site_name" content="Qeuroal&#39;s Blog">
<meta property="og:description" content="面向对象基础例子   1234class Person &#123;    public String name;    public int age;&#125;    一个 class 可以包含多个字段（field），字段用来描述一个类的特征。上面的 Person 类，我们定义了两个字段，一个是 String 类型的字段，命名为 name，一个是 int 类型的字段，命名为 age。因此，通过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qeuroal.top/2020/12/26/115/2.png">
<meta property="og:image" content="http://qeuroal.top/2020/12/26/115/3.png">
<meta property="og:image" content="http://qeuroal.top/2020/12/26/115/4.png">
<meta property="article:published_time" content="2020-12-25T20:00:00.000Z">
<meta property="article:modified_time" content="2025-10-01T23:18:39.348Z">
<meta property="article:author" content="Qeuroal">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qeuroal.top/2020/12/26/115/2.png">


<link rel="canonical" href="http://qeuroal.top/2020/12/26/115/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qeuroal.top/2020/12/26/115/","path":"2020/12/26/115/","title":"115. Java 面向对象"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>115. Java 面向对象 | Qeuroal's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qeuroal's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">静幽正治</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">1.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.</span> <span class="nav-text">创建实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.</span> <span class="nav-text">类和对象的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.5.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9B%BE"><span class="nav-number">2.</span> <span class="nav-text">类图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">定义方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#private-%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">private 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">this 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="nav-number">3.4.</span> <span class="nav-text">方法参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-number">3.6.</span> <span class="nav-text">参数绑定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">5.</span> <span class="nav-text">方法重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-number">6.2.</span> <span class="nav-text">继承树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protected"><span class="nav-number">6.3.</span> <span class="nav-text">protected</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">6.4.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">6.5.</span> <span class="nav-text">阻止继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E5%9C%B0%E5%8F%98%E4%B8%BA%E7%88%B6%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="nav-number">6.6.</span> <span class="nav-text">向上转型：一个子类类型安全地变为父类类型的赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E6%8A%8A%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E5%9E%8B%E4%B8%BA%E5%AD%90%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.7.</span> <span class="nav-text">向下转型：把一个父类类型强制转型为子类类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">6.8.</span> <span class="nav-text">组合和继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">7.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">7.1.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E5%86%99%EF%BC%88%E9%87%8D%E5%86%99%E3%80%81%E8%A6%86%E7%9B%96%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">覆写（重写、覆盖）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E4%BE%8B"><span class="nav-number">7.3.</span> <span class="nav-text">引例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">7.4.</span> <span class="nav-text">多态定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E7%94%A8%E5%A4%84"><span class="nav-number">7.5.</span> <span class="nav-text">多态的用处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">7.6.</span> <span class="nav-text">final</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5"><span class="nav-number">8.1.</span> <span class="nav-text">引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="nav-number">8.1.1.</span> <span class="nav-text">个人理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">8.2.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">8.2.1.</span> <span class="nav-text">抽象类的用途</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">8.3.</span> <span class="nav-text">面向抽象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">8.3.1.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-1"><span class="nav-number">9.1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">9.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">9.3.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="nav-number">9.4.</span> <span class="nav-text">接口继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">9.5.</span> <span class="nav-text">继承关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default-%E6%96%B9%E6%B3%95"><span class="nav-number">9.6.</span> <span class="nav-text">default 方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">10.</span> <span class="nav-text">静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">10.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">11.</span> <span class="nav-text">包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">11.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">11.2.</span> <span class="nav-text">包作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#import"><span class="nav-number">11.3.</span> <span class="nav-text">import</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">11.4.</span> <span class="nav-text">最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="nav-number">11.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">12.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#public"><span class="nav-number">12.1.</span> <span class="nav-text">public</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#private"><span class="nav-number">12.2.</span> <span class="nav-text">private</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-1"><span class="nav-number">12.3.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1"><span class="nav-number">12.4.</span> <span class="nav-text">最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="nav-number">12.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">13.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Inner-Class"><span class="nav-number">13.1.</span> <span class="nav-text">Inner Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Anonymous-Class"><span class="nav-number">13.2.</span> <span class="nav-text">Anonymous Class (?)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="nav-number">13.3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-1"><span class="nav-number">13.4.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#classpath-%E5%92%8C-jar"><span class="nav-number">14.</span> <span class="nav-text">classpath 和 jar</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#classpath"><span class="nav-number">14.1.</span> <span class="nav-text">classpath</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jar-%E5%8C%85"><span class="nav-number">14.2.</span> <span class="nav-text">jar 包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="nav-number">14.3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-2"><span class="nav-number">14.4.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">14.5.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">15.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="nav-number">15.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97"><span class="nav-number">15.2.</span> <span class="nav-text">编写模块</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qeuroal"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qeuroal</p>
  <div class="site-description" itemprop="description">大人者，不失其赤子之心</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">183</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Qeuroal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Qeuroal" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qeuroal.top/2020/12/26/115/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qeuroal">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qeuroal's Blog">
      <meta itemprop="description" content="大人者，不失其赤子之心">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="115. Java 面向对象 | Qeuroal's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          115. Java 面向对象
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-26 04:00:00" itemprop="dateCreated datePublished" datetime="2020-12-26T04:00:00+08:00">2020-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-02 07:18:39" itemprop="dateModified" datetime="2025-10-02T07:18:39+08:00">2025-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   一个 class 可以包含多个字段（field），字段用来描述一个类的特征。上面的 Person 类，我们定义了两个字段，一个是 String 类型的字段，命名为 name，一个是 int 类型的字段，命名为 age。因此，通过 class，把一组数据汇集到一个对象上，实现了数据封装。</p>
<blockquote>
<p>字段就是 C++ 中的成员属性</p>
</blockquote>
<h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Role</span> <span class="variable">role1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>(); <span class="comment">// 在堆空间里面分配了一个空间，把空间的地址赋给了 role1，用哈希码来表示在虚拟机里面的内存地址</span></span><br><span class="line">Role role2; <span class="comment">// 声明了一个 Role 类型的变量，叫 role2（可以把 Role 看成自己定义的数据类型），但是还没有空间</span></span><br><span class="line">role2 = <span class="keyword">new</span> <span class="title class_">Role</span>();  <span class="comment">// role2 一定要初始化，对象在运行时，一定要分配空间</span></span><br></pre></td></tr></table></figure>

<h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><ul>
<li>类是一个抽象的概念，仅仅是模板，比如说：演员、总统</li>
<li>对象是一个你能够看得到、摸得着的具体实体</li>
<li>类的定义者和类的使用者是不一样的。越往下越具体，越往上越抽象。</li>
</ul>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>发现类</li>
<li>找出属性（名词）</li>
<li>找出行为（动词）</li>
<li>数据抽象：是数据和处理方法的结合</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在 OOP 中，class 和 instance 是 “模版” 和 “实例” 的关系；</li>
<li>类就是对象的模板（蓝图）</li>
<li>定义 class 就是定义了一种数据类型，对应的 instance 是这种数据类型的实例；</li>
<li>class 定义的 field，在每个 instance 都会拥有各自的 field，且互不干扰；</li>
<li>通过 new 操作符创建新的 instance，然后用变量指向它，即可通过变量来引用这个 instance；</li>
<li>访问实例字段的方法是变量名. 字段名；</li>
</ul>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><ol>
<li>直观、容易理解</li>
<li>参考工具：<ul>
<li>StarUML</li>
<li>Astah</li>
<li><ul>
<li>号代表 public，- 号代表 private</li>
</ul>
</li>
<li>属性名在前，后面跟冒号和类型名</li>
<li>方法名在前，后面跟冒号和返回值类型</li>
<li>如果有参数，参数的类型写法同上</li>
<li>Astah</li>
</ul>
</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>   把 field 从 public 改成 private，外部代码不能访问这些 field，以我们需要使用方法（method）来让外部代码可以间接修改 field：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      ming.setName(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 设置 name</span></span><br><span class="line">      ming.setAge(<span class="number">12</span>); <span class="comment">// 设置 age</span></span><br><span class="line">      System.out.println(ming.getName() + <span class="string">&quot;,&quot;</span> + ming.getAge());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age&gt; <span class="number">100</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid age value&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   虽然外部代码不能直接修改 private 字段，但是，外部代码可以调用方法 setName() 和 setAge() 来间接修改 private 字段。在方法内部，我们就有机会检查参数对不对。比如，setAge() 就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把 age 设置成不合理的值。<br>   同样，外部代码不能直接读取 private 字段，但可以通过 getName() 和 getAge() 间接获取 private 字段的值。<br>   所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。</p>
<p>   调用方法的语法是实例变量 <code>. 方法名 (参数)</code>;。一个方法调用就是一个语句，所以不要忘了在末尾加 <code>;</code>。例如：<code>ming.setName(&quot;Xiao Ming&quot;);</code>。</p>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法返回类型 方法名 (方法参数列表) &#123;</span><br><span class="line">若干方法语句;</span><br><span class="line"><span class="keyword">return</span> 方法返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="private-方法"><a href="#private-方法" class="headerlink" title="private 方法"></a>private 方法</h2><blockquote>
<p>有 public 方法，自然就有 private 方法。和 private 字段一样，private 方法不允许外部调用，定义 private 方法的理由是内部方法是可以调用 private 方法的。</p>
</blockquote>
<h2 id="this-变量"><a href="#this-变量" class="headerlink" title="this 变量"></a>this 变量</h2><blockquote>
<p>在方法内部，可以使用一个隐含的变量 this，它始终指向当前实例。因此，通过 this.field 就可以访问当前实例的字段。如果没有命名冲突，可以省略 this，但是如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上 this</p>
</blockquote>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><blockquote>
<p>方法可以包含 0 个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。(同 C++)</p>
</blockquote>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><blockquote>
<p>可变参数用 <code> 类型...</code> 定义，可变参数相当于数组类型：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String[] names;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>  public void setNames(String... names) &#123;
     this.names = names;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; 上面的 setNames() 就定义了一个可变参数。调用时，可以这么写：</span><br><span class="line">```java</span><br><span class="line">Group g = new Group();</span><br><span class="line">g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;); // 传入 3 个 String</span><br><span class="line">g.setNames(&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;); // 传入 2 个 String</span><br><span class="line">g.setNames(&quot;Xiao Ming&quot;); // 传入 1 个 String</span><br><span class="line">g.setNames(); // 传入 0 个 String</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>完全可以把可变参数改写为 String[] 类型：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String[] names;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>  public void setNames(String[] names) &#123;
     this.names = names;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 但是，调用方需要自己先构造 String[]，比较麻烦。例如：</span><br><span class="line">```java</span><br><span class="line">Group g = new Group();</span><br><span class="line">g.setNames(new String[] &#123;&quot;Xiao Ming&quot;, &quot;Xiao Hong&quot;, &quot;Xiao Jun&quot;&#125;); // 传入 1 个 String[]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>另一个问题是，调用方可以传入 null：</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Group</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">g.setNames(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而可变参数可以保证无法传入 null，因为传入 0 个参数时，接收到的实际值是一个空数组而不是 null。</p>
</blockquote>
<h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><blockquote>
<p>传参的问题<br>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。<br>引用类型的传递：将地址进行复制，如下：</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      String[] fullname = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Homer&quot;</span>, <span class="string">&quot;Simpson&quot;</span> &#125;;</span><br><span class="line">      p.setName(fullname); <span class="comment">// 传入 fullname 数组</span></span><br><span class="line">      System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;</span></span><br><span class="line">      fullname[<span class="number">0</span>] = <span class="string">&quot;Bart&quot;</span>; <span class="comment">// fullname 数组的第一个元素修改为 &quot;Bart&quot;</span></span><br><span class="line">      System.out.println(p.getName()); <span class="comment">// &quot;Bart Simpson&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String[] name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.name[<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String[] name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note</strong>: 因为传入的是字符串数组，因此将 <code>fullname</code> 数组的地址复制，传给了 <code>p.name</code>，因此 <code>p.name</code> 和 <code>fullname</code> 指向的是同一个字符串数组，所以这两个同时变化，但是变化的时候还是遵循引用的原则：<code>Homer</code> 仍然存在，只是无法通过 <code>fullname[0]</code> 进行访问罢了。</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      <span class="type">String</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">      p.setName(bob); <span class="comment">// 传入 bob 变量</span></span><br><span class="line">      System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">      bob = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// bob 改名为 Alice</span></span><br><span class="line">      System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note</strong>: 和上一个传入引用参数一样，复制的是地址，传入之后 <code>bob</code> 和 <code>p.name</code> 指向了同一块内存，只不过 <code>bob</code> 改变之后会重新指向新的内存，所以这两个变量指向的内存就不一样了。</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>：字符串和数组都是引用类型。</p>
</blockquote>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ol>
<li>由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有 void），调用构造方法，必须用 new 操作符。(具体意义和 C++ 一样)</li>
<li>没有在构造方法中初始化字段时，引用类型的字段默认是 null，数值类型的字段用默认值，int 类型默认值是 0，布尔类型默认值是 false：</li>
<li>可以对字段直接进行初始化：</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造方法的代码由于后运行，最终由构造方法的代码确定，即便已经直接将字段初始化了。</p>
</blockquote>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><pre><code>&gt; 同 C++
</code></pre>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>   Student 类包含了 Person 类已有的字段和方法，只是多出了一个 score 字段和相应的 getScore()、setScore() 方法。<br>   继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让 Student 从 Person 继承时，Student 就获得了 Person 的所有功能，我们只需要为 Student 编写新增的功能。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote>
<p>Java 使用 extends 关键字来实现继承：</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="comment">// 不要重复 name 和 age 字段 / 方法,</span></span><br><span class="line">   <span class="comment">// 只需要定义新增 score 字段 / 方法:</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; …&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   通过继承，Student 只需要编写额外的功能，不再需要重复代码。</p>
<blockquote>
<p><strong>Note:</strong> 子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p>
</blockquote>
<p>   在 OOP 的术语中，我们把 <code>Person</code> 称为 <code> 超类（super class）</code>，<code> 父类（parent class）</code>，<code> 基类（base class）</code>，把 <code>Student</code> 称为 <code> 子类（subclass）</code>，<code> 扩展类（extended class）</code>。</p>
<h2 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h2><p>   在 Java 中，没有明确写 <code>extends</code> 的类，编译器会自动加上 <code>extends Object</code>。所以，任何类，除了 Object，都会继承自某个类。<br>   Java 只允许一个 class 继承自一个类，因此，一个类有且仅有一个父类。只有 Object 特殊，它没有父类。</p>
<p>   例如：<br>   <img data-src="/2020/12/26/115/2.png" class=""></p>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>   继承有个特点，就是子类无法访问父类的 <code>private</code> 字段或者 <code>private</code> 方法。<br>   为了让子类可以访问父类的字段，我们需要把 <code>private</code> 改为 <code>protected</code>。用 <code>protected</code> 修饰的字段可以被子类访问： 因此，<code>protected</code> 关键字可以把字段和方法的访问权限控制在继承树内部，一个 <code>protected</code> 字段和方法可以被其子类，以及子类的子类所访问。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>   <code>super</code> 关键字表示父类（超类）。子类引用父类的字段时，可以用 <code>super.fieldName</code>。例如：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + <span class="built_in">super</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   实际上，这里使用 <code>super.name</code>，或者 <code>this.name</code>，或者 <code>name</code>，效果都是一样的。编译器会自动定位到父类的 <code>name</code> 字段。<br>   但是，在某些时候，就必须使用 super。我们来看一个例子：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">         <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.score = score;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   运行上面的代码，会得到一个 <strong>编译错误</strong>，大意是在 Student 的构造方法中，无法调用 Person 的构造方法。</p>
<p>   这是因为在 Java 中，任何 class 的构造方法，**第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句 super();**，所以，Student 类的构造方法实际上是这样：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">         <span class="built_in">this</span>.score = score;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   但是，Person 类并没有无参数的构造方法，因此，编译失败。</p>
<p>   解决方法是调用 <code>Person</code> 类存在的某个构造方法。例如：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>(name, age); <span class="comment">// 调用父类的构造方法 Person(String, int)</span></span><br><span class="line">         <span class="built_in">this</span>.score = score;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果父类没有默认的构造方法，子类就必须显式调用 super() 并给出参数以便让编译器定位到父类的一个合适的构造方法。</strong></p>
</blockquote>
<p>   这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p>
<h2 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h2><p>   只要某个 class 没有 <code>final</code> 修饰符，那么任何类都可以从该 class 继承。<br>   从 Java 15 开始，允许使用 <code>sealed</code> 修饰 class，并通过 <code>permits</code> 明确写出能够从该 class 继承的子类名称。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle, Triangle &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   上述 <code>Shape</code> 类就是一个 <code>sealed</code> 类，它只允许指定的 3 个类 (<code>Rect</code>, <code>Circle</code>, <code>Triangle</code>) 继承它，否则就会报错。<br>   这种 <code>sealed</code> 类主要用于一些框架，防止继承被滥用。<code>sealed</code> 类在 Java 15 中目前是预览状态，要启用它，必须使用参数 <code>--enable-preview</code> 和 <code>--source 15</code>。</p>
<h2 id="向上转型：一个子类类型安全地变为父类类型的赋值"><a href="#向上转型：一个子类类型安全地变为父类类型的赋值" class="headerlink" title="向上转型：一个子类类型安全地变为父类类型的赋值"></a>向上转型：一个子类类型安全地变为父类类型的赋值</h2><p>   向上转型实际上是把一个子类型安全地变为更加抽象的父类型<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> p; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure><br>   <code>p</code> 也只能使用 <code>Person</code> 类中有的字段和方法，不能使用 <code>Student</code> 添加的字段和方法</p>
<h2 id="向下转型：把一个父类类型强制转型为子类类型"><a href="#向下转型：把一个父类类型强制转型为子类类型" class="headerlink" title="向下转型：把一个父类类型强制转型为子类类型"></a>向下转型：把一个父类类型强制转型为子类类型</h2><p>   不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p>
<p>   <code>instanceof</code> 实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为 null，那么对任何 <code>instanceof</code> 的判断都为 <code>false</code>。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">   <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">   <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   从 Java 14 开始，判断 <code>instanceof</code> 后，可以直接转型为指定变量，避免再次强制转型。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            <span class="comment">// 可以直接使用变量 s:</span></span><br><span class="line">            System.out.println(s.toUpperCase());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   等价于<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">   System.out.println(s.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   这个 Book 类也有 name 字段，那么，我们能不能让 Student 继承自 Book 呢？<strong>不可以</strong><br>   从逻辑上讲，这是不合理的，Student 不应该从 Book 继承，而应该从 Person 继承。<br>   究其原因，是因为 Student 是 Person 的一种，它们是 is 关系，而 Student 并不是 Book。实际上 Student 和 Book 的关系是 has 关系。<br>   具有 has 关系不应该使用继承，而是使用组合，即 Student 可以持有一个 Book 实例：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> Book book;</span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>继承是 is 关系，组合是 has 关系。</p>
</blockquote>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。</p>
<blockquote>
<p><strong>Note</strong>：方法签名不包括方法的返回类型。不包括返回值和访问修饰符。</p>
</blockquote>
<h2 id="覆写（重写、覆盖）"><a href="#覆写（重写、覆盖）" class="headerlink" title="覆写（重写、覆盖）"></a>覆写（重写、覆盖）</h2><ol>
<li><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p>
</li>
<li><p>重写（Override）和重载（Overload）<br>Override 和 Overload 不同的是，如果方法签名如果不同，就是 Overload，Overload 方法是一个新方法；如果方法签名相同，并且返回值也相同，就是 Override</p>
<p>重写： 前提是继承，两个方法的方法签名相同。至于修饰符，范围相同或者比父类的范围大即可。</p>
<p>要是重写的话，也不是必须加 @override，写 @override，这个表示编辑器会给你去父类检查重写的对不对，不写就自己检查呗。</p>
<blockquote>
<p>重写是覆盖，就是子类的替换了父类的，正常用方法，调的是子类的，所以重写完还是一个方法<br>重载是写多个同名方法，但可以给的参数不同，功能类似，所以正常调哪个方法，要看参数怎么写的，跟继承无关，区别是重载后变成多个方法。</p>
</blockquote>
</li>
<li><p>注意</p>
<ol>
<li>父类：如果是 private，那么子类就不存在重写，只是新建了个方法。但是要是 protected 的话，子类就可以重写。@override 是可以 OK 的。子类是 protected 或者 public，不可以是 private(经测试 private 类型是错误的，直接报错)。</li>
<li>在修饰符条件 OK 的情况下，发现如果可继承的要重写的方法要是返回类型不同，编辑器也是会报错的。说是重写的两个方法的返回类型冲突、不相容的，矛盾的返回类型。</li>
</ol>
</li>
</ol>
<h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">      p.run(); <span class="comment">// 打印 Student.run</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java 的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。<br>这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。</p>
</blockquote>
<h2 id="多态定义"><a href="#多态定义" class="headerlink" title="多态定义"></a>多态定义</h2><blockquote>
<p>针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTwice</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">   p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它传入的参数类型是 Person，我们是无法知道传入的参数实际类型究竟是 Person，还是 Student，还是 Person 的其他子类，因此，也无法确定调用的是不是 Person 类定义的 run() 方法。<br>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。</p>
</blockquote>
<h2 id="多态的用处"><a href="#多态的用处" class="headerlink" title="多态的用处"></a>多态的用处</h2><blockquote>
<p>我们要编写一个报税的财务软件，对于一个人的所有收入进行报税<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">      Income[] incomes = <span class="keyword">new</span> <span class="title class_">Income</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Income</span>(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Salary</span>(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StateCouncilSpecialAllowance</span>(<span class="number">15000</span>)</span><br><span class="line">      &#125;;</span><br><span class="line">      System.out.println(totalTax(incomes));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>  public static double totalTax(Income... incomes) &#123;
     double total = 0;
     for (Income income: incomes) &#123;
           total = total + income.getTax();
     &#125;
     return total;
  &#125;
</code></pre>
<p>   }</p>
<p>   class Income {<br>      protected double income;</p>
<pre><code>  public Income(double income) &#123;
     this.income = income;
  &#125;

  public double getTax() &#123;
     return income * 0.1; // 税率 10%
  &#125;
</code></pre>
<p>   }</p>
<p>   class Salary extends Income {<br>      public Salary(double income) {<br>         super(income);<br>      }</p>
<pre><code>  @Override
  public double getTax() &#123;
     if (income &lt;= 5000) &#123;
           return 0;
     &#125;
     return (income - 5000) * 0.2;
  &#125;
</code></pre>
<p>   }</p>
<p>   class StateCouncilSpecialAllowance extends Income {<br>      public StateCouncilSpecialAllowance(double income) {<br>         super(income);<br>      }</p>
<pre><code>  @Override
  public double getTax() &#123;
     return 0;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; 观察 totalTax() 方法：利用多态，totalTax() 方法只需要和 Income 打交道，它完全不需要知道 Salary 和 StateCouncilSpecialAllowance 的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从 Income 派生，然后正确覆写 getTax() 方法就可以。把新的类型传入 totalTax()，不需要修改任何代码。</span><br><span class="line"></span><br><span class="line">   &gt; *** 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 调用 super</span><br><span class="line">   ```java</span><br><span class="line">   class Person &#123;</span><br><span class="line">      protected String name;</span><br><span class="line">      public String hello() &#123;</span><br><span class="line">         return &quot;Hello,&quot; + name;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Student extends Person &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public String hello() &#123;</span><br><span class="line">         // 调用父类的 hello() 方法:</span><br><span class="line">         return super.hello() + &quot;!&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol>
<li>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为 final。用 final 修饰的方法不能被 Override：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Hello,&quot;</span> + name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="comment">// compile error: 不允许覆写</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为 final。用 final 修饰的类不能被继承：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile error: 不允许继承自 Person</span></span><br><span class="line">Student <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于一个类的实例字段，同样可以用 final 修饰。用 final 修饰的字段在初始化后不能被修改。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对 final 字段重新赋值会报错：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;New Name&quot;</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>
这样也不可以：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TestDemo1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最常用的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为可以保证实例一旦创建，其 final 字段就不可修改：</p>
</blockquote>
</li>
</ol>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><blockquote>
<p>因为可以保证实例一旦创建，其 final 字段就不可修改：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; …&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   class Student extends Person {<br>      @Override<br>      public void run() { …}<br>   }</p>
<p>   class Teacher extends Person {<br>      @Override<br>      public void run() { …}<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 从 Person 类派生的 Student 和 Teacher 都可以覆写 run() 方法。</span><br><span class="line">&gt; 如果父类 Person 的 run() 方法没有实际意义，能否去掉方法的执行语句？</span><br><span class="line">```java</span><br><span class="line">class Person &#123;</span><br><span class="line">   public void run(); // Compile Error!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。<br>而且不可以去掉父类的 <code>run()</code> 方法，因为如果去掉了父类的 <code>run()</code> 方法，就会失去多态的特性</p>
</blockquote>
<blockquote>
<p>解决办法：如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>把一个方法声明为 abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person 类也无法被实例化。编译器会告诉我们，无法编译 Person 类，因为它包含抽象方法，必须把 Person 类本身也声明为 <code>abstract</code>，才能正确编译它：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   等价于<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>区别在于：<br>前者不可以实例化，后者可以实例化</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>如果一个 class 定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用 abstract 修饰。<br>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p>
</blockquote>
<blockquote>
<p>使用 abstract 修饰的类就是抽象类。我们无法实例化一个抽象类：</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<h3 id="抽象类的用途"><a href="#抽象类的用途" class="headerlink" title="抽象类的用途"></a>抽象类的用途</h3><blockquote>
<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了 “规范”。</p>
</blockquote>
<blockquote>
<p>例如，Person 类定义了抽象方法 run()，那么，在实现子类 Student 的时候，就必须覆写 run() 方法：</p>
</blockquote>
<h2 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h2><blockquote>
<p>当我们定义了抽象类 Person，以及具体的 Student、Teacher 子类的时候，我们可以通过抽象类 Person 类型去引用具体的子类的实例：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br></pre></td></tr></table></figure><br>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心 Person 类型变量的具体子类型：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不关心 Person 变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><br>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现 run() 方法的：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这种尽量引用 ** 高层类型 **（相当于父类），避免引用 ** 实际子类型 **（相当于子类）的方式，称之为面向抽象编程。</p>
</blockquote>
<p>   面向抽象编程的本质就是：</p>
<ul>
<li>上层代码只定义规范（例如：abstract class Person）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心（个人理解：就是调用者只需要知道抽象类有什么字段和方法以及功能，不关心具体怎么实现的，可以直接调用，具体实现对调用者透明）。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>通过 abstract 定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</li>
<li>定义了抽象方法的 class 必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</li>
<li>如果不实现抽象方法，则该子类仍是一个抽象类；</li>
<li>面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><blockquote>
<p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
</blockquote>
<blockquote>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>就可以把该抽象类改写为接口： <code>interface</code> 。<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>所谓 interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是 public abstract 的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
</blockquote>
<blockquote>
<p>当一个具体的 class 去实现一个 interface 时，需要使用 implements 关键字。举个例子：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>  public Student(String name) &#123;
     this.name = name;
  &#125;

  @Override
  public void run() &#123;
     System.out.println(this.name + &quot;run&quot;);
  &#125;

  @Override
  public String getName() &#123;
     return this.name;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在 Java 中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个 interface，例如：</span><br><span class="line">```java</span><br><span class="line">class Student implements Person, Hello &#123; // 实现了两个 interface</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><blockquote>
<p>Java 的接口特指 interface 的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
</blockquote>
<blockquote>
<p>抽象类和接口的对比如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">abstract</th>
<th align="center">class</th>
<th align="center">interface</th>
</tr>
</thead>
<tbody><tr>
<td align="center">继承</td>
<td align="center">只能 extends 一个 class</td>
<td align="center">可以 implements 多个 interface</td>
</tr>
<tr>
<td align="center">字段</td>
<td align="center">可以定义实例字段</td>
<td align="center">不能定义实例字段</td>
</tr>
<tr>
<td align="center">抽象方法</td>
<td align="center">可以定义抽象方法</td>
<td align="center">可以定义抽象方法</td>
</tr>
<tr>
<td align="center">非抽象方法</td>
<td align="center">可以定义非抽象方法</td>
<td align="center">可以定义 default 方法</td>
</tr>
</tbody></table>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><blockquote>
<p>一个 interface 可以继承自另一个 interface。interface 继承自 interface 使用 extends，它相当于扩展了接口的方法。例如：</p>
</blockquote>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">   String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时，Person 接口继承自 Hello 接口，因此，Person 接口现在实际上有 3 个抽象方法签名，其中一个来自继承的 Hello 接口。</p>
</blockquote>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>合理设计 interface 和 abstract class 的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在 abstract class 中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考 Java 的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>
<img data-src="/2020/12/26/115/3.png" class="" width="3">在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 用 List 接口引用具体子类的实例</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> list; <span class="comment">// 向上转型为 Collection 接口</span></span><br><span class="line"><span class="type">Iterable</span> <span class="variable">it</span> <span class="operator">=</span> coll; <span class="comment">// 向上转型为 Iterable 接口</span></span><br></pre></td></tr></table></figure>

<h2 id="default-方法"><a href="#default-方法" class="headerlink" title="default 方法"></a>default 方法</h2><blockquote>
<p>在接口中，可以定义 default 方法。例如，把 Person 接口的 run() 方法改为 default 方法：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">      p.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   interface Person {<br>      String getName();<br>      default void run() {<br>         System.out.println(getName() + “run”);<br>      }<br>   }</p>
<p>   class Student implements Person {<br>      private String name;</p>
<pre><code>  public Student(String name) &#123;
     this.name = name;
  &#125;

  public String getName() &#123;
     return this.name;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   &gt; 实现类可以不必覆写 default 方法。default 方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是 default 方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</span><br><span class="line">   &gt; default 方法和抽象类的普通方法是有所不同的。因为 interface 没有字段，default 方法无法访问字段，而抽象类的普通方法可以访问实例字段。</span><br><span class="line"></span><br><span class="line">## 小结</span><br><span class="line">   - Java 的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；</span><br><span class="line">   - 接口也是数据类型，适用于向上转型和向下转型；</span><br><span class="line">   - 接口的所有方法都是抽象方法，接口不能定义实例字段；</span><br><span class="line">   - 接口可以定义 default 方法（JDK&gt;=1.8）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 静态字段和静态方法</span><br><span class="line"></span><br><span class="line">## 静态字段</span><br><span class="line">   &gt; 在一个 class 中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。</span><br><span class="line"></span><br><span class="line">   &gt; 还有一种字段，是用 static 修饰的字段，称为静态字段：static field。</span><br><span class="line">   &gt; 实例字段在每个实例中都有自己的一个独立 “空间”，但是静态字段只有一个共享 “空间”，所有实例都会共享该字段。举个例子：</span><br><span class="line">   ```java</span><br><span class="line">   class Person &#123;</span><br><span class="line">      public String name;</span><br><span class="line">      public int age;</span><br><span class="line">      // 定义静态字段 number:</span><br><span class="line">      public static int number;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>);</span><br><span class="line">      <span class="type">Person</span> <span class="variable">hong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Hong&quot;</span>, <span class="number">15</span>);</span><br><span class="line">      ming.number = <span class="number">88</span>;</span><br><span class="line">      System.out.println(hong.number);</span><br><span class="line">      hong.number = <span class="number">99</span>;</span><br><span class="line">      System.out.println(ming.number);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88</span><br><span class="line">99</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：<br>   <img data-src="/2020/12/26/115/4.png" class=""><br>虽然实例可以访问静态字段，但是它们指向的其实都是 <code>Person class</code> 的静态字段。所以，所有实例共享一个静态字段。<br>因此，不推荐用 <code>实例变量. 静态字段</code> 去访问静态字段，因为在 Java 程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名. 静态字段来访问静态对象。</p>
</blockquote>
<blockquote>
<p>推荐用类名来访问静态字段。可以把静态字段理解为描述 class 本身的字段（非实例字段）。对于上面的代码，更好的写法是：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.number = <span class="number">99</span>;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><blockquote>
<p>有静态字段，就有静态方法。用 static 修饰的方法称为静态方法。(废话)<br>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Person.setNumber(<span class="number">99</span>);</span><br><span class="line">      System.out.println(Person.number);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   class Person {<br>      public static int number;</p>
<pre><code>  public static void setNumber(int value) &#123;
     number = value;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   &gt; 因为静态方法属于 class 而不属于实例，因此，静态方法内部，无法访问 this 变量，也无法访问实例字段，它只能访问静态字段。</span><br><span class="line">   &gt; 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。</span><br><span class="line">   &gt; 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。</span><br><span class="line"></span><br><span class="line">   &gt; 静态方法经常用于工具类，例如：</span><br><span class="line">   - `Arrays.sort()`</span><br><span class="line">   - `Math.random()`</span><br><span class="line">   &gt; 静态方法也经常用于辅助方法。注意到 Java 程序的入口 main() 也是静态方法。</span><br><span class="line"></span><br><span class="line">## 接口的静态字段</span><br><span class="line">   &gt; 因为 interface 是一个纯抽象类，所以它不能定义实例字段。但是，interface 是可以有静态字段的，并且静态字段必须为 final 类型：</span><br><span class="line">   ```java</span><br><span class="line">   public interface Person &#123;</span><br><span class="line">      public static final int MALE = 1;</span><br><span class="line">      public static final int FEMALE = 2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>实际上，因为 interface 的字段只能是 public static final 类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="comment">// 编译器会自动加上 public statc final:</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译器会自动把该字段变为 public static final 类型。</p>
</blockquote>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>静态字段属于所有实例 “共享” 的字段，实际上是属于 class 的字段；</li>
<li>调用静态方法不需要实例，无法访问 this，但可以访问静态字段和其他静态方法；</li>
<li>静态方法常用于工具类和辅助方法。</li>
</ul>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>在前面的代码中，我们把类和接口命名为 <code>Person</code>、<code>Student</code>、<code>Hello</code> 等简单名字。</p>
<p>在现实中，如果小明写了一个 Person 类，小红也写了一个 <code>Person</code> 类，现在，小白既想用小明的 <code>Person</code>，也想用小红的 <code>Person</code>，怎么办？</p>
<p>如果小军写了一个 <code>Arrays</code> 类，恰好 JDK 也自带了一个 <code>Arrays</code> 类，如何解决类名冲突？</p>
<p>在 Java 中，我们使用 <code>package</code> 来解决名字冲突。</p>
<p>Java 定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如 <code>Person</code>）只是一个简写，真正的完整类名是包名. 类名。</p>
<p>例如：</p>
<p>小明的 <code>Person</code> 类存放在包 <code>ming</code> 下面，因此，完整类名是 <code>ming.Person</code>；</p>
<p>小红的 <code>Person</code> 类存放在包 <code>hong</code> 下面，因此，完整类名是 <code>hong.Person</code>；</p>
<p>小军的 <code>Arrays</code> 类存放在包 <code>mr.jun</code> 下面，因此，完整类名是 <code>mr.jun.Arrays</code>；</p>
<p>JDK 的 <code>Arrays</code> 类存放在包 <code>java.util</code> 下面，因此，完整类名是 <code>java.util.Arrays</code>。</p>
<p>在定义 class 的时候，我们需要在第一行声明这个 class 属于哪个包。</p>
</blockquote>
<blockquote>
<p>小明的 <code>Person.java</code> 文件<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名 ming</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   public class Person {</p>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 小军的 `Arrays.java` 文件</span><br><span class="line">```java</span><br><span class="line">package mr.jun; // 申明包名 mr.jun</span><br><span class="line"></span><br><span class="line">public class Arrays &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。</p>
</blockquote>
<blockquote>
<p>包可以是多层结构，用 <code>.</code> 隔开。例如：<code>java.util</code>。</p>
</blockquote>
<blockquote>
<p>要特别注意：包没有父子关系。<code>java.util</code> 和 <code>java.util.zip</code> 是不同的包，两者没有任何继承关系。</p>
</blockquote>
<blockquote>
<p>没有定义包名的 class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的 Java 文件组织起来。假设以 package_sample 作为根目录，src 作为源码目录，那么所有文件结构就是：</p>
</blockquote>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.java</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.java</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.java</span><br></pre></td></tr></table></figure>
<blockquote>
<p>即所有 Java 文件对应的目录层次要和包的层次一致。</p>
</blockquote>
<blockquote>
<p>编译后的 <code>.class</code> 文件也需要按照包结构存放。如果使用 IDE，把编译后的 <code>.class</code> 文件放到 bin 目录下，那么，编译的文件结构就是：</p>
</blockquote>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译的命令相对比较复杂，我们需要在 src 目录下执行 javac 命令：<br>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</span><br></pre></td></tr></table></figure><br>在 IDE 中，会自动根据包结构编译所有 Java 源码，所以不必担心使用命令行编译的复杂命令。</p>
</blockquote>
<h2 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h2><blockquote>
<p>位于同一个包的类，可以访问包作用域的字段和方法。不用 public、protected、private 修饰的字段和方法就是包作用域。例如，Person 类定义在 hello 包下面：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   public class Person {<br>      &#x2F;&#x2F; 包作用域:<br>      void hello() {<br>         System.out.println(“Hello!”);<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; Main 类也定义在 hello 包下面：</span><br><span class="line">```java</span><br><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Person p = new Person();</span><br><span class="line">      p.hello(); // 可以调用，因为 Main 和 Person 在同一个包</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><blockquote>
<p>在一个 class 中，我们总会引用其他的 class。例如，小明的 ming.Person 类，如果要引用小军的 mr.jun.Arrays 类，他有三种写法：</p>
</blockquote>
<blockquote>
<p>第一种，直接写出完整类名，例如：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   public class Person {<br>      public void run() {<br>         mr.jun.Arrays arrays &#x3D; new mr.jun.Arrays();<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 很显然，每次写完整类名比较痛苦。</span><br><span class="line">&gt; 因此，第二种写法是用 import 语句，导入小军的 Arrays，然后写简单类名：</span><br><span class="line">```java</span><br><span class="line">// Person.java</span><br><span class="line">package ming;</span><br><span class="line"></span><br><span class="line">// 导入完整类名:</span><br><span class="line">import mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      Arrays arrays = new Arrays();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在写 import 的时候，可以使用 *，表示把这个包下面的所有 class 都导入进来（但不包括子包的 class）：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   &#x2F;&#x2F; 导入 mr.jun 包的所有 class:<br>   import mr.jun.*;</p>
<p>   public class Person {<br>      public void run() {<br>         Arrays arrays &#x3D; new Arrays();<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; 我们一般不推荐这种写法，因为在导入了多个包后，很难看出 Arrays 类属于哪个包。</span><br><span class="line"></span><br><span class="line">&gt; 还有一种 import static 的语法，它可以导入可以导入一个类的静态字段和静态方法：</span><br><span class="line">```java</span><br><span class="line">package main;</span><br><span class="line"></span><br><span class="line">// 导入 System 类的所有静态字段和静态方法:</span><br><span class="line">import static java.lang.System.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      // 相当于调用 System.out.println(…)</span><br><span class="line">      out.println(&quot;Hello, world!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>import static</code> 很少使用。</p>
</blockquote>
<blockquote>
<p>Java 编译器最终编译出的 <code>.class</code> 文件只使用完整类名，因此，在代码中，当编译器遇到一个 class 名称时：</p>
</blockquote>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个 class；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前 package 是否存在这个 class；</li>
<li>查找 import 的包是否包含这个 class；</li>
<li>查找 java.lang 包是否包含这个 class。</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
</blockquote>
<blockquote>
<p>编写 class 的时候，编译器会自动帮我们做两个 import 动作：</p>
</blockquote>
<ul>
<li>默认自动 import 当前 package 的其他 class；</li>
<li>默认自动 <code>import java.lang.*</code>。</li>
</ul>
<blockquote>
<p>** 注意 **：</p>
</blockquote>
<ul>
<li>自动导入的是 <code>java.lang</code> 包，但类似 <code>java.lang.reflect</code> 这些包仍需要手动导入。</li>
<li>如果有两个 class 名称相同，例如，mr.jun.Arrays 和 java.util.Arrays，那么只能 import 其中一个，另一个必须写完整类名。</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><blockquote>
<p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
</blockquote>
<ul>
<li><code>org.apache</code></li>
<li><code>org.apache.commons.log</code></li>
<li><code>com.liaoxuefeng.sample</code><blockquote>
<p>子包就可以根据功能自行命名。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>要注意不要和 java.lang 包的类重名，即自己的类不要使用这些名字：</p>
</blockquote>
<ul>
<li><code>String</code></li>
<li><code>System</code></li>
<li><code>Runtime</code></li>
<li><code>...</code></li>
</ul>
<blockquote>
<p>要注意也不要和 JDK 常用类重名：</p>
</blockquote>
<ul>
<li><code>java.util.List</code></li>
<li><code>java.text.Format</code></li>
<li><code>java.math.BigInteger</code></li>
<li><code>...</code></li>
</ul>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Java 内建的 package 机制是为了避免 class 命名冲突；</li>
<li>JDK 的核心类使用 java.lang 包，编译器会自动导入；</li>
<li>JDK 的其它常用类定义在 java.util.*，java.math.*，java.text.*，……；</li>
<li>包名推荐使用倒置的域名，例如 org.apache。</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><blockquote>
<p>public、protected、private 这些修饰符。在 Java 中，这些修饰符可以用来限定访问作用域。</p>
</blockquote>
<h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><blockquote>
<p>定义为 public 的 class、interface 可以被其他任何类访问：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   public class Hello {<br>      public void hi() {<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; 上面的 Hello 是 public，因此，可以被其他包的类访问：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package xyz;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">   void foo() &#123;</span><br><span class="line">      // Main 可以访问 Hello</span><br><span class="line">      Hello h = new Hello();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>定义为 public 的 field、method 可以被其他类访问，前提是首先有访问 class 的权限：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   public class Hello {<br>      public void hi() {<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 上面的 hi() 方法是 public，可以被其他类调用，前提是首先要能访问 Hello 类：</span><br><span class="line">```java</span><br><span class="line">package xyz;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">   void foo() &#123;</span><br><span class="line">      Hello h = new Hello();</span><br><span class="line">      h.hi();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><blockquote>
<p>定义为 private 的 field、method 无法被其他类访问：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   public class Hello {<br>      &#x2F;&#x2F; 不能被其他类调用:<br>      private void hi() {<br>      }</p>
<pre><code>  public void hello() &#123;
     this.hi();
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; ** 实际上，确切地说，private 访问权限被限定在 class 的内部，而且与方法声明顺序无关。推荐把 private 方法放到后面，因为 public 方法定义了类对外提供的功能，阅读代码的时候，应该先关注 public 方法：**</span><br><span class="line">```java</span><br><span class="line">package abc;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">   public void hello() &#123;</span><br><span class="line">      this.hi();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void hi() &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于 Java 支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问 private 的权限：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">      i.hi();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>  // private 方法:
  private static void hello() &#123;
     System.out.println(&quot;private hello!&quot;);
  &#125;

  // 静态内部类:
  static class Inner &#123;
     public void hi() &#123;
           Main.hello();
     &#125;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   &gt; 定义在一个 `class` 内部的 `class` 称为嵌套类（nested class），Java 支持好几种嵌套类。经过自己测试： `static` 不能没有</span><br><span class="line"></span><br><span class="line">## protected</span><br><span class="line">   &gt; `protected` 作用于继承关系。定义为 `protected` 的字段和方法可以被子类访问，以及子类的子类：</span><br><span class="line">   ```java</span><br><span class="line">   package abc;</span><br><span class="line"></span><br><span class="line">   public class Hello &#123;</span><br><span class="line">      // protected 方法:</span><br><span class="line">      protected void hi() &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面的 <code>protected</code> 方法可以被继承的类访问：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   class Main extends Hello {<br>      void foo() {<br>         &#x2F;&#x2F; 可以访问 protected 方法:<br>         hi();<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## package</span><br><span class="line">   &gt; 包作用域是指一个类允许访问同一个 `package` 的没有 `public`、`private` 修饰的 `class`，以及没有 `public`、`protected`、`private` 修饰的字段和方法。但是不允许包之外的类访问。</span><br><span class="line">   ```java</span><br><span class="line">   package abc;</span><br><span class="line">   // package 权限的类:</span><br><span class="line">   class Hello &#123;</span><br><span class="line">      // package 权限的方法:</span><br><span class="line">      void hi() &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>只要在同一个包，就可以访问 package 权限的 class、field 和 method：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   class Main {<br>      void foo() {<br>         &#x2F;&#x2F; 可以访问 package 权限的类:<br>         Hello h &#x3D; new Hello();<br>         &#x2F;&#x2F; 可以调用 package 权限的方法:<br>         h.hi();<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   &gt; 注意，包名必须完全一致，包没有父子关系，`com.apache` 和 `com.apache.abc` 是不同的包</span><br><span class="line"></span><br><span class="line">## 局部变量</span><br><span class="line">   &gt; 在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</span><br><span class="line">   ```java</span><br><span class="line">   package abc;</span><br><span class="line"></span><br><span class="line">   public class Hello &#123;</span><br><span class="line">      void hi(String name) &#123; // ①</span><br><span class="line">         String s = name.toLowerCase(); // ②</span><br><span class="line">         int len = s.length(); // ③</span><br><span class="line">         if (len &lt; 10) &#123; // ④</span><br><span class="line">               int p = 10 - len; // ⑤</span><br><span class="line">               for (int i=0; i&lt;10; i++) &#123; // ⑥</span><br><span class="line">                  System.out.println(); // ⑦</span><br><span class="line">               &#125; // ⑧</span><br><span class="line">         &#125; // ⑨</span><br><span class="line">      &#125; // ⑩</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们观察上面的 hi() 方法代码：</p>
</blockquote>
<ul>
<li>方法参数 <code>name</code> 是局部变量，它的作用域是整个方法，即 <code>①～⑩</code>；</li>
<li>变量 <code>s</code> 的作用域是定义处到方法结束，即 <code>②～⑩</code>；</li>
<li>变量 <code>len</code> 的作用域是定义处到方法结束，即 <code>③～⑩</code>；</li>
<li>变量 <code>p</code> 的作用域是定义处到 <code>if</code> 块结束，即 <code>⑤～⑨</code>；</li>
<li>变量 <code>i</code> 的作用域是 <code>for</code> 循环，即 <code>⑥～⑧</code>。</li>
</ul>
<h2 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h2><blockquote>
<p>final 与访问权限不冲突，它有很多作用。</p>
</blockquote>
<blockquote>
<ol>
<li>用 <code>final</code> 修饰 <code>class</code> 可以阻止被继承：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<p>   &#x2F;&#x2F; 无法被继承:<br>   public final class Hello {<br>      private int n &#x3D; 0;<br>      protected void hi(int t) {<br>         long i &#x3D; t;<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 2. 用 `final` 修饰 `method` 可以阻止被子类覆写：</span><br><span class="line">```java</span><br><span class="line">package abc;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">   // 无法被覆写:</span><br><span class="line">   protected final void hi() &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol start="3">
<li>用 <code>final</code> 修饰 <code>field</code> 可以阻止被重新赋值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<p>   public class Hello {<br>      private final int n &#x3D; 0;<br>      protected void hi() {<br>         this.n &#x3D; 1; &#x2F;&#x2F; error!<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 4. 用 final 修饰局部变量可以阻止被重新赋值：</span><br><span class="line">```java</span><br><span class="line">package abc;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">   protected void hi(final int t) &#123;</span><br><span class="line">      t = 1; // error!</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>如果不确定是否需要 <code>public</code>，就不声明为 <code>public</code>，即尽可能少地暴露对外的字段和方法。</li>
<li>把方法定义为 <code>package</code> 权限有助于测试，因为测试类和被测试类只要位于同一个 <code>package</code>，测试代码就可以访问被测试类的 <code>package</code> 权限方法。</li>
<li>一个. java 文件只能包含一个 <code>public</code> 类，但可以包含多个非 <code>public</code> 类。如果有 <code>public</code> 类，文件名必须和 <code>public</code> 类的名字相同。</li>
</ul>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>Java 内建的访问权限包括 <code>public</code> 、 <code>protected</code> 、 <code>private</code> 和 <code>package</code> 权限；</p>
</li>
<li><p>Java 在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；</p>
</li>
<li><p>final 修饰符不是访问权限，它可以修饰 <code>class</code>、<code>field</code> 和 <code>method</code>；</p>
</li>
<li><p>一个 <code>.java</code> 文件只能包含一个 public 类，但可以包含多个非 public 类。</p>
</li>
<li><p>关于修饰符的问题：</p>
<ul>
<li><code>public</code>：包内、包外（需要 <code>import</code>）都可以访问</li>
<li><code>private</code>：只有类的内部才可以访问</li>
<li><code>protected</code>：只有类、子类、子类的子类可以访问</li>
<li>没有修饰符：只有包的内部能访问，包外不可以访问</li>
</ul>
</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><blockquote>
<p>通常情况下，我们把不同的类组织在不同的包下面，对于一个包下面的类来说，它们是在同一层次，没有父子关系：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang</span><br><span class="line">├── Math</span><br><span class="line">├── Runnable</span><br><span class="line">├── String</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><br>还有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。Java 的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。</p>
</blockquote>
<h2 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a>Inner Class</h2><blockquote>
<p>如果一个类定义在另一个类的内部，这个类就是 <code>Inner Class</code>：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">      <span class="comment">// 定义了一个 Inner Class</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述定义的 <code>Outer</code> 是一个普通类，而 <code>Inner</code> 是一个 <code>Inner Class</code>，它与普通类有个最大的不同，就是 <code>Inner Class</code> 的实例不能单独存在，必须依附于一个 <code>Outer Class</code> 的实例。示例代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个 Outer</span></span><br><span class="line">      Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个 Inner</span></span><br><span class="line">      inner.hello();</span><br><span class="line">      System.out.println(outer.age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   class Outer {<br>      private String name;<br>   public int age;</p>
<pre><code>  Outer(String name) &#123;
     this.name = name;
  &#125;

  class Inner &#123;
     void hello() &#123;
           System.out.println(&quot;Hello,&quot; + Outer.this.name);
           Outer.this.age =100; // 或者 age = 10;
     &#125;
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 观察上述代码，要实例化一个 Inner，我们必须首先创建一个 Outer 的实例，然后，调用 Outer 实例的 new 来创建 Inner 实例：</span><br><span class="line">```java</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p> 这是因为 Inner Class 除了有一个 this 指向它自己，还隐含地持有一个 Outer Class 实例，可以用 Outer.this 访问这个实例。所以，实例化一个 Inner Class 不能脱离 Outer 实例。<br>Inner Class 和普通 Class 相比，除了能引用 Outer 实例外，还有一个额外的 “特权”，就是可以修改 Outer Class 的 private 字段，因为 Inner Class 的作用域在 Outer Class 内部，所以能访问 Outer Class 的 private 字段和方法。</p>
</blockquote>
<blockquote>
<p>观察 Java 编译器编译后的. class 文件可以发现，Outer 类被编译为 Outer.class，而 Inner 类被编译为 Outer$Inner.class。</p>
</blockquote>
<h2 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class (?)"></a>Anonymous Class (?)</h2><blockquote>
<p>还有一种定义 Inner Class 的方法，它不需要在 Outer Class 中明确地定义这个 Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。示例代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">      outer.asyncHello();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   class Outer {<br>      private String name;</p>
<pre><code>  Outer(String name) &#123;
     this.name = name;
  &#125;

  void asyncHello() &#123;
     Runnable r = new Runnable() &#123;
           @Override
           public void run() &#123;
              System.out.println(&quot;Hello,&quot; + Outer.this.name);
           &#125;
     &#125;;
     new Thread(r).start();
  &#125;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 观察 `asyncHello()` 方法，我们在方法内部实例化了一个 `Runnable`。`Runnable` 本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了 `Runnable` 接口的匿名类，并且通过 new 实例化该匿名类，然后转型为 `Runnable`。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</span><br><span class="line">```java</span><br><span class="line">Runnable r = new Runnable() &#123;</span><br><span class="line">   // 实现必要的抽象方法...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>匿名类和 Inner Class 一样，可以访问 Outer Class 的 private 字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义 Inner Class 可以少写很多代码。<br>观察 Java 编译器编译后的. class 文件可以发现，Outer 类被编译为 Outer.class，而匿名类被编译为 Outer1.class。如果有多个匿名类，Java 编译器会将每个匿名类依次命名为 Outer1、Outer2、Outer3……</p>
</blockquote>
<blockquote>
<p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   public class Main {<br>      public static void main(String[] args) {<br>         HashMap&lt;String, String&gt; map1 &#x3D; new HashMap&lt;&gt;();<br>         HashMap&lt;String, String&gt; map2 &#x3D; new HashMap&lt;&gt;() {}; &#x2F;&#x2F; 匿名类!<br>         HashMap&lt;String, String&gt; map3 &#x3D; new HashMap&lt;&gt;() {<br>               {<br>                  put(“A”, “1”);<br>                  put(“B”, “2”);<br>               }<br>         };<br>         System.out.println(map3.get(“A”));<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   &gt; map1 是一个普通的 HashMap 实例，但 map2 是一个匿名类实例，只是该匿名类继承自 HashMap。map3 也是一个继承自 HashMap 的匿名类实例，并且添加了 static 代码块来初始化数据。观察编译输出可发现 Main$1.class 和 Main$2.class 两个匿名类文件。</span><br><span class="line"></span><br><span class="line">## Static Nested Class</span><br><span class="line">   &gt; 最后一种内部类和 Inner Class 类似，但是使用 static 修饰，称为静态内部类（Static Nested Class）：</span><br><span class="line">   ```java</span><br><span class="line">   public class Main &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">         Outer.StaticNested sn = new Outer.StaticNested();</span><br><span class="line">         sn.hello();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class Outer &#123;</span><br><span class="line">      private static String NAME = &quot;OUTER&quot;;</span><br><span class="line"></span><br><span class="line">      private String name;</span><br><span class="line"></span><br><span class="line">      Outer(String name) &#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static class StaticNested &#123;</span><br><span class="line">         void hello() &#123;</span><br><span class="line">             System.out.println(&quot;Hello,&quot; + Outer.NAME);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>用 static 修饰的内部类和 Inner Class 有很大的不同，它不再依附于 Outer 的实例，而是一个完全独立的类，因此无法引用 Outer.this，但它可以访问 Outer 的 private 静态字段和静态方法。如果把 StaticNested 移到 Outer 之外，就失去了访问 private 的权限。</p>
</blockquote>
<blockquote>
<p>但是在实例化 <code>静态内部类</code> 的时候，也会实例化一个 <code>Outer</code></p>
</blockquote>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>Java 的内部类可分为 Inner Class、Anonymous Class 和 Static Nested Class 三种：</p>
</blockquote>
<ul>
<li>Inner Class 和 Anonymous Class 本质上是相同的，都必须依附于 Outer Class 的实例，即隐含地持有 Outer.this 实例，并拥有 Outer Class 的 private 访问权限；</li>
<li>Static Nested Class 是独立类，但拥有 Outer Class 的 private 访问权限。</li>
</ul>
<h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><blockquote>
<p>内部类就是在一个类的内部再定义一个类。比如：A类中定义一个B类，那么B类相对于A类来说就称为内部类，而A类相对于B类来说就是外部类了。</p>
</blockquote>
<h1 id="classpath-和-jar"><a href="#classpath-和-jar" class="headerlink" title="classpath 和 jar"></a>classpath 和 jar</h1><h2 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h2><blockquote>
<p>在 Java 中，我们经常听到 <code>classpath</code> 这个东西。网上有很多关于 “如何设置 classpath” 的文章，但大部分设置都不靠谱。到底什么是 <code>classpath</code>？<br><code>classpath</code> 是 <code>JVM</code> 用到的一个环境变量，它用来指示 JVM 如何搜索 <code>class</code>。</p>
</blockquote>
<blockquote>
<p>因为 Java 是编译型语言，源码文件是 <code>.java</code>，而编译后的 <code>.class</code> 文件才是真正可以被 JVM 执行的字节码。因此，JVM 需要知道，如果要加载一个 <code>abc.xyz.Hello</code> 的类，应该去哪搜索对应的 <code>Hello.class</code> 文件。<br>所以，<code>classpath</code> 就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在 <code>Windows</code> 系统上，用 <code>;</code> 分隔，带空格的目录用 <code>&quot;&quot;</code> 括起来，可能长这样：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work\project1\bin;C:\shared;&quot;D:\My Documents\project1\bin&quot;</span><br></pre></td></tr></table></figure><br>在 Linux 系统上，用: 分隔，可能长这样：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</span><br></pre></td></tr></table></figure><br>现在我们假设 <code>classpath</code> 是 <code>.;C:\work\project1\bin;C:\shared</code>，当 <code>JVM</code> 在加载 <code>abc.xyz.Hello</code> 这个类时，会依次查找：</p>
</blockquote>
<ul>
<li><code>&lt;当前目录&gt;\abc\xyz\Hello.class</code></li>
<li><code>C:\work\project1\bin\abc\xyz\Hello.class</code></li>
<li><code>C:\shared\abc\xyz\Hello.class</code><blockquote>
<p>注意到 <code>.</code> 代表当前目录。如果 JVM 在某个路径下找到了对应的 class 文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>classpath 的设定方法有两种：</p>
</blockquote>
<ul>
<li>在系统环境变量中设置 classpath 环境变量，不推荐；</li>
<li>在启动 JVM 时设置 classpath 变量，推荐。</li>
</ul>
<blockquote>
<p>我们强烈不推荐在系统环境变量中设置 classpath，那样会污染整个系统环境。在启动 JVM 时设置 classpath 才是推荐的做法。实际上就是给 java 命令传入 <code>-classpath</code> 或 <code>-cp</code> 参数：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure><br>或者使用 <code>-cp</code> 的简写：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure><br>没有设置系统环境变量，也没有传入 <code>-cp</code> 参数，那么 JVM 默认的 classpath 为.，即当前目录：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java abc.xyz.Hello</span><br></pre></td></tr></table></figure><br>上述命令告诉 JVM 只在当前目录搜索 <code>Hello.class</code>。</p>
</blockquote>
<blockquote>
<p>在 IDE 中运行 Java 程序，IDE 自动传入的 - cp 参数是当前工程的 bin 目录和引入的 jar 包。<br>通常，我们在自己编写的 <code>class</code> 中，会引用 Java 核心库的 class，例如，<code>String</code>、<code>ArrayList</code> 等。这些 <code>class</code> 应该上哪去找？<br>有很多 “如何设置 classpath” 的文章会告诉你把 JVM 自带的 rt.jar 放入 classpath，但事实上，根本不需要告诉 JVM 如何去 Java 核心库查找 class，JVM 怎么可能笨到连自己的核心库在哪都不知道？</p>
</blockquote>
<blockquote>
<p><strong>Note: 不要把任何 Java 核心库添加到 classpath 中！JVM 根本不依赖 classpath 加载核心库！</strong></p>
</blockquote>
<blockquote>
<p>更好的做法是，不要设置 classpath！默认的当前目录. 对于绝大多数情况都够用了。<br>假设我们有一个编译后的 Hello.class，它的包名是 com.example，当前目录是 C:\work，那么，目录结构必须如下：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\work</span><br><span class="line">└─ com</span><br><span class="line">   └─ example</span><br><span class="line">      └─ Hello.class</span><br></pre></td></tr></table></figure><br>运行这个 Hello.class 必须在当前目录下使用如下命令：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work&gt; java -cp . com.example.Hello</span><br></pre></td></tr></table></figure><br>JVM 根据 classpath 设置的. 在当前目录下查找 <code>com.example.Hello</code>，即实际搜索文件必须位于 <code>com/example/Hello.class</code>。如果指定的. class 文件不存在，或者目录结构和包名对不上，均会报错。</p>
</blockquote>
<h2 id="jar-包"><a href="#jar-包" class="headerlink" title="jar 包"></a>jar 包</h2><blockquote>
<p>如果有很多 <code>.class</code> 文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。<br>jar 包就是用来干这个事的，它可以把 package 组织的目录层级，以及各个目录下的所有文件（包括. class 文件和其他文件）都打成一个 jar 文件，这样一来，无论是备份，还是发给客户，就简单多了。<br>jar 包实际上就是一个 zip 格式的压缩文件，而 jar 包相当于目录。如果我们要执行一个 jar 包的 class，就可以把 jar 包放到 <code>classpath</code> 中：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure><br>这样 JVM 会自动在 hello.jar 文件里去搜索某个类。</p>
</blockquote>
<blockquote>
<p>那么问题来了：如何创建 jar 包？<br>因为 jar 包就是 zip 包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择 “发送到”，<code>“压缩 (zipped) 文件夹”</code>，就制作了一个 zip 文件。然后，把后缀从 <code>.zip</code> 改为 <code>.jar</code>，一个 jar 包就创建成功。</p>
</blockquote>
<blockquote>
<p>假设编译输出的目录结构是这样：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure><br>这里需要特别注意的是，jar 包里的第一层目录，不能是 <code>bin</code>，而应该是 <code>hong</code>、<code>ming</code>、<code>mr</code>。如果在 Windows 的资源管理器中看，应该长这样：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">└─ hello.zip</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure><br>   如果长这样：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">└─ hello.zip</span><br><span class="line">   └─ bin</span><br><span class="line">      ├─ hong</span><br><span class="line">      │  └─ Person.class</span><br><span class="line">      │  ming</span><br><span class="line">      │  └─ Person.class</span><br><span class="line">      └─ mr</span><br><span class="line">         └─ jun</span><br><span class="line">            └─ Arrays.class</span><br></pre></td></tr></table></figure><br>说明打包打得有问题，JVM 仍然无法从 jar 包中查找正确的 class，原因是 <code>hong.Person</code> 必须按 <code>hong/Person.class</code> 存放，而不是 <code>bin/hong/Person.class</code></p>
</blockquote>
<blockquote>
<p>jar 包还可以包含一个特殊的 <code>/META-INF/MANIFEST.MF</code> 文件，<code>MANIFEST.MF</code> 是纯文本，可以指定 <code>Main-Class</code> 和其它信息。JVM 会自动读取这个 <code>MANIFEST.MF</code> 文件，如果存在 <code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure><br>jar 包还可以包含其它 jar 包，这个时候，就需要在 <code>MANIFEST.MF</code> 文件里配置 <code>classpath</code> 了。<br>在大型项目中，不可能手动编写 <code>MANIFEST.MF</code> 文件，再手动创建 zip 包。Java 社区提供了大量的开源构建工具，例如 <code>Maven</code>，可以非常方便地创建 jar 包。</p>
</blockquote>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><ul>
<li>JVM 通过环境变量 classpath 决定搜索 class 的路径和顺序；</li>
<li>不推荐设置系统环境变量 classpath，始终建议通过 - cp 命令传入；</li>
<li>jar 包相当于目录，可以包含很多 <code>.class</code> 文件，方便下载和使用；</li>
<li><code>MANIFEST.MF</code> 文件可以提供 jar 包的信息，如 <code>Main-Class</code>，这样可以直接运行 jar 包。</li>
</ul>
<h2 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h2><ul>
<li><code>idea</code> 软件中 <code>.class</code> 在根目录的 <code>out -&gt; production</code> 文件下</li>
<li>个人理解 <code>jar 包 </code>： 就是将目录下的类打包，供其他人使用的，可以直接调用的压缩包文件</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>我的目录<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IdeaTestProjects</span><br><span class="line">    └─class2</span><br><span class="line">        └─unit10</span><br><span class="line">             ├─test1</span><br><span class="line">             │   └─Main.class</span><br><span class="line">             │   └─Person.class</span><br><span class="line">             │</span><br><span class="line">             └─test2</span><br><span class="line">                 └─TestMain.class</span><br></pre></td></tr></table></figure><br>将文件夹 <code>IdeaTestProjects</code> 打包 <code>zip</code> 文件，再将后缀名改为 <code>jar</code>, 然后运行如下命令<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp IdeaTestProjects.jar class2.unit10.test1.Main</span><br></pre></td></tr></table></figure><br>输出结果为：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name: Qeuro</span><br><span class="line">age: 23</span><br><span class="line">name: qeuro</span><br><span class="line">age: 23</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><blockquote>
<p>一个 <code>class</code> 类是一个 java 文件，后缀名为 <code>.java</code>，编译之后生成 <code>.class</code> 文件，而这个 <code>.class</code> 文件才真正可以被 JVM 执行的字节码。</p>
</blockquote>
<h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>从 Java 9 开始，JDK 又引入了模块（Module）。<br>什么是模块？这要从 Java 9 之前的版本说起。<br>我们知道，<code>.class</code> 文件是 JVM 看到的最小可执行文件，而一个大型程序需要编写很多 Class，并生成一堆 <code>.class</code> 文件，很不便于管理，所以，<code>jar</code> 文件就是 <code>.class</code> 文件的容器。<br>在 <code>Java 9</code> 之前，一个大型 <code>Java</code> 程序会生成自己的 <code>jar</code> 文件，同时引用依赖的第三方 <code>jar</code> 文件，而 <code>JVM</code> 自带的 <code>Java</code> 标准库，实际上也是以 <code>jar</code> 文件形式存放的，这个文件叫 <code>rt.jar</code>，一共有 60 多 M。<br>如果是自己开发的程序，除了一个自己的 <code>app.jar</code> 以外，还需要一堆第三方的 jar 包，运行一个 Java 程序，一般来说，命令行写这样：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note: JVM 自带的标准库 <code>rt.jar</code> 不要写到 <code>classpath</code> 中，写了反而会干扰 JVM 的正常运行。</strong></p>
</blockquote>
<blockquote>
<p>如果漏写了某个运行时需要用到的 jar，那么在运行期极有可能抛出 <code>ClassNotFoundException</code>。<br>所以，jar 只是用于存放 class 的容器，它并不关心 class 之间的依赖。</p>
</blockquote>
<blockquote>
<p>从 Java 9 开始引入的模块，主要是为了解决 <code>“依赖”</code> 这个问题。如果 <code>a.jar</code> 必须依赖另一个 <code>b.jar</code> 才能运行，那我们应该给 <code>a.jar</code> 加点说明啥的，让程序在编译和运行的时候能自动定位到 <code>b.jar</code>，这种自带 “依赖关系” 的 class 容器就是模块。<br>为了表明 Java 模块化的决心，从 Java 9 开始，原有的 Java 标准库已经由一个单一巨大的 <code>rt.jar</code> 分拆成了几十个模块，这些模块以 <code>.jmod</code> 扩展名标识，可以在 <code>$JAVA_HOME/jmods</code> 目录下找到它们：<br>     - <code>java.base.jmod</code><br>     - <code>java.compiler.jmod</code><br>     - <code>java.datatransfer.jmod</code><br>     - <code>java.desktop.jmod</code><br>     - <code>...</code></p>
</blockquote>
<blockquote>
<p>这些 <code>.jmod</code> 文件每一个都是一个模块，模块名就是文件名。例如：模块 <code>java.base</code> 对应的文件就是 <code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的 <code>module-info.class</code> 文件了。所有的模块都直接或间接地依赖 <code>java.base</code> 模块，只有 <code>java.base</code> 模块不依赖任何模块，它可以被看作是 “根模块”，好比所有的类都是从 <code>Object</code> 直接或间接继承而来。<br>把一堆 class 封装为 jar 仅仅是一个打包的过程，而把一堆 class 封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是 JNI 扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的 JVM 提供不同的版本。</p>
</blockquote>
<h2 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h2><blockquote>
<p>如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建 Java 项目是完全一样的，以 <code>oop-module</code> 工程为例，它的目录结构如下：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">├── build.sh</span><br><span class="line">└── src</span><br><span class="line">   ├── com</span><br><span class="line">   │   └── itranswarp</span><br><span class="line">   │       └── sample</span><br><span class="line">   │           ├── Greeting.java</span><br><span class="line">   │           └── Main.java</span><br><span class="line">   └── module-info.java</span><br></pre></td></tr></table></figure><br>其中，<code>bin</code> 目录存放编译后的 <code>.class</code> 文件，<code>src</code> 目录存放源码，按包名的目录结构存放，仅仅在 <code>src</code> 目录下多了一个 <code>module-info.java</code> 这个文件，这就是模块的描述文件。在这个模块中，它长这样：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">   <span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入 java.base</span></span><br><span class="line">   <span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中，<code>module</code> 是关键字，后面的 <code>hello.world</code> 是模块的名称，它的命名规范与包一致。花括号的 <code>requires xxx;</code> 表示这个模块需要引用的其他模块名。除了 <code>java.base</code> 可以被自动引入外，这里我们引入了一个 <code>java.xml</code> 的模块。</p>
</blockquote>
<blockquote>
<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code> 代码如下：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>   &#x2F;&#x2F; 必须引入 java.xml 模块后才能使用其中的类:<br>   import javax.xml.XMLConstants;</p>
<p>   public class Main {<br>      public static void main(String[] args) {<br>         Greeting g &#x3D; new Greeting();<br>         System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));<br>      }<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果把 `requires java.xml;` 从 `module-info.java` 中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</span><br><span class="line"></span><br><span class="line">&gt; 下面，我们用 JDK 提供的命令行工具来编译并创建模块。</span><br><span class="line">&gt; 首先，我们把工作目录切换到 `oop-module`，在当前目录下编译所有的 `.java` 文件，并存放到 `bin` 目录下，命令如下：</span><br></pre></td></tr></table></figure><br>   javac -d bin src&#x2F;module-info.java src&#x2F;com&#x2F;itranswarp&#x2F;sample&#x2F;*.java<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果编译成功，现在项目结构如下：</span><br></pre></td></tr></table></figure><br>   oop-module<br>   ├── bin<br>   │   ├── com<br>   │   │   └── itranswarp<br>   │   │       └── sample<br>   │   │           ├── Greeting.class<br>   │   │           └── Main.class<br>   │   └── module-info.class<br>   └── src<br>      ├── com<br>      │   └── itranswarp<br>      │       └── sample<br>      │           ├── Greeting.java<br>      │           └── Main.java<br>      └── module-info.java<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 注意到 `src` 目录下的 `module-info.java` 被编译到 `bin` 目录下的 `module-info.class`。</span><br><span class="line"></span><br><span class="line">&gt; 下一步，我们需要把 `bin` 目录下的所有 `class` 文件先打包成 `jar`，在打包的时候，注意传入 `--main-class` 参数，让这个 `jar` 包能自己定位 `main` 方法所在的类：</span><br></pre></td></tr></table></figure><br>   jar –create –file hello.jar –main-class com.itranswarp.sample.Main -C bin .<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 现在我们就在当前目录下得到了 `hello.jar` 这个 `jar` 包，它和普通 `jar` 包并无区别，可以直接使用命令 `java -jar hello.jar` 来运行它。但是我们的目标是创建模块，所以，继续使用 `JDK` 自带的 jmod 命令把一个 `jar` 包转换成模块：</span><br></pre></td></tr></table></figure><br>   jmod create –class-path hello.jar hello.jmod<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   &gt; 于是，在当前目录下我们又得到了 `hello.jmod` 这个模块文件，这就是最后打包出来的传说中的模块！</span><br><span class="line"></span><br><span class="line">## 运行模块</span><br><span class="line">   &gt; 要运行一个 jar，我们使用 `java -jar xxx.jar` 命令。要运行一个模块，我们只需要指定模块名。试试：</span><br></pre></td></tr></table></figure><br>   java –module-path hello.jmod –module hello.world<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 结果是一个错误：</span><br></pre></td></tr></table></figure><br>   Error occurred during initialization of boot layer<br>   java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 原因是 `.jmod` 不能被放入 `--module-path` 中。换成 `.jar` 就没问题了：</span><br></pre></td></tr></table></figure><br>   $ java –module-path hello.jar –module hello.world<br>   Hello, xml!<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   &gt; 那我们辛辛苦苦创建的 hello.jmod 有什么用？** 答案是我们可以用它来打包 JRE。**</span><br><span class="line"></span><br><span class="line">## 打包 JRE</span><br><span class="line">   前面讲了，为了支持模块化，Java 9 首先带头把自己的一个巨大无比的 rt.jar 拆成了几十个. jmod 模块，原因就是，运行 Java 程序的时候，实际上我们用到的 JDK 模块，并没有那么多。不需要的模块，完全可以删除。</span><br><span class="line">   过去发布一个 Java 应用程序，要运行它，必须下载一个完整的 JRE，再运行 jar 包。而完整的 JRE 块头很大，有 `100+M`。怎么给 JRE 瘦身呢？</span><br><span class="line">   现在，JRE 自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪 JRE 呢？并不是说把系统安装的 JRE 给删掉部分模块，而是 “复制” 一份 JRE，但只带上用到的模块。为此，JDK 提供了 `jlink` 命令来干这件事。命令如下：</span><br></pre></td></tr></table></figure><br>   jlink –module-path hello.jmod –add-modules java.base,java.xml,hello.world –output jre&#x2F;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们在 `--module-path` 参数指定了我们自己的模块 `hello.jmod`，然后，在 `--add-modules` 参数中指定了我们用到的 3 个模块 `java.base`、`java.xml` 和 `hello.world`，用 `,` 分隔。最后，在 `--output` 参数指定输出目录。</span><br><span class="line">现在，在当前目录下，我们可以找到 jre 目录，这是一个完整的并且带有我们自己 `hello.jmod` 模块的 JRE。试试直接运行这个 JRE：</span><br></pre></td></tr></table></figure><br>   $ jre&#x2F;bin&#x2F;java –module hello.world<br>   Hello, xml!<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   要分发我们自己的 `Java` 应用程序，只需要把这个 `jre` 目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装 `JDK`，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</span><br><span class="line"></span><br><span class="line">## 访问权限</span><br><span class="line">   前面我们讲过，`Java` 的 `class` 访问权限分为 `public`、`protected`、`private` 和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</span><br><span class="line">   确切地说，`class` 的这些访问权限只在一个模块内有效，模块和模块之间，例如，`a` 模块要访问 `b` 模块的某个 `class`，必要条件是 `b` 模块明确地导出了可以访问的包。</span><br><span class="line"></span><br><span class="line">   举个例子：我们编写的模块 `hello.world` 用到了模块 `java.xml` 的一个类 `javax.xml.XMLConstants`，我们之所以能直接使用这个类，是因为模块 `java.xml` 的 `module-info.java` 中声明了若干导出：</span><br></pre></td></tr></table></figure><br>   module java.xml {<br>      exports java.xml;<br>      exports javax.xml.catalog;<br>      exports javax.xml.datatype;<br>      …<br>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的 `hello.world` 模块中的 `com.itranswarp.sample.Greeting` 类，我们必须将其导出：</span><br></pre></td></tr></table></figure><br>   module hello.world {<br>      exports com.itranswarp.sample;</p>
<pre><code>  requires java.base;
  requires java.xml;
</code></pre>
<p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因此，模块进一步隔离了代码的访问权限。</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Qeuroal
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://qeuroal.top/2020/12/26/115/" title="115. Java 面向对象">http://qeuroal.top/2020/12/26/115/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/03/114/" rel="prev" title="114. C/C++ 常用注释命令">
                  <i class="fa fa-angle-left"></i> 114. C/C++ 常用注释命令
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/01/05/117/" rel="next" title="117. Java 核心类">
                  117. Java 核心类 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Qeuroal</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Qeuroal" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
